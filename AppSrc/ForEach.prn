Compiling Program: C:\data\VDF\ForEach\AppSrc\ForEach.src
Memory Available: 2147483647
1>Use Windows.pkg
Using pre-compiled package WINDOWS.PKG
Including file: windows.pkd    (C:\Program Files (x86)\Visual DataFlex 17.1\Pkg\windows.pkd)
6781>Use cHtmlHelp.pkg
Including file: cHtmlHelp.pkg    (C:\Program Files (x86)\Visual DataFlex 17.1\Pkg\cHtmlHelp.pkg)
6781>>>Use windows.pkg
6781>>>Use LanguageText.pkg
6781>>>Use cHtmlHelp.inc // API Functions and Constants, etc.
Including file: cHtmlHelp.inc    (C:\Program Files (x86)\Visual DataFlex 17.1\Pkg\cHtmlHelp.inc)
6781>>>>>External_Function HtmlHelp "HtmlHelpA" HHCTRL.OCX ;    Handle hwndCaller ;    String pszFile ;    Integer uCommand ;    Integer dwData ;    Returns Handle
6782>>>>>
6782>>>>>// Declarations. Note HH_DISPLAY_TOPIC and HH_HELP_FINDER perform the same function for backward compatibility
6782>>>>>DEFINE HH_DISPLAY_TOPIC         FOR |CI$0000
6782>>>>>DEFINE HH_HELP_FINDER           FOR |CI$0000
6782>>>>>DEFINE HH_DISPLAY_TOC           FOR |CI$0001
6782>>>>>DEFINE HH_DISPLAY_INDEX         FOR |CI$0002
6782>>>>>DEFINE HH_DISPLAY_SEARCH        FOR |CI$0003
6782>>>>>DEFINE HH_SET_WIN_TYPE          FOR |CI$0004
6782>>>>>DEFINE HH_GET_WIN_TYPE          FOR |CI$0005
6782>>>>>DEFINE HH_GET_WIN_HANDLE        FOR |CI$0006
6782>>>>>DEFINE HH_ENUM_INFO_TYPE        FOR |CI$0007
6782>>>>>DEFINE HH_SET_INFO_TYPE         FOR |CI$0008
6782>>>>>DEFINE HH_SYNC                  FOR |CI$0009
6782>>>>>DEFINE HH_KEYWORD_LOOKUP        FOR |CI$000D
6782>>>>>DEFINE HH_DISPLAY_TEXT_POPUP    FOR |CI$000E
6782>>>>>DEFINE HH_HELP_CONTEXT          FOR |CI$000F
6782>>>>>DEFINE HH_TP_HELP_CONTEXTMENU   FOR |CI$0010
6782>>>>>DEFINE HH_TP_HELP_WM_HELP       FOR |CI$0011
6782>>>>>DEFINE HH_CLOSE_ALL             FOR |CI$0012
6782>>>>>DEFINE HH_ALINK_LOOKUP          FOR |CI$0013
6782>>>>>DEFINE HH_GET_LAST_ERROR        FOR |CI$0014
6782>>>>>DEFINE HH_ENUM_CATEGORY         FOR |CI$0015
6782>>>>>DEFINE HH_ENUM_CATEGORY_IT      FOR |CI$0016
6782>>>>>DEFINE HH_RESET_IT_FILTER       FOR |CI$0017
6782>>>>>DEFINE HH_SET_INCLUSIVE_FILTER  FOR |CI$0018
6782>>>>>DEFINE HH_SET_EXCLUSIVE_FILTER  FOR |CI$0019
6782>>>>>DEFINE HH_INITIALIZE            FOR |CI$001C
6782>>>>>DEFINE HH_UNINITIALIZE          FOR |CI$001D
6782>>>>>DEFINE HH_PRETRANSLATEMESSAGE   FOR |CI$00FD
6782>>>>>DEFINE HH_SET_GLOBAL_PROPERTY   FOR |CI$00FC
6782>>>>>
6782>>>>>Type tAkLink
6782>>>>>    Field tAkLink.cbStruct     as DWord
6782>>>>>    Field tAkLink.fReserved    as DWord
6782>>>>>    Field tAkLink.pszKeywords  as Pointer
6782>>>>>    Field tAkLink.pszUrl       as Pointer
6782>>>>>    Field tAkLink.pszMsgText   as Pointer
6782>>>>>    Field tAkLink.pszMsgTitle  as Pointer
6782>>>>>    Field tAkLink.pszWindow    as Pointer
6782>>>>>    Field tAkLink.fIndexOnFail as DWord
6782>>>>>End_Type
6782>>>Use GlobalFunctionsProcedures.pkg
6782>>>Use HelpSystemConstants.pkg
6782>>>
6782>>>Register_function phoMainPanel returns integer
6782>>>
6782>>>
6782>>>Class cHtmlHelp is a cObject
6783>>>    Procedure Construct_Object
6785>>>        Forward Send Construct_Object
6787>>>
6787>>>
6787>>>        Move self To ghoHtmlHelp // registers the object-handle globally
6788>>>
6788>>>        Property String  psHelpFile ""
6789>>>        Property Handle  phoOwner           // object that is the owner of the HTML help window
6790>>>        Property Boolean pbAlwaysOnTop True // if true, help is always on top.
6791>>>
6791>>>        Property integer private_piCookie
6792>>>
6792>>>        Send DoInitialize
6793>>>
6793>>>    End_Procedure
6794>>>
6794>>>    Procedure Destroy_Object
6796>>>        Send DoDeInitialize
6797>>>        Forward Send Destroy_Object
6799>>>    End_Procedure
6800>>>
6800>>>    // get owner's window handle. if phoOwner not defined use
6800>>>    // handle of application objects phoMainPanel. If no owner return 0
6800>>>    Function GetOwnerWindowHandle Returns Integer
6802>>>        Handle hoOwner
6802>>>        // if not always on top we want to use the windows desktop window handle. When the desktop is the owner
6802>>>        // you don't get on-top behavior and the help windows does not minimize when you minimize
6802>>>        // main program. When the Main panel has the focus, you get the on-top behavior.
6802>>>        If (pbAlwaysOnTop(self)) begin
6804>>>            Get phoOwner To hoOwner
6805>>>            If (hoOwner=0 And ghoApplication) ;                Get phoMainPanel Of ghoApplication To hoOwner
6808>>>            If hoOwner ;                Get window_handle Of hoOwner To hoOwner // the DF objects window handle
6811>>>        end
6811>>>>
6811>>>        // owner will be 0, if we could not find a main active handle or, the more likely
6811>>>        // case, pbAlwaysOnTop is set false. Using the windows destkop stops help on top.
6811>>>        If (hoOwner=0) Begin
6813>>>            Move (GetDesktopWindow()) To hoOwner
6814>>>        End
6814>>>>
6814>>>        Function_Return hoOwner
6815>>>    End_Function  // GetOwnerWindowHandle
6816>>>
6816>>>    Function GetHelpFile Returns String
6818>>>        String sHelpFile
6818>>>        Get psHelpFile to sHelpFile
6819>>>        // if name is not directly set object, see if we can get it from the application object
6819>>>        If (sHelpFile="" and ghoApplication and peHelpType(ghoApplication)=htHtmlHelp);            Get psHelpFile of ghoApplication to sHelpFile
6822>>>        If (sHelpFile<>"") Get_File_Path sHelpFile To sHelpFile
6825>>>        Function_Return sHelpFile
6826>>>    End_Function
6827>>>
6827>>>    // 5.19.2004 - It appears that using hh_initialize/hh_uninitialze causes keyboard problems with
6827>>>    // embedded help which causing ctrl+c to not work. According to messages found on a Newsgroup this
6827>>>    // is a known issue and that not using these is the solution. The general advice was to stay
6827>>>    // away from these messages - and it does seem to solve the problem (jjt)
6827>>>
6827>>>    Procedure DoInitialize
6829>>>//        //Must be sent before any HTML commands can be used
6829>>>//        Handle hRetVal
6829>>>//        Integer dwCookie
6829>>>//        String sBuffer
6829>>>//        Pointer pBuffer
6829>>>
6829>>>//        Zerotype tDWORD TO sBuffer
6829>>>//        GetAddress OF sBuffer TO pBuffer
6829>>>
6829>>>//        Move (HtmlHelp(0, "", HH_INITIALIZE, pBuffer)) TO hRetVal
6829>>>//        GetBuff From sBuffer AT tDWORD.DWord TO dwCookie
6829>>>//        Set private_piCookie TO dwCookie
6829>>>    End_Procedure
6830>>>
6830>>>    Procedure DoDeInitialize
6832>>>//        //Must be sent to free resources
6832>>>//        Dword dwCookie
6832>>>//        Handle hRetVal
6832>>>//        String sHelpFile
6832>>>//        Get private_piCookie TO dwCookie
6832>>>
6832>>>//        Move (HtmlHelp(0, "", HH_UNINITIALIZE, dwCookie))TO hRetVal
6832>>>    End_Procedure
6833>>>
6833>>>    Procedure DoDisplayTopic String sTopic
6835>>>        //Most-used command. Pops up the tri-pane Help Viewer.
6835>>>        Handle hRetVal
6835>>>        Pointer psTopic
6835>>>        String sHelpFile
6835>>>        GetAddress OF sTopic TO psTopic
6836>>>        Get GetHelpFile To sHelpFile
6837>>>        If (sHelpFile<>"") Begin
6839>>>            Move (HtmlHelp(GetOwnerWindowHandle(Self), sHelpFile, HH_DISPLAY_TOPIC, psTopic)) TO hRetVal
6840>>>        end
6840>>>>
6840>>>    End_Procedure
6841>>>
6841>>>    Procedure DoDisplayIndex
6843>>>        //Another commonly-used command. Pops up the topic for the current index entry.
6843>>>        Handle hRetVal
6843>>>        String sHelpFile
6843>>>        Get GetHelpFile To sHelpFile
6844>>>        If (sHelpFile<>"") Begin
6846>>>            Move (HtmlHelp(GetOwnerWindowHandle(Self), sHelpFile, HH_DISPLAY_INDEX, 0)) TO hRetVal
6847>>>        end
6847>>>>
6847>>>    End_Procedure
6848>>>
6848>>>    Procedure DoDisplayIndexString String sIndex
6850>>>        //Another commonly-used command. Shows the Index, and highlights the sIndex entry
6850>>>        Handle hRetVal
6850>>>        String sHelpFile
6850>>>        Pointer lpsIndex
6850>>>        GetAddress of sIndex To lpsIndex
6851>>>        Get GetHelpFile To sHelpFile
6852>>>        If (sHelpFile<>"") Begin
6854>>>            Move (HtmlHelp(GetOwnerWindowHandle(Self), sHelpFile, HH_DISPLAY_INDEX, lpsIndex)) TO hRetVal
6855>>>        End
6855>>>>
6855>>>    End_Procedure
6856>>>
6856>>>    Procedure DoShowMapId Integer iMapID
6858>>>        //Passed an integer of the MapID allocated to the topic
6858>>>        Handle hRetVal
6858>>>        String sHelpFile
6858>>>        Get GetHelpFile To sHelpFile
6859>>>
6859>>>        If (sHelpFile<>"") Begin
6861>>>            Move (HtmlHelp(GetOwnerWindowHandle(Self), sHelpFile, HH_HELP_CONTEXT, iMapID)) To hRetVal
6862>>>            Send DoDisplayTOC
6863>>>            //Send DoSyncToc
6863>>>        End
6863>>>>
6863>>>    End_Procedure
6864>>>
6864>>>    Procedure DoDisplayKeyword String sKeyword
6866>>>        Handle hRetVal
6866>>>        Pointer lpsKeyword lpsAkLink lpsErrorText
6866>>>        String sHelpFile sAkLink sErrorText
6866>>>        GetAddress OF sKeyword TO lpsKeyword
6867>>>        Get GetHelpFile To sHelpFile
6868>>>        If (sHelpFile<>"") Begin
6870>>>
6870>>>            Move (SFormat(C_$SorryIsNotInTheIndex, sKeyword)) To sErrorText
6871>>>            GetAddress of sErrorText To lpsErrorText
6872>>>
6872>>>            ZeroType tAkLink To sAkLink
6873>>>            Put tAkLink_Size To sAkLink At tAkLink.cbStruct
6874>>>            Put 0            To sAkLink At tAkLink.fReserved
6875>>>            Put lpsKeyword   To sAkLink At tAkLink.pszKeywords
6876>>>            Put 0            To sAkLink At tAkLink.pszUrl
6877>>>            //Put lpsErrorText  To sAkLink At tAkLink.pszMsgText
6877>>>            Put 0  To sAkLink At tAkLink.pszMsgText
6878>>>            Put 0            To sAkLink At tAkLink.pszMsgTitle
6879>>>            Put 0            To sAkLink At tAkLink.pszWindow
6880>>>            Put 0            To sAkLink At tAkLink.fIndexOnFail
6881>>>
6881>>>            GetAddress of sAkLink To lpsAkLink
6882>>>
6882>>>            Send DoDisplayIndexString sKeyword
6883>>>            Move (HtmlHelp(GetOwnerWindowHandle(Self), sHelpFile, HH_KEYWORD_LOOKUP, lpsAkLink)) TO hRetVal
6884>>>        End
6884>>>>
6884>>>    End_Procedure
6885>>>
6885>>>    Procedure DoDisplayTOC
6887>>>        Handle hRetVal
6887>>>        String sHelpFile
6887>>>        Get GetHelpFile To sHelpFile
6888>>>        If (sHelpFile<>"") Begin
6890>>>            Move (HtmlHelp(GetOwnerWindowHandle(Self), sHelpFile, HH_DISPLAY_TOC, 0)) TO hRetVal
6891>>>        End
6891>>>>
6891>>>    End_Procedure
6892>>>
6892>>>    Procedure DoSyncToc
6894>>>        Handle hRetVal
6894>>>        String sHelpFile
6894>>>        Get GetHelpFile To sHelpFile
6895>>>        If (sHelpFile<>"") Begin
6897>>>            Move (HtmlHelp(GetOwnerWindowHandle(Self), sHelpFile, HH_SYNC, 0)) TO hRetVal
6898>>>        End
6898>>>>
6898>>>    End_Procedure
6899>>>
6899>>>    Procedure DO_HH_DISPLAY_SEARCH String sTopic
6901>>>        Handle hRetVal
6901>>>        Pointer psTopic
6901>>>        String sHelpFile
6901>>>        GetAddress OF sTopic TO psTopic
6902>>>        Get GetHelpFile To sHelpFile
6903>>>        If (sHelpFile<>"") Begin
6905>>>            Move (HtmlHelp(GetOwnerWindowHandle(Self), sHelpFile, HH_DISPLAY_SEARCH, psTopic)) TO hRetVal
6906>>>        End
6906>>>>
6906>>>    End_Procedure
6907>>>
6907>>>End_Class
6908>Use cApplication.pkg
Including file: cApplication.pkg    (C:\Program Files (x86)\Visual DataFlex 17.1\Pkg\cApplication.pkg)
6908>>>// cApplication.pkg
6908>>>// Author: SWB
6908>>>
6908>>>// Mar  1, 2002 SWB changed the order of the DoOpenWorkspace method to try to load the file from the path before looking in the Registered list
6908>>>// Mar 13, 2000 SWB changed the GetApplicationFileName method to use a safer method of retrieving the filename from the OS
6908>>>// Mar 13, 2000 SWB changed the default of psProgram to use Module_Name, as this works across chained-to programs
6908>>>
6908>>>Use Windows.pkg
6908>>>Use LanguageText.pkg
6908>>>Use WinUser.pkg
6908>>>Use WinShell.pkg
Including file: WinShell.pkg    (C:\Program Files (x86)\Visual DataFlex 17.1\Pkg\WinShell.pkg)
6908>>>>>// Shell API functions
6908>>>>>Use Windows.pkg
6908>>>>>Use DLL.pkg
6908>>>>>
6908>>>>>External_Function PathFileExists "PathFileExistsA" shlwapi.dll ;    String sPath ;Returns Integer // Boolean
6909>>>>>
6909>>>>>External_Function PathIsRelative "PathIsRelativeA" shlwapi.dll ;    String sPath ;Returns Integer // Boolean
6910>>>>>
6910>>>>>External_Function PathRemoveExtension "PathRemoveExtensionA" shlwapi.dll ;    Address aPath ;Returns Integer // void
6911>>>>>
6911>>>>>External_Function PathRemoveFileSpec "PathRemoveFileSpecA" shlwapi.dll ;    Address aPath ;Returns Integer
6912>>>>>
6912>>>>>
6912>>>>>Define URL_UNESCAPE_INPLACE                    for |CI$00100000
6912>>>>>
6912>>>>>External_Function UrlUnescape "UrlUnescapeA" shlwapi.dll;    Pointer pszURL;    Pointer pszUnescaped;    Pointer pcchUnescaped;    DWord dwFlags;Returns Integer // S_OK if succesfull
6913>>>Use cWorkspace.pkg
Including file: cWorkspace.pkg    (C:\Program Files (x86)\Visual DataFlex 17.1\Pkg\cWorkspace.pkg)
6913>>>>>// cWorkspace.pkg
6913>>>>>// Author: SWB
6913>>>>>Use Windows.pkg
6913>>>>>Use LanguageText.pkg
6913>>>>>Use WinShell.pkg // Shell API functions
6913>>>>>Use seq_chnl.pkg
Including file: seq_chnl.pkg    (C:\Program Files (x86)\Visual DataFlex 17.1\Pkg\seq_chnl.pkg)
6913>>>>>>>//=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
6913>>>>>>>// Confidential Trade Secret.
6913>>>>>>>// Copyright 1987-1994 Data Access Corporation, Miami FL, USA
6913>>>>>>>// All Rights reserved
6913>>>>>>>// DataFlex is a registered trademark of Data Access Corporation.
6913>>>>>>>//
6913>>>>>>>// Module:
6913>>>>>>>//      seq_chnl.pkg
6913>>>>>>>//
6913>>>>>>>// Purpose:
6913>>>>>>>//      Defines global sequential device management operations.
6913>>>>>>>//
6913>>>>>>>// Author:
6913>>>>>>>//      Lee Smith
6913>>>>>>>//
6913>>>>>>>// Date:
6913>>>>>>>//      11/2/94
6913>>>>>>>//
6913>>>>>>>//=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
6913>>>>>>>// 12/13/2001 JJT: If channel not open, don't declare error during close
6913>>>>>>>//=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
6913>>>>>>>Use LanguageText.pkg
6913>>>>>>>use VDFBase.pkg
Including file: errornum.inc    (C:\Program Files (x86)\Visual DataFlex 17.1\Pkg\errornum.inc)
6913>>>>>>>>// DataFlex Source Code
6913>>>>>>>>// Copyright 1987-1992 Data Access Corporation, Miami FL, USA
6913>>>>>>>>// All Rights reserved
6913>>>>>>>>//
6913>>>>>>>>// JR 2/7/92
6913>>>>>>>>
6913>>>>>>>>
6913>>>>>>>>
6913>>>>>>>>//
6913>>>>>>>>// these will get defined in fmac
6913>>>>>>>>//
6913>>>>>>>>// already defined
6913>>>>>>>>//    #REPLACE DFERR_COMP_BAD_IMAGE_NAME                 |CI4293
6913>>>>>>>>//    #REPLACE DFERR_COMP_CONSTANT_EXPECTED              |CI4299
6913>>>>>>>>//    #REPLACE DFERR_COMP_ILLEGAL_RETURN_TYPE            |CI4310
6913>>>>>>>>//    #REPLACE DFERR_COMP_IMAGE_NOT_FOUND                |CI4311
6913>>>>>>>>//    #REPLACE DFERR_COMP_INVALID_DATATYPE               |CI4315
6913>>>>>>>>//    #REPLACE DFERR_COMP_INVALID_TYPE                   |CI4317
6913>>>>>>>>//    #REPLACE DFERR_COMP_MISSING_ARGUMENT               |CI4320
6913>>>>>>>>//    #REPLACE DFERR_COMP_MISSING_END_OBJECT             |CI4323
6913>>>>>>>>//    #REPLACE DFERR_COMP_UNDEFINED_SYMBOL_IN_ARGUMENT   |CI4328
6913>>>>>>>>//    #REPLACE DFERR_COMP_SYMBOL_ALREADY_DEFINED         |CI4332
6913>>>>>>>>//    #REPLACE DFERR_COMP_TOO_MANY_MESSAGES              |CI4339
6913>>>>>>>>//    #REPLACE DFERR_COMP_UNRESOVLED_CONTROL_BLOCK       |CI4348
6913>>>>>>>>// new compiler errors used by fmac
6913>>>>>>>>//    #REPLACE DFERR_COMP_ILLEGAL_OBJECT_DEFINTION       |CI4388 // object name used is not valid
6913>>>>>>>>//    #REPLACE DFERR_COMP_ILLEGAL_PROPERTY_DEFINTION     |CI4389 // property name cannot be used
6913>>>>>>>>//    #REPLACE DFERR_COMP_ILLEGAL_METHOD_DEFINTION       |CI4390 // method name cannot be used
6913>>>>>>>>//    #REPLACE DFERR_COMP_ILLEGAL_CODE_PLACEMENT         |CI4391 // Location of code, nesting, is wrong
6913>>>>>>>>//    #REPLACE DFERR_COMP_INVALID_METHOD_SYNTAX          |CI4392 // syntax is incorrect for method definition
6913>>>>>>>>//    #REPLACE DFERR_COMP_INVALID_MESSAGE_SYNTAX         |CI4393 // sysntax is incorrect for sending message
6913>>>>>>>>//    #REPLACE DFERR_COMP_INVALID_OBJECT_REFERENCE       |CI4394 // object named in message is invalid
6913>>>>>>>>//    #REPLACE DFERR_COMP_OBSOLETE_UNSUPPORTED_FEATURE   |CI4395 // Obsolete - was 101 (Moveused by fmac)
6913>>>>>>>>//    #REPLACE DFERR_COMP_INVALID_ARGUMENT               |CI4396 // Agument in line is incorrect
6913>>>>>>>>//    #REPLACE DFERR_COMP_ILLEGAL_EXTERNAL_FUNCTION_DEFINITION |CI4397 // name cannot be used
6913>>>>>>>>//    #REPLACE DFERR_COMP_MISSING_DEBUG_INFORMATION      |CI4500 // debug information is not provided
6913>>>>>>>>//    #REPLACE DFERR_COMP_INCOMPATIBLE_DEBUG_INFORMATION |CI4501 // debug inforamtion is is not correct
6913>>>>>>>>//    #REPLACE DFERR_COMP_RECURSIVE_STRUCT_DECLARATION   |CI4513 // recursive struct definition
6913>>>>>>>>//    #REPLACE DFERR_COMP_AMBIGUOUS_SYNTAX.              |CI4514 // either Left of "'[' is not array, use '(' if indicator" or "Left of '.' is not of type struct or table" 
6913>>>>>>>>
6913>>>>>>>>
6913>>>>>>>
6913>>>>>>>define DF_SEQ_CHANNEL_NOT_AVAILABLE for -2
6913>>>>>>>define DF_SEQ_CHANNEL_ERROR         for -1
6913>>>>>>>define DF_SEQ_CHANNEL_MIN           for 0
6913>>>>>>>define DF_SEQ_CHANNEL_MAX           for 9
6913>>>>>>>define DF_SEQ_START_CHANNEL         for 2 // leave 0 and 1 til last
6913>>>>>>>                            // so that programs that use direct_input/output
6913>>>>>>>                            // w/o specifying a channel will work.
6913>>>>>>>enum_list
6913>>>>>>>    define DF_SEQ_CHANNEL_MODE_CLOSED
6913>>>>>>>    define DF_SEQ_CHANNEL_MODE_OPEN
6913>>>>>>>    define DF_SEQ_CHANNEL_MODE_OUTPUT
6913>>>>>>>    define DF_SEQ_CHANNEL_MODE_INPUT
6913>>>>>>>end_enum_list
6913>>>>>>>
6913>>>>>>>enum_list
6913>>>>>>>    define DF_SEQ_CHANNEL_ERROR_MODE_NONE
6913>>>>>>>    define DF_SEQ_CHANNEL_ERROR_MODE_ALL
6913>>>>>>>end_enum_list
6913>>>>>>>
6913>>>>>>>integer Seq$Channel$Error$Mode
6913>>>>>>>
6913>>>>>>>procedure set Seq_Channel_Error_Mode GLOBAL integer Mode
6915>>>>>>>    move Mode to Seq$Channel$Error$Mode
6916>>>>>>>end_procedure
6917>>>>>>>
6917>>>>>>>function Seq_Channel_Error_Mode GLOBAL returns integer
6919>>>>>>>    function_return Seq$Channel$Error$Mode
6920>>>>>>>end_procedure
6921>>>>>>>
6921>>>>>>>object Seq_Channel_List is an Array
6923>>>>>>>    procedure Initialize
6926>>>>>>>        integer Itm
6926>>>>>>>
6926>>>>>>>        move DF_SEQ_CHANNEL_MIN to Itm
6927>>>>>>>
6927>>>>>>>        while Itm LE DF_SEQ_CHANNEL_MAX
6931>>>>>>>            set Array_Value item Itm to DF_SEQ_CHANNEL_MODE_CLOSED
6932>>>>>>>            increment Itm
6933>>>>>>>        end
6934>>>>>>>>
6934>>>>>>>    end_procedure
6935>>>>>>>
6935>>>>>>>    send Initialize
6936>>>>>>>end_object
6937>>>>>>>
6937>>>>>>>set Seq_Channel_Error_Mode to DF_SEQ_CHANNEL_ERROR_MODE_ALL
6938>>>>>>>
6938>>>>>>>function Seq_Channel_Mode GLOBAL integer Chnl returns integer
6940>>>>>>>    function_return (Integer_Value(Seq_Channel_List(self), Chnl))
6941>>>>>>>end_function
6942>>>>>>>
6942>>>>>>>procedure set Seq_Channel_Mode GLOBAL integer Chnl integer Mode
6944>>>>>>>    set Array_Value of (Seq_Channel_List(self)) item Chnl to Mode
6945>>>>>>>end_procedure
6946>>>>>>>
6946>>>>>>>function Seq_New_Channel GLOBAL returns integer
6948>>>>>>>    integer Obj Chnl
6948>>>>>>>
6948>>>>>>>    move DF_SEQ_START_CHANNEL to Chnl
6949>>>>>>>
6949>>>>>>>    while Chnl LE DF_SEQ_CHANNEL_MAX
6953>>>>>>>        if (Seq_Channel_Mode(Chnl)) EQ DF_SEQ_CHANNEL_MODE_CLOSED begin
6955>>>>>>>            set Seq_Channel_Mode Chnl to DF_SEQ_CHANNEL_MODE_OPEN
6956>>>>>>>            function_return Chnl
6957>>>>>>>        end
6957>>>>>>>>
6957>>>>>>>
6957>>>>>>>        increment Chnl
6958>>>>>>>    end
6959>>>>>>>>
6959>>>>>>>
6959>>>>>>>    // wrap back to beginning
6959>>>>>>>    move 0 to Chnl
6960>>>>>>>
6960>>>>>>>    while Chnl LT DF_SEQ_START_CHANNEL
6964>>>>>>>        if (Seq_Channel_Mode(Chnl)) EQ DF_SEQ_CHANNEL_MODE_CLOSED begin
6966>>>>>>>            set Seq_Channel_Mode Chnl to DF_SEQ_CHANNEL_MODE_OPEN
6967>>>>>>>            function_return Chnl
6968>>>>>>>        end
6968>>>>>>>>
6968>>>>>>>
6968>>>>>>>        increment Chnl
6969>>>>>>>    end
6970>>>>>>>>
6970>>>>>>>
6970>>>>>>>    function_return DF_SEQ_CHANNEL_NOT_AVAILABLE
6971>>>>>>>end_procedure
6972>>>>>>>
6972>>>>>>>procedure Seq_Release_Channel GLOBAL integer Chnl
6974>>>>>>>    if ((Chnl >= DF_SEQ_CHANNEL_MIN) and (Chnl <= DF_SEQ_CHANNEL_MAX)) ;        set Seq_Channel_Mode Chnl to DF_SEQ_CHANNEL_MODE_CLOSED
6977>>>>>>>end_procedure
6978>>>>>>>
6978>>>>>>>function Seq_Open_Input_Channel GLOBAL string Dvc returns integer
6980>>>>>>>    integer Chnl
6980>>>>>>>
6980>>>>>>>    get Seq_New_Channel to Chnl
6981>>>>>>>
6981>>>>>>>    if Chnl LE DF_SEQ_CHANNEL_ERROR begin
6983>>>>>>>        if (Seq_Channel_Error_Mode()) EQ DF_SEQ_CHANNEL_ERROR_MODE_ALL ;            error DFERR_CANT_OPEN_INPUT_FILE (Dvc + ":" *C_$NoOpenChannels)
6986>>>>>>>        function_return Chnl
6987>>>>>>>    end
6987>>>>>>>>
6987>>>>>>>
6987>>>>>>>    indicate Err FALSE
6988>>>>>>>    direct_input channel Chnl Dvc
6990>>>>>>>
6990>>>>>>>    [Err] begin
6992>>>>>>>>
6992>>>>>>>        send Seq_Release_Channel Chnl
6993>>>>>>>        function_return DF_SEQ_CHANNEL_ERROR
6994>>>>>>>    end
6994>>>>>>>>
6994>>>>>>>
6994>>>>>>>    set Seq_Channel_Mode Chnl to DF_SEQ_CHANNEL_MODE_INPUT
6995>>>>>>>
6995>>>>>>>    function_return Chnl
6996>>>>>>>end_function
6997>>>>>>>
6997>>>>>>>function Seq_Open_Output_Channel GLOBAL string Dvc returns integer
6999>>>>>>>    integer Chnl
6999>>>>>>>
6999>>>>>>>    get Seq_New_Channel to Chnl
7000>>>>>>>
7000>>>>>>>    if Chnl LE DF_SEQ_CHANNEL_ERROR begin
7002>>>>>>>        if (Seq_Channel_Error_Mode()) EQ DF_SEQ_CHANNEL_ERROR_MODE_ALL begin
7004>>>>>>>            error DFERR_CANT_OPEN_OUTPUT_FILE (Dvc + ":" *C_$ChannelNotAvailable)
7005>>>>>>>>
7005>>>>>>>            move DF_SEQ_CHANNEL_ERROR to Chnl
7006>>>>>>>        end
7006>>>>>>>>
7006>>>>>>>
7006>>>>>>>        function_return Chnl
7007>>>>>>>    end
7007>>>>>>>>
7007>>>>>>>
7007>>>>>>>    indicate Err FALSE
7008>>>>>>>    direct_output channel Chnl Dvc
7010>>>>>>>
7010>>>>>>>    [Err] begin
7012>>>>>>>>
7012>>>>>>>        send Seq_Release_Channel Chnl
7013>>>>>>>        function_return DF_SEQ_CHANNEL_ERROR
7014>>>>>>>    end
7014>>>>>>>>
7014>>>>>>>
7014>>>>>>>    set Seq_Channel_Mode Chnl to DF_SEQ_CHANNEL_MODE_OUTPUT
7015>>>>>>>
7015>>>>>>>    function_return Chnl
7016>>>>>>>end_function
7017>>>>>>>
7017>>>>>>>function Seq_Append_Output_Channel GLOBAL string Dvc returns integer
7019>>>>>>>    integer Chnl
7019>>>>>>>
7019>>>>>>>    get Seq_New_Channel to Chnl
7020>>>>>>>
7020>>>>>>>    if Chnl LE DF_SEQ_CHANNEL_ERROR begin
7022>>>>>>>        if (Seq_Channel_Error_Mode()) EQ DF_SEQ_CHANNEL_ERROR_MODE_ALL begin
7024>>>>>>>            error DFERR_CANT_OPEN_OUTPUT_FILE (Dvc + ":" *C_$ChannelNotAvailable)
7025>>>>>>>>
7025>>>>>>>            move DF_SEQ_CHANNEL_ERROR to Chnl
7026>>>>>>>        end
7026>>>>>>>>
7026>>>>>>>
7026>>>>>>>        function_return Chnl
7027>>>>>>>    end
7027>>>>>>>>
7027>>>>>>>
7027>>>>>>>    indicate Err FALSE
7028>>>>>>>    append_output channel Chnl Dvc
7030>>>>>>>
7030>>>>>>>    [Err] begin
7032>>>>>>>>
7032>>>>>>>        send Seq_Release_Channel Chnl
7033>>>>>>>        function_return DF_SEQ_CHANNEL_ERROR
7034>>>>>>>    end
7034>>>>>>>>
7034>>>>>>>
7034>>>>>>>    set Seq_Channel_Mode Chnl to DF_SEQ_CHANNEL_MODE_OUTPUT
7035>>>>>>>
7035>>>>>>>    function_return Chnl
7036>>>>>>>end_function
7037>>>>>>>
7037>>>>>>>procedure Seq_Close_Channel GLOBAL integer Chnl
7039>>>>>>>    integer Mode
7039>>>>>>>
7039>>>>>>>    if ((Chnl >= DF_SEQ_CHANNEL_MIN) and (Chnl <= DF_SEQ_CHANNEL_MAX)) begin
7041>>>>>>>        get Seq_Channel_Mode Chnl to Mode
7042>>>>>>>
7042>>>>>>>        if Mode EQ DF_SEQ_CHANNEL_MODE_OUTPUT ;            close_output channel Chnl
7046>>>>>>>        else if Mode EQ DF_SEQ_CHANNEL_MODE_INPUT ;            close_input channel Chnl
7051>>>>>>>        // 12/13/2001 - If channel not open, release it! No (fatal) Error.
7051>>>>>>>        //else begin
7051>>>>>>>        //    Error DFERR_FILE_NOT_OPEN ("Channel: " + string(Chnl))
7051>>>>>>>        //    procedure_return
7051>>>>>>>        //end
7051>>>>>>>
7051>>>>>>>        send Seq_Release_Channel Chnl
7052>>>>>>>    end
7052>>>>>>>>
7052>>>>>>>end_procedure
7053>>>>>
7053>>>>>Register_Function IsRegistered String sWorkspace Returns Boolean
7053>>>>>Register_Function VdfSystemDfPath   Returns String
7053>>>>>Register_Function VdfSystemMakePath Returns String
7053>>>>>
7053>>>>>Enum_List
7053>>>>>    Define wsWorkspaceOpened       // WS opened ok
7053>>>>>    Define wsWorkspaceNotFound     // the named WS was not found in the global list
7053>>>>>    Define wsWorkspaceFileNotFound // the WS file was not found
7053>>>>>    Define wsDataPathEmpty         // the DataPath entry was empty
7053>>>>>    Define wsFileListEmpty         // The FileList entry was empty
7053>>>>>    Define wsFileListNotExist      // The FileList.cfg file could not be found
7053>>>>>End_Enum_List
7053>>>>>
7053>>>>>Function LastDelimeter Global String sDelimeters String sString Returns Integer
7055>>>>>    // Returns last position of any sDelimeters in the sString
7055>>>>>    Integer iPos
7055>>>>>
7055>>>>>    Move (Length(sString) ) To iPos
7056>>>>>    While (iPos >0)
7060>>>>>        If (Mid(sString, 1, iPos)) In sDelimeters Function_Return iPos
7063>>>>>        Decrement iPos
7064>>>>>    Loop
7065>>>>>>
7065>>>>>    Function_Return 0
7066>>>>>End_Function
7067>>>>>
7067>>>>>Function ExtractFilePath Global String sFileName Returns String
7069>>>>>    // Returns a path from a filename. "c:\Ide\Test\AbData.pkg" would return "c:\Ide\Test\"
7069>>>>>    Integer iPos
7069>>>>>    Move (LastDelimeter("\:", sFileName)) To iPos
7070>>>>>    Function_Return (Left(sFileName, iPos))
7071>>>>>End_Function
7072>>>>>
7072>>>>>Function IsFileNameQualified GLOBAL String sFileName Returns Integer
7074>>>>>    Function_Return (ExtractFilePath(sFileName) <> "")
7075>>>>>End_Function
7076>>>>>
7076>>>>>Function ExtractFileName Global String sFileName Returns String
7078>>>>>    // Returns a name from a fully-qualified filename. Eg: "c:\Test\IDE.src" will return "IDE.src"
7078>>>>>    Integer iPos
7078>>>>>
7078>>>>>    Move (LastDelimeter("\:", sFileName)) To iPos
7079>>>>>
7079>>>>>    Function_Return (Right(sFileName, Length(sFileName) -iPos))
7080>>>>>End_Function
7081>>>>>
7081>>>>>
7081>>>>>Define INVALID_HANDLE_VALUE for -1
7081>>>>>DEFINE MAX_PATH For 260   // Symbol for maximum length of a path
7081>>>>>
7081>>>>>Type tWin32FindData
7081>>>>>    Field tWin32FindData.dwFileAttributes                as Dword
7081>>>>>    Field tWin32FindData.ftCreationTime.dwLowDateTime    as Dword
7081>>>>>    Field tWin32FindData.ftCreationTime.dwHighDateTime   as Dword
7081>>>>>    Field tWin32FindData.ftLastAccessTime.dwLowDateTime  as Dword
7081>>>>>    Field tWin32FindData.ftLastAccessTime.dwHighDateTime as Dword
7081>>>>>    Field tWin32FindData.ftLastWriteTime.dwLowDateTime   as Dword
7081>>>>>    Field tWin32FindData.ftLastWriteTime.dwHighDateTime  as Dword
7081>>>>>    Field tWin32FindData.nFileSizeHigh                   as Dword
7081>>>>>    Field tWin32FindData.nFileSizeLow                    as Dword
7081>>>>>    Field tWin32FindData.dwReserved0                     as Dword
7081>>>>>    Field tWin32FindData.dwReserved1                     as Dword
7081>>>>>    Field tWin32FindData.cFileName                       as Char MAX_PATH
7081>>>>>    Field tWin32FindData.cAlternateFileName              as Char 14
7081>>>>>End_Type
7081>>>>>
7081>>>>>External_Function winFindFirstFile "FindFirstFileA" Kernel32.dll ;    String sFileSpec Pointer lpsWin32FindData Returns Handle
7082>>>>>
7082>>>>>External_Function winFindNextFile "FindNextFileA" Kernel32.dll ;    Handle hFindFile Pointer lpsWin32FindData Returns Handle
7083>>>>>
7083>>>>>External_Function winFindClose "FindClose" Kernel32.dll ;    Handle hOpenFile Returns Integer
7084>>>>>
7084>>>>>Function DoesFileExist GLOBAL String sFilename Returns Boolean
7086>>>>>        String sWin32FindData sMask
7086>>>>>        Pointer lpsWin32FindData
7086>>>>>        Integer iVoid
7086>>>>>        Handle hFileFind
7086>>>>>
7086>>>>>        ZeroType tWin32FindData To sWin32FindData
7087>>>>>        GetAddress of sWin32FindData To lpsWin32FindData
7088>>>>>        Move (winFindFirstFile(ToAnsi(sFilename), lpsWin32FindData)) To hFileFind   // JVH 8.3.8.0 must pass Ansi filename
7089>>>>>        If (hFileFind <> INVALID_HANDLE_VALUE) Begin
7091>>>>>            Move (winFindClose(hFileFind)) To iVoid
7092>>>>>        End
7092>>>>>>
7092>>>>>
7092>>>>>    Function_Return (hFileFind <> INVALID_HANDLE_VALUE)
7093>>>>>End_Function
7094>>>>>
7094>>>>>
7094>>>>>Use cIniFile.pkg
Including file: cIniFile.pkg    (C:\Program Files (x86)\Visual DataFlex 17.1\Pkg\cIniFile.pkg)
7094>>>>>>>// cIniFile.pkg
7094>>>>>>>// Author: SWB
7094>>>>>>>Use LanguageText.pkg
7094>>>>>>>Use windows.pkg
7094>>>>>>>
7094>>>>>>>// it is important that psFileName is defined. If blank, the registry may be accessed. We will check all WritePrivateProfileString
7094>>>>>>>// and GetPrivateProfileString to make sure that a file is defined.
7094>>>>>>>External_Function WritePrivateProfileString "WritePrivateProfileStringA" Kernel32.dll ;    String sSection String sKeyName String sValue String sFileName Returns Integer
7095>>>>>>>
7095>>>>>>>External_Function GetPrivateProfileString "GetPrivateProfileStringA" Kernel32.dll ;    Address aSection Address aKeyName Address aDefault Pointer lpsValue Integer nSize String sFileName Returns Integer
7096>>>>>>>
7096>>>>>>>Class cIniFile is a cObject
7097>>>>>>>    Procedure Construct_Object
7099>>>>>>>        Forward Send Construct_Object
7101>>>>>>>
7101>>>>>>>        Property String psFileName
7102>>>>>>>    End_Procedure
7103>>>>>>>
7103>>>>>>>    Procedure WriteString String sSection String sKey String sValue
7105>>>>>>>        Boolean bSuccess
7105>>>>>>>
7105>>>>>>>        //Showln "WriteString "
7105>>>>>>>        //Showln sSection ' - ' sKey ' - ' (psFileName(self))
7105>>>>>>>        //Showln sSection ' - ' sKey ' - ' (ToAnsi(psFileName(self)))
7105>>>>>>>        If (trim(psFileName(self))="") Begin
7107>>>>>>>            Error DFERR_INI_FILE "Ini file name not defined"
7108>>>>>>>>
7108>>>>>>>            Procedure_return
7109>>>>>>>        end
7109>>>>>>>>
7109>>>>>>>        Move (WritePrivateProfileString(ToAnsi(sSection), ToAnsi(sKey), ToAnsi(sValue), ToAnsi(psFilename(self)))) To bSuccess
7110>>>>>>>        If (bSuccess = False) Error DFERR_INI_FILE C_$CannotWriteToTheIniFile
7113>>>>>>>    End_Procedure
7114>>>>>>>
7114>>>>>>>    Function ReadString String sSection String sKey String sDefault Returns String
7116>>>>>>>        Integer iNumChars iSizeValue
7116>>>>>>>        Pointer lpsValue
7116>>>>>>>        String sValue
7116>>>>>>>
7116>>>>>>>        Move (ToAnsi(sSection)) To sSection
7117>>>>>>>        Move (ToAnsi(sKey))     To sKey
7118>>>>>>>        Move (ToAnsi(sDefault)) To sDefault
7119>>>>>>>
7119>>>>>>>        Move 2047 to iSizeValue
7120>>>>>>>
7120>>>>>>>        Pad " " To sValue iSizeValue
7122>>>>>>>>
7122>>>>>>>        GetAddress of sValue to lpsValue
7123>>>>>>>
7123>>>>>>>        If (trim(psFileName(self))="") Begin
7125>>>>>>>            Error DFERR_INI_FILE "Ini file name not defined"
7126>>>>>>>>
7126>>>>>>>            Function_return ''
7127>>>>>>>        end
7127>>>>>>>>
7127>>>>>>>        Move (GetPrivateProfileString(AddressOf(sSection), AddressOf(sKey), AddressOf(sDefault), lpsValue, iSizeValue, ToAnsi(psFilename(self)))) To iNumChars
7128>>>>>>>        Function_Return  (ToOem(CString(sValue)))
7129>>>>>>>    End_Function
7130>>>>>>>
7130>>>>>>>    Function SectionExists String sSection Returns Boolean
7132>>>>>>>        // A section exists only if it has at least one Key. A section with no keys is said not to exist
7132>>>>>>>        Handle hoKeys
7132>>>>>>>        Integer icKey iKey
7132>>>>>>>
7132>>>>>>>        Get Create U_ARRAY To hoKeys
7133>>>>>>>        Send ReadSection sSection hoKeys
7134>>>>>>>        Get Item_Count of hoKeys To icKey
7135>>>>>>>        Send Destroy of hoKeys
7136>>>>>>>
7136>>>>>>>        Function_Return (icKey >0)
7137>>>>>>>    End_Function
7138>>>>>>>
7138>>>>>>>    Procedure ReadSection String sSection Handle hoArray
7140>>>>>>>        Integer iNumChars iSizeValue iPos
7140>>>>>>>        Pointer lpsKeys
7140>>>>>>>        String sKeys sKey
7140>>>>>>>
7140>>>>>>>        Move 16384 to iSizeValue
7141>>>>>>>        Move (Repeat(character(0),  iSizeValue)) To sKeys
7142>>>>>>>
7142>>>>>>>        GetAddress of sKeys to lpsKeys
7143>>>>>>>
7143>>>>>>>        Move (ToAnsi(sSection)) To sSection
7144>>>>>>>
7144>>>>>>>        If (trim(psFileName(self))="") Begin
7146>>>>>>>            Error DFERR_INI_FILE "Ini file name not defined"
7147>>>>>>>>
7147>>>>>>>            Procedure_return
7148>>>>>>>        end
7148>>>>>>>>
7148>>>>>>>        Move (GetPrivateProfileString(AddressOf(sSection), 0, 0, lpsKeys, Length(sKeys), ToAnsi(psFilename(self)))) To iNumChars
7149>>>>>>>        If (iNumChars >0) Begin
7151>>>>>>>            Repeat
7151>>>>>>>>
7151>>>>>>>                Pos (Character(0)) in sKeys To iPos
7153>>>>>>>>
7153>>>>>>>                If (iPos >1) Begin
7155>>>>>>>                    Left sKeys To sKey (iPos -1)
7157>>>>>>>>
7157>>>>>>>                    Right sKeys To sKeys (Length(sKeys) - iPos)
7159>>>>>>>>
7159>>>>>>>                    Set Value of hoArray (Item_Count(hoArray)) To (ToOem(sKey))
7160>>>>>>>                End
7160>>>>>>>>
7160>>>>>>>            Until (iPos <=1)
7162>>>>>>>        End
7162>>>>>>>>
7162>>>>>>>    End_Procedure
7163>>>>>>>
7163>>>>>>>    Procedure ReadSections Handle hoArray
7165>>>>>>>        Integer iNumChars iSizeValue iPos
7165>>>>>>>        Pointer lpsSections
7165>>>>>>>        String sSections sSection
7165>>>>>>>
7165>>>>>>>        Move 16384 to iSizeValue
7166>>>>>>>
7166>>>>>>>        Move (Repeat(character(0),  iSizeValue)) To sSections
7167>>>>>>>        GetAddress of sSections to lpsSections
7168>>>>>>>
7168>>>>>>>        If (trim(psFileName(self))="") Begin
7170>>>>>>>            Error DFERR_INI_FILE "Ini file name not defined"
7171>>>>>>>>
7171>>>>>>>            Procedure_return
7172>>>>>>>        end
7172>>>>>>>>
7172>>>>>>>        Move (GetPrivateProfileString(0, 0, 0, lpsSections, Length(sSections), ToAnsi(psFilename(self)))) To iNumChars
7173>>>>>>>        If (iNumChars >0) Begin
7175>>>>>>>            Repeat
7175>>>>>>>>
7175>>>>>>>                Pos (Character(0)) in sSections To iPos
7177>>>>>>>>
7177>>>>>>>                If (iPos >1) Begin
7179>>>>>>>                    Left sSections To sSection (iPos -1)
7181>>>>>>>>
7181>>>>>>>                    Right sSections To sSections (Length(sSections) - iPos)
7183>>>>>>>>
7183>>>>>>>                    Set Value of hoArray (Item_Count(hoArray)) To (ToOem(sSection))
7184>>>>>>>                End
7184>>>>>>>>
7184>>>>>>>            Until (iPos <=1)
7186>>>>>>>        End
7186>>>>>>>>
7186>>>>>>>
7186>>>>>>>    End_Procedure
7187>>>>>>>
7187>>>>>>>    Procedure DeleteSection String sSection
7189>>>>>>>        //Showln "delete section:"
7189>>>>>>>        //Showln sSection ' - ' (psFileName(self))
7189>>>>>>>        //Showln sSection ' - ' (ToAnsi(psFileName(self)))
7189>>>>>>>
7189>>>>>>>        If (trim(psFileName(self))="") Begin
7191>>>>>>>            Error DFERR_INI_FILE "Ini file name not defined"
7192>>>>>>>>
7192>>>>>>>            Procedure_return
7193>>>>>>>        end
7193>>>>>>>>
7193>>>>>>>        If (WritePrivateProfileString(ToAnsi(sSection), "", "", ToAnsi(psFilename(self))) = 0) Error DFERR_INI_FILE C_$CanNotDeleteSection
7196>>>>>>>    End_Procedure
7197>>>>>>>
7197>>>>>>>    Procedure DeleteKey String sSection String sKey
7199>>>>>>>        Integer iVoid
7199>>>>>>>        //Showln "delete key:"
7199>>>>>>>        //Showln sSection ' - ' sKey ' - ' (psFileName(self))
7199>>>>>>>        //Showln sSection ' - ' skey ' - ' (ToAnsi(psFileName(self)))
7199>>>>>>>        If (trim(psFileName(self))="") Begin
7201>>>>>>>            Error DFERR_INI_FILE "Ini file name not defined"
7202>>>>>>>>
7202>>>>>>>            Procedure_return
7203>>>>>>>        end
7203>>>>>>>>
7203>>>>>>>        Move (WritePrivateProfileString(ToAnsi(sSection), ToAnsi(sKey), "", ToAnsi(psFilename(self)))) To iVoid
7204>>>>>>>        //Move (WritePrivateProfileString(ToAnsi(sSection), ToAnsi(sKey), "", psFilename(self))) To iVoid
7204>>>>>>>    End_Procedure
7205>>>>>>>
7205>>>>>>>    Function KeyExists String sSection String sKey Returns Boolean
7207>>>>>>>        Handle hoKeys
7207>>>>>>>        Integer iKey
7207>>>>>>>        Boolean bExists
7207>>>>>>>
7207>>>>>>>        Move (False) To bExists
7208>>>>>>>
7208>>>>>>>        Move (ToAnsi(Uppercase(sKey))) To sKey
7209>>>>>>>
7209>>>>>>>        Get Create U_ARRAY To hoKeys
7210>>>>>>>
7210>>>>>>>        Send ReadSection sSection hoKeys
7211>>>>>>>        For iKey from 0 To (Item_Count(hoKeys) -1)
7217>>>>>>>>
7217>>>>>>>            If (sKey = Uppercase(Value(hoKeys, iKey))) Begin
7219>>>>>>>                Move (True) To bExists
7220>>>>>>>            End
7220>>>>>>>>
7220>>>>>>>        Loop
7221>>>>>>>>
7221>>>>>>>
7221>>>>>>>        Send Destroy of hoKeys
7222>>>>>>>
7222>>>>>>>        Function_Return bExists
7223>>>>>>>    End_Function
7224>>>>>>>
7224>>>>>>>End_Class
7225>>>>>
7225>>>>>Class cWorkspace is a cObject
7226>>>>>
7226>>>>>    Procedure Construct_Object
7228>>>>>        Forward Send Construct_Object
7230>>>>>
7230>>>>>
7230>>>>>        Property String psAppSrcPath
7231>>>>>        Property String psBitmapPath
7232>>>>>        Property String psDataPath
7233>>>>>        Property String psDdSrcPath
7234>>>>>        Property String psDescription
7235>>>>>        Property String psFileList
7236>>>>>        Property String psHelpPath
7237>>>>>        Property String psHome
7238>>>>>        Property String psIdeSrcPath
7239>>>>>        Property String psProgramPath
7240>>>>>        Property String psAppHtmlPath
7241>>>>>        Property String psWorkspaceName
7242>>>>>        Property String psWorkspaceWSFile
7243>>>>>
7243>>>>>        Property String psSystemDfPath // took from the Registry!
7244>>>>>        Property String psSystemMakePath // took from the Registry!
7245>>>>>        Property String psDfPath        // Calculated
7246>>>>>
7246>>>>>        Property Boolean pbWorkspaceOpened False // used internally to tell if we are switching workspaces
7247>>>>>
7247>>>>>    End_Procedure
7248>>>>>
7248>>>>>    Function FullPathNames String sShortPathNames Returns String
7250>>>>>        String sFileName
7250>>>>>        String sFullPathNames sFullPathName sShortPathName
7250>>>>>        Pointer lpsFullPathName
7250>>>>>        Pointer lpsFilePart
7250>>>>>        Integer icChar // the number of characters returned
7250>>>>>        Integer iPos
7250>>>>>
7250>>>>>        Move (Pos(";", sShortPathNames)) To iPos
7251>>>>>        While (length(sShortPathNames) >0)
7255>>>>>            If (iPos =0) Begin
7257>>>>>                Move sShortPathNames To sShortPathName
7258>>>>>                Move "" To sShortPathNames
7259>>>>>            End
7259>>>>>>
7259>>>>>            Else Begin // multiple paths
7260>>>>>                Move (Left(sShortPathNames, iPos -1)) To sShortPathName
7261>>>>>                Move (Right(sShortPathNames, length(sShortPathNames) -iPos)) To sShortPathNames // remove this path from the paths
7262>>>>>            End
7262>>>>>>
7262>>>>>            Move (Repeat(character(0), 4096)) To sFullPathName
7263>>>>>            GetAddress of sFullPathName to lpsFullPathName
7264>>>>>            move -1 to lpsFilePart
7265>>>>>            Move (GetFullPathName(sShortPathName, 4096, lpsFullPathName, AddressOf(lpsFilePart))) To icChar
7266>>>>>            Append sFullPathNames (CString(sFullPathName))
7267>>>>>            If (sShortPathNames <>"") Append sFullPathNames ";"
7270>>>>>            Move (Pos(";", sShortPathNames)) To iPos
7271>>>>>        Loop
7272>>>>>>
7272>>>>>
7272>>>>>        Function_Return sFullPathNames
7273>>>>>    End_Function
7274>>>>>
7274>>>>>    Function GetApplicationPath Returns String
7276>>>>>        // Returns the path of the Application (no trailing "\")
7276>>>>>        String sApplicationFileName sPath
7276>>>>>        Boolean bRemoved
7276>>>>>        Integer iNumChars
7276>>>>>        String sFilename
7276>>>>>
7276>>>>>        Move (Repeat(Character(0), 1024)) to sApplicationFileName
7277>>>>>        Move (GetModuleFileName(0, AddressOf(sApplicationFileName), 1024)) to iNumChars
7278>>>>>        Move (CString(sApplicationFileName)) to sApplicationFileName
7279>>>>>
7279>>>>>        Move (PathRemoveFileSpec(AddressOf(sApplicationFileName))) to bRemoved
7280>>>>>        Move (CString(sApplicationFileName)) to sPath
7281>>>>>
7281>>>>>        If (Right(sPath, 1) ="\") Move (Left(sPath, Length(sPath) -1)) to sPath
7284>>>>>        Function_Return sPath
7285>>>>>    End_Function
7286>>>>>
7286>>>>>    Procedure DoClearPaths
7288>>>>>        // Call this prior to changing from one WorkspAce to another
7288>>>>>        // if you don't, OpenWorkspaceFile will ignore the new paths.
7288>>>>>        Set psHome           To ""
7289>>>>>        Set psAppSrcPath     To ""
7290>>>>>        Set psBitmapPath     To ""
7291>>>>>        Set psDataPath       To ""
7292>>>>>        Set psDdSrcPath      To ""
7293>>>>>        Set psDescription    To ""
7294>>>>>        Set psFileList       To ""
7295>>>>>        Set psHelpPath       To ""
7296>>>>>        Set psIdeSrcPath     To ""
7297>>>>>        Set psAppHtmlPath    To ""
7298>>>>>        Set psProgramPath    To ""
7299>>>>>        Set psWorkspaceName  To ""
7300>>>>>        Set psSystemDfPath   To ""
7301>>>>>        Set psSystemMakePath To ""
7302>>>>>        Set psWorkspaceWSFile to ""
7303>>>>>    End_Procedure
7304>>>>>
7304>>>>>    Function OpenWorkspaceFile String sWorkspaceFile Returns Integer
7306>>>>>        String sApplicationStartPath
7306>>>>>        String sWsName // name of Workspace is inferred from the Workspacefile name
7306>>>>>        Pointer lpsApplicationStartPath
7306>>>>>        Boolean bRemoved
7306>>>>>        Handle hoIniFile
7306>>>>>        Boolean bSuccess // call succeeded?
7306>>>>>        String sOldDirectory
7306>>>>>        String sSystemDfPath sSystemMakePath
7306>>>>>        Boolean bExist // does the WS file exist?
7306>>>>>        Boolean bChangingWorkspace
7306>>>>>
7306>>>>>        String sHome sAppSrcPath sBitmapPath sDataPath sDdSrcPath sDescription sAppHtmlPath
7306>>>>>        String sFileList sHelpPath sIdeSrcPath sProgramPath sWorkspaceName
7306>>>>>        
7306>>>>>        Set psWorkspaceWSFile to ""
7307>>>>>        If (sWorkspaceFile ="") Function_Return wsWorkspaceFileNotFound
7310>>>>>
7310>>>>>        // Append extension if not supplied...
7310>>>>>        If (Uppercase(Right(Trim(sWorkspaceFile),3)) <> ".WS") Begin
7312>>>>>            Move (sWorkspaceFile-".ws") To sWorkspaceFile
7313>>>>>        End
7313>>>>>>
7313>>>>>
7313>>>>>        Get pbWorkspaceOpened To bChangingWorkspace // if we had an existing workspace. We are changing
7314>>>>>
7314>>>>>        If (IsFilenameQualified(sWorkspaceFile) = False) Begin
7316>>>>>            // Set the properties to the paths of the Workspace
7316>>>>>            // Find the WS file (with program)...
7316>>>>>            Get GetApplicationPath to sApplicationStartPath
7317>>>>>
7317>>>>>            Move sWorkspaceFile To sWsName
7318>>>>>            Move (sApplicationStartPath +"\" +sWorkspaceFile) To sWorkspaceFile
7319>>>>>        End
7319>>>>>>
7319>>>>>        Else Begin
7320>>>>>            Move (ExtractFileName(sWorkspaceFile)) To sWsName
7321>>>>>
7321>>>>>            Move sWorkspaceFile To sApplicationStartPath
7322>>>>>            GetAddress of sApplicationStartPath To lpsApplicationStartPath
7323>>>>>            Move (PathRemoveFileSpec(lpsApplicationStartPath)) To bRemoved
7324>>>>>        End
7324>>>>>>
7324>>>>>
7324>>>>>        // Ensure that the file can be found...
7324>>>>>        //File_Exist (ToAnsi(sWorkspaceFile)) bExist        // [JVH] 8.3.8.0 Convert filename to Ansi
7324>>>>>        // [JVH] 8.3.8.0 - Temporarily turn off support for
7324>>>>>        // Ansi extended characters in workspace until we can
7324>>>>>        // resolve all open issues..........................
7324>>>>>        Set psWorkspaceWSFile to sWorkspaceFile
7325>>>>>        File_Exist sWorkspaceFile bExist
7326>>>>>        If (bExist = False) Function_Return wsWorkspaceFileNotFound
7329>>>>>
7329>>>>>        Get psHome           To sHome
7330>>>>>        Get psAppSrcPath     To sAppSrcPath
7331>>>>>        Get psAppHtmlPath    To sAppHtmlPath
7332>>>>>        Get psBitmapPath     To sBitmapPath
7333>>>>>        Get psDataPath       To sDataPath
7334>>>>>        Get psDdSrcPath      To sDdSrcPath
7335>>>>>        Get psDescription    To sDescription
7336>>>>>        Get psFileList       To sFileList
7337>>>>>        Get psHelpPath       To sHelpPath
7338>>>>>        Get psIdeSrcPath     To sIdeSrcPath
7339>>>>>        Get psProgramPath    To sProgramPath
7340>>>>>        Get psSystemDfPath   To sSystemDfPath
7341>>>>>        Get psSystemMakePath To sSystemMakePath
7342>>>>>        Get psWorkspaceName  To sWorkspaceName
7343>>>>>
7343>>>>>        Get_Current_Directory To sOldDirectory
7344>>>>>        // Note- this conversion is temporarily rolled back
7344>>>>>        //Move (SetCurrentDirectory(ToAnsi(CString(sApplicationStartPath)))) To bSuccess    // [JVH] 8.3.8.0 Convert AppStartPath to ANSI
7344>>>>>        Move (SetCurrentDirectory(CString(sApplicationStartPath))) To bSuccess
7345>>>>>
7345>>>>>        Get Create U_cIniFile To hoIniFile
7346>>>>>        Set psFilename of hoIniFile To sWorkspaceFile
7347>>>>>
7347>>>>>        If (sHome ="")          Get ReadString of hoIniFile "Workspace" "Home" ""          To sHome
7350>>>>>        If (sAppSrcPath ="")    Get ReadString of hoIniFile "Workspace" "AppSrcPath" ""    To sAppSrcPath
7353>>>>>        If (sAppHtmlPath ="")   Get ReadString of hoIniFile "Workspace" "AppHtmlPath" ""   To sAppHtmlPath
7356>>>>>        If (sBitmapPath ="")    Get ReadString of hoIniFile "Workspace" "BitmapPath" ""    To sBitmapPath
7359>>>>>        If (sDataPath ="")      Get ReadString of hoIniFile "Workspace" "DataPath" ""      To sDataPath
7362>>>>>        If (sDdSrcPath ="")     Get ReadString of hoIniFile "Workspace" "DdSrcPath" ""     To sDdSrcPath
7365>>>>>        If (sDescription ="")   Get ReadString of hoIniFile "Workspace" "Description" ""   To sDescription
7368>>>>>        If (sFileList ="")      Get ReadString of hoIniFile "Workspace" "FileList" ""      To sFileList
7371>>>>>        If (sHelpPath ="")      Get ReadString of hoIniFile "Workspace" "HelpPath" ""      To sHelpPath
7374>>>>>        If (sIdeSrcPath ="")    Get ReadString of hoIniFile "Workspace" "IdeSrcPath" ""    To sIdeSrcPath
7377>>>>>        If (sProgramPath ="")   Get ReadString of hoIniFile "Workspace" "ProgramPath" ""   To sProgramPath
7380>>>>>        If (sWorkspaceName ="") Move (Left(sWsName, Length(sWsName) -3))                   To sWorkspaceName
7383>>>>>
7383>>>>>        If (sSystemDfPath ="")   Set psSystemDfPath   To (VdfSystemDfPath(self))
7386>>>>>        If (sSystemMakePath ="") Set psSystemMakePath To (VdfSystemMakePath(self))
7389>>>>>
7389>>>>>        Set psHome          To (FullPathNames(self, sHome))
7390>>>>>
7390>>>>>        // Set CWD to Home...
7390>>>>>        Move (SetCurrentDirectory(sHome)) To bSuccess
7391>>>>>        Set psAppSrcPath    To (FullPathNames(self, sAppSrcPath))
7392>>>>>        Set psAppHtmlPath   To (FullPathNames(self, sAppHtmlPath))
7393>>>>>        Set psBitmapPath    To (FullPathNames(self, sBitmapPath))
7394>>>>>        Set psDataPath      To (FullPathNames(self, sDataPath))
7395>>>>>        Set psDdSrcPath     To (FullPathNames(self, sDdSrcPath))
7396>>>>>        Set psFileList      To (FullPathNames(self, sFileList))
7397>>>>>        Set psHelpPath      To (FullPathNames(self, sHelpPath))
7398>>>>>        Set psIdeSrcPath    To (FullPathNames(self, sIdeSrcPath))
7399>>>>>        Set psProgramPath   To (FullPathNames(self, sProgramPath))
7400>>>>>
7400>>>>>        Set psWorkspaceName To sWorkspaceName
7401>>>>>        Set psDescription   To sDescription
7402>>>>>
7402>>>>>        Send Destroy of hoIniFile // destroy dynaically created inifile object
7403>>>>>
7403>>>>>        // Restore CWD...
7403>>>>>        Move (SetCurrentDirectory(sOldDirectory)) To sOldDirectory
7404>>>>>
7404>>>>>        // Check for error conditions:
7404>>>>>        // DataPath and FileList must be defined; the FileList entry must point to a valid FileList.cfg
7404>>>>>        If (psDataPath(self) = "") Function_Return wsDataPathEmpty
7407>>>>>        If (psFileList(self) = "") Function_Return wsFileListEmpty
7410>>>>>
7410>>>>>        //File_Exist (psFileList(self)) bExist
7410>>>>>        Move (DoesFileExist(psFileList(self))) To bExist
7411>>>>>        If (bExist = False) Function_Return wsFileListNotExist
7414>>>>>
7414>>>>>        If bChangingWorkspace Close DF_ALL // if there is a WS open, we must close all the files
7417>>>>>
7417>>>>>        Send DoAssignPaths // set psDfPath
7418>>>>>        Send DoSetPaths    // Set the application's Attributes of Filelist_Name and Open_Path
7419>>>>>        Set pbWorkspaceOpened To True
7420>>>>>
7420>>>>>        Function_Return wsWorkspaceOpened
7421>>>>>    End_Function
7422>>>>>
7422>>>>>    Function OpenWorkspace String sWorkspace Returns Integer
7424>>>>>        // Look in the Workspaces.ini file for the name, then open it by path
7424>>>>>
7424>>>>>        Handle hoSections hoIniFile
7424>>>>>        Integer iWorkspace eOpened
7424>>>>>        String sWorkspaceName sPath
7424>>>>>        String sVdfRootDir
7424>>>>>
7424>>>>>        Get Create U_Array    To hoSections
7425>>>>>        Get Create U_cIniFile To hoIniFile
7426>>>>>
7426>>>>>        Get_Profile_String "Defaults" "VdfRootDir" To sVdfRootDir
7429>>>>>        If (Right(sVdfRootDir,1) <>"\") Move (sVdfRootDir +"\") To sVdfRootDir
7432>>>>>
7432>>>>>        Set psFilename of hoIniFile To (sVdfRootDir +"bin\Workspaces.ini")
7433>>>>>
7433>>>>>        Send ReadSections of hoIniFile hoSections
7434>>>>>
7434>>>>>        For iWorkspace from 0 to (Item_Count(hoSections) -1)
7440>>>>>>
7440>>>>>            Get Value of hoSections iWorkspace To sWorkspaceName
7441>>>>>            If (Uppercase(sWorkspaceName) = Uppercase(sWorkspace)) Begin
7443>>>>>                Get ReadString of hoIniFile sWorkspace "Path" "" To sPath
7444>>>>>                If (Right(sPath,1) <>"\") Move (sPath +"\") To sPath
7447>>>>>
7447>>>>>                Get OpenWorkspaceFile (sPath + sWorkspace) To eOpened
7448>>>>>                Send Destroy of hoSections
7449>>>>>                Send Destroy of hoIniFile
7450>>>>>                Function_Return eOpened
7451>>>>>            End
7451>>>>>>
7451>>>>>        Loop
7452>>>>>>
7452>>>>>
7452>>>>>        Send Destroy of hoSections
7453>>>>>        Send Destroy of hoIniFile
7454>>>>>        Function_Return wsWorkspaceNotFound
7455>>>>>    End_Function
7456>>>>>
7456>>>>>    Function IsRegistered String sWorkspace Returns Boolean
7458>>>>>        Boolean bRegistered
7458>>>>>        Handle hoIniFile
7458>>>>>        String sVdfRootDir
7458>>>>>
7458>>>>>        Get Create U_cIniFile To hoIniFile
7459>>>>>
7459>>>>>        Get_Profile_String "Defaults" "VdfRootDir" To sVdfRootDir
7462>>>>>        If (Right(sVdfRootDir,1) <>"\") Move (sVdfRootDir +"\") To sVdfRootDir
7465>>>>>        Set psFilename of hoIniFile To (sVdfRootDir +"bin\Workspaces.ini")
7466>>>>>        Move (SectionExists(hoIniFile, sWorkspace)) To bRegistered
7467>>>>>
7467>>>>>        Send Destroy of hoIniFile
7468>>>>>
7468>>>>>        Function_Return bRegistered
7469>>>>>    End_Function
7470>>>>>
7470>>>>>    Function VdfSystemDfPath Returns String
7472>>>>>        String sSystemDfPath
7472>>>>>        Get_Profile_String "Workspaces" "SystemDfPath" To sSystemDfPath
7475>>>>>
7475>>>>>        Function_Return sSystemDfPath
7476>>>>>    End_Function
7477>>>>>
7477>>>>>    Function VdfSystemMakePath Returns String
7479>>>>>        String sSystemMakePath
7479>>>>>        Get_Profile_String "Workspaces" "SystemMakePath" To sSystemMakePath
7482>>>>>
7482>>>>>        Function_Return sSystemMakePath
7483>>>>>    End_Function
7484>>>>>
7484>>>>>    Procedure DoAssignPaths
7486>>>>>        String sDataPath sBitmapPath sHelpPath sProgramPath sSystemDfPath
7486>>>>>
7486>>>>>        Get psDataPath     To sDataPath
7487>>>>>        Get psBitmapPath   To sBitmapPath
7488>>>>>        Get psHelpPath     To sHelpPath
7489>>>>>        Get psProgramPath  To sProgramPath
7490>>>>>        Get psSystemDfPath To sSystemDfPath
7491>>>>>
7491>>>>>        Set psDfPath To (sDataPath +';' + sBitmapPath +';' + sHelpPath +';' + sProgramPath +';' + sSystemDfPath)
7492>>>>>
7492>>>>>    End_Procedure
7493>>>>>
7493>>>>>    Procedure DoSetPaths
7495>>>>>        // [JVH] 8.3.8.0 - must convert paths to Ansi before setting these values
7495>>>>>        // Note- this conversion is temporarily rolled back
7495>>>>>        //Set_Attribute DF_FILELIST_NAME To (ToAnsi(psFileList(self)))
7495>>>>>        //Set_Attribute DF_OPEN_PATH     To (ToAnsi(psDfPath(self)))
7495>>>>>        Set_Attribute DF_FILELIST_NAME To (psFileList(self))
7498>>>>>        Set_Attribute DF_OPEN_PATH     To (psDfPath(self))
7501>>>>>    End_Procedure
7502>>>>>
7502>>>>>    Procedure EnumerateWorkspaceData Handle hoCallBack Handle hmGeneric
7504>>>>>         String sPath
7504>>>>>
7504>>>>>         If (psWorkspaceName(self)="") Send hmGeneric to hoCallBack C_$WorkspaceNotUsed
7507>>>>>         Else Begin
7508>>>>>            Send hmGeneric to hoCallBack (SFormat(C_$WorkspaceDesc, psDescription(self)))
7509>>>>>            Send hmGeneric to hoCallBack (SFormat(C_$WorkspaceName, psWorkspaceName(self)))
7510>>>>>            Send hmGeneric to hoCallBack ""
7511>>>>>            Send hmGeneric to hoCallBack (SFormat(C_$Filelist, psFileList(self)))
7512>>>>>            Send hmGeneric to hoCallBack (SFormat(C_$DataPath, psDataPath(self)))
7513>>>>>            Send hmGeneric to hoCallBack (SFormat(C_$ProgramPath, psProgramPath(self)))
7514>>>>>            Send hmGeneric to hoCallBack (SFormat(C_$HelpPath, psHelpPath(self)))
7515>>>>>            Send hmGeneric to hoCallBack (SFormat(C_$BitmapsPath, psBitmapPath(self)))
7516>>>>>            Send hmGeneric to hoCallBack (SFormat(C_$SystemPaths, psSystemDfPath(self)))
7517>>>>>            Send hmGeneric to hoCallBack (SFormat(C_$FullDFPath, psDfPath(self)))
7518>>>>>         End
7518>>>>>>
7518>>>>>    End_Procedure
7519>>>>>
7519>>>>>    Function OpenWorkspaceErrorMessage Integer eErrorCode Returns String
7521>>>>>        // Decodes the enumerated integer returned by OpenWorkspace and
7521>>>>>        // returns a corresponding message string.
7521>>>>>        String sError
7521>>>>>
7521>>>>>        Case Begin
7521>>>>>            Case (eErrorCode = wsWorkspaceOpened)
7523>>>>>                Move C_$NoErrors To sError
7524>>>>>                Case Break
7525>>>>>            Case (eErrorCode = wsWorkspaceNotFound)
7528>>>>>                Move C_$NoWsName To sError
7529>>>>>                Case Break
7530>>>>>            Case (eErrorCode = wsWorkspaceFileNotFound)
7533>>>>>                Move C_$NoWsFileFound To sError
7534>>>>>                Case Break
7535>>>>>            Case (eErrorCode = wsDataPathEmpty)
7538>>>>>                Move C_$NoWsDataPath To sError
7539>>>>>                Case Break
7540>>>>>            Case (eErrorCode = wsFileListEmpty)
7543>>>>>                Move C_$NoWsFileList To sError
7544>>>>>                Case Break
7545>>>>>            Case (eErrorCode = wsFileListNotExist)
7548>>>>>                Move C_$NoFileListCfg To sError
7549>>>>>                Case Break
7550>>>>>            Case Else
7550>>>>>                Move C_$UnknownError To sError
7551>>>>>                Case Break
7552>>>>>        Case End
7552>>>>>
7552>>>>>        Function_Return (sError-".")
7553>>>>>    End_Function    // OpenWorkspaceErrorMessage
7554>>>>>
7554>>>>>    Function GetWorkspaceFileName String sWorkspace Returns String
7556>>>>>        // Returns the name of the physical Workspace file for the passed Workspace name.
7556>>>>>        String sVdfRootDir
7556>>>>>        Handle hoIniFile
7556>>>>>        String sPath
7556>>>>>        String sFileName
7556>>>>>        String sWorkspacePath
7556>>>>>
7556>>>>>        Move "" To sFileName
7557>>>>>
7557>>>>>        Get_Profile_String "Defaults" "VdfRootDir" To sVdfRootDir
7560>>>>>        If (Right(sVdfRootDir,1) <>"\") Move (sVdfRootDir +"\") To sVdfRootDir
7563>>>>>
7563>>>>>        Get Create U_cIniFile To hoIniFile
7564>>>>>        Set psFilename of hoIniFile To (sVdfRootDir +"bin\Workspaces.ini")
7565>>>>>        Get ReadString of hoIniFile sWorkspace "Path" "" To sWorkspacePath
7566>>>>>        If (sWorkspacePath <>"") Begin
7568>>>>>            If (Right(sWorkspacePath,1) <>"\") Move (sWorkspacePath +"\") To sWorkspacePath
7571>>>>>            Move (sWorkspacePath +sWorkspace +".ws") To sFileName
7572>>>>>        End
7572>>>>>>
7572>>>>>        Send Destroy of hoIniFile
7573>>>>>
7573>>>>>        Function_Return sFileName
7574>>>>>    End_Function
7575>>>>>
7575>>>>>    Function CountOfPaths String sPaths Returns Integer
7577>>>>>        // Returns the number of paths defined in a string of paths
7577>>>>>        Integer iChar icChar icPath
7577>>>>>
7577>>>>>        If (sPaths ="") Function_Return 0
7580>>>>>
7580>>>>>        Move (Length(sPaths) -1) To icChar
7581>>>>>        For iChar from 1 To icChar
7587>>>>>>
7587>>>>>            If (Mid(sPaths, 1, iChar) =";") Increment icPath
7590>>>>>        Loop
7591>>>>>>
7591>>>>>
7591>>>>>        Function_Return (icPath +1)
7592>>>>>    End_Function
7593>>>>>
7593>>>>>    Function PathAtIndex String sPaths Integer iIndex Returns String
7595>>>>>        // Returns the path at the 1-based index of passed paths.
7595>>>>>        // If the path contains a trailing "\", it will be removed
7595>>>>>        Integer iChar icPath iPath iPos
7595>>>>>        String sPath
7595>>>>>
7595>>>>>        Move (sPaths +";") To sPaths
7596>>>>>        For iPath From 1 To iIndex
7602>>>>>>
7602>>>>>            Move (Pos(";", sPaths)) To iPos
7603>>>>>            If iPos Begin
7605>>>>>                Move (Left(sPaths, iPos -1)) To sPath
7606>>>>>                If (Right(sPath,1) = '\') Move (Left(sPath, Length(sPath) -1)) To sPath
7609>>>>>                Move (Right(sPaths, Length(sPaths) -iPos)) To sPaths
7610>>>>>            End
7610>>>>>>
7610>>>>>            Else Function_Return "" // index past number of paths
7612>>>>>        Loop
7613>>>>>>
7613>>>>>
7613>>>>>        Function_Return sPath
7614>>>>>    End_Function
7615>>>>>
7615>>>>>End_Class
7616>>>>>
7616>>>Use cCommandLine.pkg
Including file: cCommandLine.pkg    (C:\Program Files (x86)\Visual DataFlex 17.1\Pkg\cCommandLine.pkg)
7616>>>>>// CLASS: cCommandLine
7616>>>>>// Author: SWB
7616>>>>>
7616>>>>>use VDFBase.pkg
7616>>>>>
7616>>>>>Class cCommandLine is a cObject
7617>>>>>
7617>>>>>    Procedure Construct_Object
7619>>>>>        Forward Send Construct_Object
7621>>>>>
7621>>>>>        Property Handle phoArgs // private object-handle of internal array of arguments
7622>>>>>    End_Procedure
7623>>>>>
7623>>>>>    Procedure Private_DoCreateArgsArray
7625>>>>>        // creates the array for holding the arguments. Created upon demand only!
7625>>>>>        Integer icArg
7625>>>>>        String sArg
7625>>>>>
7625>>>>>        Object oArgs is an Array
7627>>>>>            Delegate Set phoArgs To self
7629>>>>>            Repeat
7629>>>>>>
7629>>>>>                CmdLine sArg
7630>>>>>>
7630>>>>>                If (sArg <> "") Begin
7632>>>>>                    Increment icArg
7633>>>>>                    Set Value  (icArg -1) To sArg
7634>>>>>                End
7634>>>>>>
7634>>>>>            Until (sArg = "")
7636>>>>>        End_Object
7637>>>>>    End_Procedure
7638>>>>>
7638>>>>>    Function CountOfArgs Returns Integer
7640>>>>>        //Returns the number of arguments passed
7640>>>>>        If (phoArgs(self) =0) Send Private_DoCreateArgsArray
7643>>>>>        Function_Return (Item_Count(phoArgs(self)))
7644>>>>>    End_Function
7645>>>>>
7645>>>>>    Function Argument Integer iIndex Returns String
7647>>>>>        //Returns the one-based argument string
7647>>>>>        If (phoArgs(self) =0) Send Private_DoCreateArgsArray
7650>>>>>        Function_Return (Value(phoArgs(self), iIndex -1))
7651>>>>>    End_Function
7652>>>>>
7652>>>>>End_Class
7653>>>Use cRegistry.pkg
Including file: cRegistry.pkg    (C:\Program Files (x86)\Visual DataFlex 17.1\Pkg\cRegistry.pkg)
7653>>>>>// cRegistry.pkg
7653>>>>>// Author: SWB
7653>>>>>
7653>>>>>//  Registry Access Package
7653>>>>>
7653>>>>>Use Windows.pkg
7653>>>>>Use RegistryAPI.pkg
7653>>>>>
7653>>>>>Enum_List // Registry Data types
7653>>>>>    Define rdString
7653>>>>>    Define rdDword
7653>>>>>    Define rdBinary
7653>>>>>    Define rdUnknown
7653>>>>>End_Enum_List
7653>>>>>
7653>>>>>//Prototypes
7653>>>>>Register_Function phRootKey      Returns Handle // HKEY_CURRENT_USER
7653>>>>>Register_Function pfAccessRights Returns Integer // KEY_ALL_ACCESS - what access level should be used to open a Key?
7653>>>>>Register_Function phCurrentKey   Returns Handle // low-level key
7653>>>>>Register_Function pbLazyWrite    Returns Boolean // True
7653>>>>>
7653>>>>>Register_Function CountOfSubkeys      Returns Integer
7653>>>>>Register_Function CountOfValues       Returns Integer
7653>>>>>Register_Function CreateKey           String sKeyName Returns Integer   // return=error code
7653>>>>>Register_Function DeleteKey           String sKeyName Returns Boolean       // Deleted successfully?
7653>>>>>Register_Function DeleteValue         String sValueName Returns Boolean // Deleted successfully?
7653>>>>>Register_Function GetSubkeys          Handle hoArray Returns Integer    // count of Subkeys
7653>>>>>Register_Function GetValues           Handle hoArray Returns Integer    // count of Values
7653>>>>>Register_Function KeyExists           String sKeyName Returns Boolean   // does the key exist?
7653>>>>>Register_Function LongestDataLength   Returns Integer
7653>>>>>Register_Function LongestSubkeyLength Returns Integer
7653>>>>>Register_Function LongestValueLength  Returns Integer
7653>>>>>Register_Function OpenKey             string sKeyName Returns Integer
7653>>>>>Register_Function ReadBinary          String sValueName Address aValueData Integer iDataLength Returns Boolean
7653>>>>>Register_Function ReadDword           String sValueName Returns DWord
7653>>>>>Register_Function ReadString          String sValueName Returns String
7653>>>>>Register_Function ValueExists         String sValueName Returns Integer // does the Value exist?
7653>>>>>Register_Function ValueLength         String sValueName Returns Integer
7653>>>>>Register_Function ValueType           String sValueName Returns Integer // what is the datatype of the Value?
7653>>>>>Register_Procedure CloseKey
7653>>>>>Register_Procedure WriteBinary        String sValueName Address aValueData Integer iDataLength
7653>>>>>Register_Procedure WriteDword         String sValue DWord dwValueData
7653>>>>>Register_Procedure WriteString        String sValue String sValueData
7653>>>>>
7653>>>>>
7653>>>>>Class cRegistry is a cObject
7654>>>>>    Procedure Construct_Object
7656>>>>>        Forward Send Construct_Object
7658>>>>>
7658>>>>>        Property Handle phRootKey HKEY_CURRENT_USER
7659>>>>>        Property UInteger pfAccessRights  KEY_ALL_ACCESS // what access level should be used to open a Key?
7660>>>>>        Property Handle phCurrentKey
7661>>>>>        Property Boolean pbLazyWrite True
7662>>>>>    End_Procedure
7663>>>>>
7663>>>>>    Function CountOfSubkeys Returns Integer
7665>>>>>        DWord dwCountOfSubkeys
7665>>>>>        Integer iError
7665>>>>>        String sError
7665>>>>>
7665>>>>>        Move 0 To dwCountOfSubkeys
7666>>>>>        Move (RegQueryInfoKey(phCurrentKey(self), 0, 0, 0, AddressOf(dwCountOfSubkeys), 0, 0, 0, 0, 0, 0, 0)) To iError
7667>>>>>        If iError Begin
7669>>>>>            Move (FormatWinError(iError)) To sError // raise an error if the Query failed
7670>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
7671>>>>>>
7671>>>>>        End
7671>>>>>>
7671>>>>>        Function_Return dwCountOfSubkeys
7672>>>>>    End_Function
7673>>>>>
7673>>>>>    Function CountOfValues Returns Integer
7675>>>>>        DWord dwCountOfValues
7675>>>>>        Integer iError
7675>>>>>        String sError
7675>>>>>
7675>>>>>        Move 0 To dwCountOfValues
7676>>>>>        Move (RegQueryInfoKey(phCurrentKey(self), 0, 0, 0, 0, 0, 0, AddressOf(dwCountOfValues), 0, 0, 0, 0)) To iError
7677>>>>>        If iError Begin
7679>>>>>            Move (FormatWinError(iError)) To sError // raise an error if the Query failed
7680>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
7681>>>>>>
7681>>>>>        End
7681>>>>>>
7681>>>>>
7681>>>>>        Function_Return dwCountOfValues
7682>>>>>    End_Function
7683>>>>>
7683>>>>>    Function LongestSubkeyLength Returns Integer
7685>>>>>        DWord dwLongestSubkeyLength
7685>>>>>        Integer iError
7685>>>>>        String sError
7685>>>>>
7685>>>>>        Move 0 To dwLongestSubkeyLength
7686>>>>>        Move (RegQueryInfoKey(phCurrentKey(self), 0, 0, 0, 0, AddressOf(dwLongestSubkeyLength), 0, 0, 0, 0, 0, 0)) To iError
7687>>>>>        If iError Begin
7689>>>>>            Move (FormatWinError(iError)) To sError // raise an error if the Query failed
7690>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
7691>>>>>>
7691>>>>>        End
7691>>>>>>
7691>>>>>
7691>>>>>        Function_Return dwLongestSubkeyLength
7692>>>>>    End_Function
7693>>>>>
7693>>>>>    Function LongestValueLength Returns Integer
7695>>>>>        DWord dwLongestValueLength
7695>>>>>        Integer iError
7695>>>>>        String sError
7695>>>>>
7695>>>>>        Move 0 To dwLongestValueLength
7696>>>>>        Move (RegQueryInfoKey(phCurrentKey(self), 0, 0, 0, 0, 0, 0, 0, AddressOf(dwLongestValueLength), 0, 0, 0)) To iError
7697>>>>>        If iError Begin
7699>>>>>            Move (FormatWinError(iError)) To sError // raise an error if the Query failed
7700>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
7701>>>>>>
7701>>>>>        End
7701>>>>>>
7701>>>>>
7701>>>>>        Function_Return dwLongestValueLength
7702>>>>>    End_Function
7703>>>>>
7703>>>>>    Function LongestDataLength Returns Integer
7705>>>>>        DWord dwLongestDataLength
7705>>>>>        Integer iError
7705>>>>>        String sError
7705>>>>>
7705>>>>>        Move 0 To dwLongestDataLength
7706>>>>>        Move (RegQueryInfoKey(phCurrentKey(self), 0, 0, 0, 0, 0, 0, 0, 0, AddressOf(dwLongestDataLength), 0, 0)) To iError
7707>>>>>        If iError Begin
7709>>>>>            Move (FormatWinError(iError)) To sError // raise an error if the Query failed
7710>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
7711>>>>>>
7711>>>>>        End
7711>>>>>>
7711>>>>>
7711>>>>>        Function_Return dwLongestDataLength
7712>>>>>    End_Function
7713>>>>>
7713>>>>>    Function ValueType String sValueName Returns Integer
7715>>>>>        DWord dwType
7715>>>>>        Integer iError eType
7715>>>>>        String sError
7715>>>>>
7715>>>>>        Move 0 To dwType
7716>>>>>        Move (RegQueryValueEx(phCurrentKey(self), ToAnsi(sValueName), 0, AddressOf(dwType), 0, 0)) To iError
7717>>>>>        If iError Begin
7719>>>>>            Move (FormatWinError(iError)) To sError // raise an error if the Query failed
7720>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
7721>>>>>>
7721>>>>>        End
7721>>>>>>
7721>>>>>
7721>>>>>        If (dwType = REG_SZ)          Move rdString To eType
7724>>>>>        Else If (dwType = REG_DWORD)  Move rdDword To eType
7728>>>>>        Else If (dwType = REG_BINARY) Move rdBinary To eType
7732>>>>>        Else                          Move rdUnknown To eType
7734>>>>>
7734>>>>>        Function_Return eType
7735>>>>>    End_Function
7736>>>>>
7736>>>>>    Function ValueLength String sValueName Returns Integer
7738>>>>>        DWord dwSize
7738>>>>>        Integer iError
7738>>>>>        String sError
7738>>>>>
7738>>>>>        Move 0 To dwSize
7739>>>>>        Move (RegQueryValueEx(phCurrentKey(self), ToAnsi(sValueName), 0, 0, 0, AddressOf(dwSize))) To iError
7740>>>>>        If iError Begin
7742>>>>>            Move (FormatWinError(iError)) To sError // raise an error if the Query failed
7743>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
7744>>>>>>
7744>>>>>        End
7744>>>>>>
7744>>>>>
7744>>>>>        Function_Return dwSize
7745>>>>>    End_Function
7746>>>>>
7746>>>>>    Function CreateKey string sKeyName Returns Integer // return=error code
7748>>>>>        // Calling CreateKey for an existing Key, merely opens it without error.
7748>>>>>        Handle hKey hKeyOpened
7748>>>>>        Integer iError
7748>>>>>        String sError
7748>>>>>
7748>>>>>        Move 0 To hKeyOpened // initialize it so we can get its address
7749>>>>>
7749>>>>>        Get phRootKey To hKey
7750>>>>>
7750>>>>>        Move (RegCreateKeyEx(hKey, ToAnsi(sKeyName), 0, 0, REG_OPTION_NON_VOLATILE, pfAccessRights(self), 0, AddressOf(hKeyOpened), 0)) To iError
7751>>>>>        If (iError =0) Set phCurrentKey To hKeyOpened
7754>>>>>        Else Begin
7755>>>>>            Move (FormatWinError(iError)) To sError // raise an error if the Query failed
7756>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
7757>>>>>>
7757>>>>>        End
7757>>>>>>
7757>>>>>        Function_Return iError
7758>>>>>    End_Function
7759>>>>>
7759>>>>>    Procedure CloseKey
7761>>>>>        Integer iError
7761>>>>>        Handle hKey
7761>>>>>
7761>>>>>        Get phCurrentKey To hKey
7762>>>>>
7762>>>>>        If (hKey <>0) Begin
7764>>>>>            If (pbLazyWrite(self)) Move (RegCloseKey(hKey)) To iError
7767>>>>>            Else Move (RegFlushKey(hKey)) To iError
7769>>>>>
7769>>>>>            Set phCurrentKey To 0
7770>>>>>        End
7770>>>>>>
7770>>>>>    End_Procedure
7771>>>>>
7771>>>>>    Function OpenKey string sKeyName Returns Boolean
7773>>>>>        Handle hKey hKeyOpened
7773>>>>>        Integer iError
7773>>>>>
7773>>>>>        Move 0 To hKeyOpened // initialize it so we can get its address
7774>>>>>
7774>>>>>        Get phRootKey To hKey
7775>>>>>        Move (RegOpenKeyEx(hKey, ToAnsi(sKeyName), 0, pfAccessRights(self), AddressOf(hKeyOpened))) To iError
7776>>>>>        If (iError =0) Set phCurrentKey To hKeyOpened
7779>>>>>
7779>>>>>        Function_Return (iError=0)
7780>>>>>    End_Function
7781>>>>>
7781>>>>>    Procedure WriteDword String sValue DWord dwValueData
7783>>>>>        Handle hKey
7783>>>>>        Integer iError
7783>>>>>        Pointer lpsDWord
7783>>>>>        String sDWord
7783>>>>>        String sError
7783>>>>>
7783>>>>>        ZeroType tDWord To sDWord
7784>>>>>        Put dwValueData To sDWord At tDWord.dword
7785>>>>>        GetAddress of sDWord To lpsDWord
7786>>>>>
7786>>>>>        Get phCurrentKey To hKey
7787>>>>>        Move (RegSetValueEx(hKey, ToAnsi(sValue), 0, REG_DWORD, lpsDWord, 4)) To iError
7788>>>>>        If iError Begin
7790>>>>>            Move (FormatWinError(iError)) To sError // raise an error if the Query failed
7791>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
7792>>>>>>
7792>>>>>        End
7792>>>>>>
7792>>>>>    End_Procedure
7793>>>>>
7793>>>>>    Procedure WriteString String sValue String sValueData
7795>>>>>        Handle hKey
7795>>>>>        Integer iError cbData
7795>>>>>        Pointer lpsValueData
7795>>>>>        String sError
7795>>>>>
7795>>>>>        If (sValueData = "") Begin
7797>>>>>             Move (Character(0)) To sValueData
7798>>>>>             Move 1 To cbData
7799>>>>>        End
7799>>>>>>
7799>>>>>        Else Begin
7800>>>>>             Move (Length(sValueData) +1) To cbData
7801>>>>>        End
7801>>>>>>
7801>>>>>        Move (ToAnsi(sValueData)) To sValueData
7802>>>>>        GetAddress of sValueData To lpsValueData
7803>>>>>
7803>>>>>        Get phCurrentKey To hKey
7804>>>>>        Move (RegSetValueEx(hKey, ToAnsi(sValue), 0, REG_SZ, lpsValueData, cbData)) To iError
7805>>>>>        If iError Begin
7807>>>>>            Move (FormatWinError(iError)) To sError // raise an error if the Query failed
7808>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
7809>>>>>>
7809>>>>>        End
7809>>>>>>
7809>>>>>    End_Procedure
7810>>>>>
7810>>>>>    Procedure WriteBinary String sValueName Address aValueData Integer iDataLength
7812>>>>>        Handle hKey
7812>>>>>        Integer iError
7812>>>>>        String sError
7812>>>>>
7812>>>>>        Get phCurrentKey To hKey
7813>>>>>        Move (RegSetValueEx(hKey, ToAnsi(sValueName), 0, REG_BINARY, aValueData, iDataLength)) To iError
7814>>>>>        If iError Begin
7816>>>>>            Move (FormatWinError(iError)) To sError // raise an error if the Query failed
7817>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
7818>>>>>>
7818>>>>>        End
7818>>>>>>
7818>>>>>    End_Procedure
7819>>>>>
7819>>>>>    Function ReadDword String sValueName Returns DWord
7821>>>>>        Handle hKey
7821>>>>>        Integer iError
7821>>>>>        DWord dwValueData dwValueDataLength
7821>>>>>        String sError
7821>>>>>
7821>>>>>        Move 0           To dwValueData
7822>>>>>        Move tDWord_Size To dwValueDataLength
7823>>>>>
7823>>>>>        Get phCurrentKey To hKey
7824>>>>>        Move (RegQueryValueEx(hKey, ToAnsi(sValueName), 0, 0, AddressOf(dwValueData), AddressOf(dwValueDataLength))) To iError
7825>>>>>        If iError Begin
7827>>>>>            Move (FormatWinError(iError)) To sError // raise an error if the Query failed
7828>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
7829>>>>>>
7829>>>>>        End
7829>>>>>>
7829>>>>>
7829>>>>>        Function_Return dwValueData
7830>>>>>    End_Function
7831>>>>>
7831>>>>>    Function ReadString String sValueName Returns String
7833>>>>>        Handle hKey
7833>>>>>        Integer iError
7833>>>>>        String sValueData
7833>>>>>        DWord dwValueDataLength
7833>>>>>        Pointer lpsValueData
7833>>>>>        String sError
7833>>>>>
7833>>>>>        Move (Repeat(character(0), ValueLength(self, sValueName))) To sValueData
7834>>>>>        GetAddress of sValueData To lpsValueData
7835>>>>>
7835>>>>>        Move (Length(sValueData)) To dwValueDataLength
7836>>>>>
7836>>>>>        Get phCurrentKey To hKey
7837>>>>>        Move (RegQueryValueEx(hKey, ToAnsi(sValueName), 0, 0, lpsValueData, AddressOf(dwValueDataLength))) To iError
7838>>>>>        If iError Begin
7840>>>>>            Move (FormatWinError(iError)) To sError // raise an error if the Query failed
7841>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
7842>>>>>>
7842>>>>>        End
7842>>>>>>
7842>>>>>
7842>>>>>        Function_Return (ToOem(CString(sValueData)))
7843>>>>>    End_Function
7844>>>>>
7844>>>>>    Function ReadBinary String sValueName Address aValueData Integer iDataLength Returns Boolean
7846>>>>>        Handle hKey
7846>>>>>        Integer iError
7846>>>>>        String sError
7846>>>>>
7846>>>>>        Get phCurrentKey To hKey
7847>>>>>        Move (RegQueryValueEx(hKey, ToAnsi(sValueName), 0, 0, aValueData, AddressOf(iDataLength))) To iError
7848>>>>>        If iError Begin
7850>>>>>            Move (FormatWinError(iError)) To sError // raise an error if the Query failed
7851>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
7852>>>>>>
7852>>>>>        End
7852>>>>>>
7852>>>>>
7852>>>>>        Function_Return (iDataLength >0)
7853>>>>>    End_Function
7854>>>>>
7854>>>>>
7854>>>>>    // Private....
7854>>>>>    Function GetBaseKey Returns Handle
7856>>>>>        Handle hBaseKey
7856>>>>>        If (phCurrentKey(self) = 0)  Get phRootKey To hBaseKey
7859>>>>>        Else Get phCurrentKey To hBaseKey
7861>>>>>
7861>>>>>        Function_Return hBaseKey
7862>>>>>    End_Function
7863>>>>>
7863>>>>>    Function GetKey String sKeyName Returns Handle
7865>>>>>        Handle hKeyOpened
7865>>>>>        Integer iError
7865>>>>>
7865>>>>>        MOve 0 To hKeyOpened // initialize so we can get its address
7866>>>>>
7866>>>>>        Move (RegOpenKeyEx(GetBaseKey(self), ToAnsi(sKeyName), 0, pfAccessRights(self), AddressOf(hKeyOpened))) To iError
7867>>>>>
7867>>>>>        If (iError =0) Function_Return hKeyOpened
7870>>>>>        Else           Function_Return 0
7872>>>>>    End_Function
7873>>>>>
7873>>>>>    // Public
7873>>>>>    Function KeyExists String sKeyName Returns Boolean
7875>>>>>        Handle hKey
7875>>>>>        Integer iVoid
7875>>>>>
7875>>>>>        Get GetKey sKeyName To hKey
7876>>>>>        If hKey Move (RegCloseKey(hKey)) To iVoid
7879>>>>>        Function_Return (hKey <>0)
7880>>>>>    End_Function
7881>>>>>
7881>>>>>    Function ValueExists String sValueName Returns Boolean
7883>>>>>        // Determines whether a Value exists for the currently-opened Key.
7883>>>>>        Integer iError
7883>>>>>        Dword dwDataType
7883>>>>>        Move 0 To dwDataType // must initialize the variable to get its address
7884>>>>>
7884>>>>>        Move (RegQueryValueEx(phCurrentKey(self), ToAnsi(sValueName), 0, AddressOf(dwDataType), 0, 0)) To iError
7885>>>>>
7885>>>>>        Function_Return (iError=0)
7886>>>>>    End_Function
7887>>>>>
7887>>>>>    Function DeleteKey String sKeyName Returns Boolean // Deleted successfully?
7889>>>>>        Function_Return (ShDeleteKey(phRootKey(self), ToAnsi(sKeyName)) =0)
7890>>>>>    End_Function
7891>>>>>
7891>>>>>    Function DeleteValue String sValueName Returns Boolean // Deleted successfully?
7893>>>>>        Function_Return (RegDeleteValue(phCurrentKey(self), ToAnsi(sValueName)) =0)
7894>>>>>    End_Function
7895>>>>>
7895>>>>>    Function GetSubkeys Handle hoArray Returns Integer // count of Values
7897>>>>>        Integer iError
7897>>>>>        Integer icValue iLongestSubkey
7897>>>>>        Handle hKey
7897>>>>>        DWord dwSubkeyNameLength
7897>>>>>        String sSubkeyName sFileTime
7897>>>>>        Pointer lpsSubkeyName lpsFileTime
7897>>>>>
7897>>>>>        Get LongestSubkeyLength To iLongestSubkey
7898>>>>>        Move (Repeat(character(0), iLongestSubkey +1)) To sSubkeyName
7899>>>>>        GetAddress of sSubkeyName To lpsSubkeyName
7900>>>>>
7900>>>>>        ZeroType tFileTime To sFileTime
7901>>>>>        GetAddress of sFileTime To lpsFileTime
7902>>>>>
7902>>>>>        Get phCurrentKey To hKey
7903>>>>>        Repeat
7903>>>>>>
7903>>>>>            Move (iLongestSubkey +1) To dwSubkeyNameLength
7904>>>>>
7904>>>>>            Move (RegEnumKeyEx(hKey, icValue, lpsSubkeyName, AddressOf(dwSubkeyNameLength), 0, 0, 0, lpsFileTime)) To iError
7905>>>>>            If (iError =0) Begin
7907>>>>>                Increment icValue
7908>>>>>                Set Value of hoArray (Item_Count(hoArray)) To (ToOem(CString(sSubkeyName)))
7909>>>>>            End
7909>>>>>>
7909>>>>>        Until (iError)
7911>>>>>        Function_Return icValue
7912>>>>>
7912>>>>>    End_Function
7913>>>>>
7913>>>>>    Function GetValues Handle hoArray Returns Integer // count of Values
7915>>>>>        Integer iError
7915>>>>>        Integer icValue iLongestValue
7915>>>>>        Handle hKey
7915>>>>>        DWord dwValueNameLength
7915>>>>>        String sValueName sValueNameSize
7915>>>>>        Pointer lpsValueName
7915>>>>>
7915>>>>>        Get LongestValueLength To iLongestValue
7916>>>>>        Move (Repeat(character(0), iLongestValue +1)) To sValueName
7917>>>>>        GetAddress of sValueName To lpsValueName
7918>>>>>
7918>>>>>        Get phCurrentKey To hKey
7919>>>>>        Repeat
7919>>>>>>
7919>>>>>            Move (iLongestValue +1) To dwValueNameLength
7920>>>>>            Move (RegEnumValue(hKey, icValue, lpsValueName, AddressOf(dwValueNameLength), 0, 0, 0, 0)) To iError
7921>>>>>            If (iError =0) Begin
7923>>>>>                Increment icValue
7924>>>>>                Set Value of hoArray (Item_Count(hoArray)) To (ToOem(CString(sValueName)))
7925>>>>>            End
7925>>>>>>
7925>>>>>        Until (iError)
7927>>>>>        Function_Return icValue
7928>>>>>
7928>>>>>    End_Function
7929>>>>>
7929>>>>>End_Class
7930>>>Use cVersionInfo.pkg
Including file: cVersionInfo.pkg    (C:\Program Files (x86)\Visual DataFlex 17.1\Pkg\cVersionInfo.pkg)
7930>>>>>// Class cVersionInfo
7930>>>>>//
7930>>>>>// Stores version information about the EXE
7930>>>>>// Designed to be instantiated as a child of the Application object
7930>>>>>//
7930>>>>>// Created: Mar 12, 2002   SWB
7930>>>>>
7930>>>>>
7930>>>>>Use Windows.pkg
7930>>>>>Use DLL.pkg
7930>>>>>Use WinKern.pkg
7930>>>>>
7930>>>>>Define VS_FF_DEBUG         for |CI$00000001
7930>>>>>Define VS_FF_PRERELEASE    for |CI$00000002
7930>>>>>Define VS_FF_PATCHED       for |CI$00000004
7930>>>>>Define VS_FF_PRIVATEBUILD  for |CI$00000008
7930>>>>>Define VS_FF_INFOINFERRED  for |CI$00000010
7930>>>>>Define VS_FF_SPECIALBUILD  for |CI$00000020
7930>>>>>
7930>>>>>External_Function GetFileVersionInfoSize "GetFileVersionInfoSizeA" version.dll ;    Pointer aFilename ;    Pointer lpdwHandle ;Returns Dword
7931>>>>>
7931>>>>>External_Function GetFileVersionInfo "GetFileVersionInfoA" version.dll ;    Pointer sFilename ;    Dword dwHandle ;    Dword dwLen ;    Address aData ;Returns Integer
7932>>>>>
7932>>>>>External_Function VerQueryValue "VerQueryValueA" version.dll ;    Address aBlock ;    Address aSubBlock ;    Address aaBuffer ;    Address puLen ;Returns Integer
7933>>>>>
7933>>>>>Type tVsFixedFileInfo
7933>>>>>    Field tVsFixedFileInfo.dwSignature        as Dword
7933>>>>>    Field tVsFixedFileInfo.dwStrucVersion     as Dword
7933>>>>>    Field tVsFixedFileInfo.dwFileVersionMS    as Dword
7933>>>>>    Field tVsFixedFileInfo.dwFileVersionLS    as Dword
7933>>>>>    Field tVsFixedFileInfo.dwProductVersionMS as Dword
7933>>>>>    Field tVsFixedFileInfo.dwProductVersionLS as Dword
7933>>>>>    Field tVsFixedFileInfo.dwFileFlagsMask    as Dword
7933>>>>>    Field tVsFixedFileInfo.dwFileFlags        as Dword
7933>>>>>    Field tVsFixedFileInfo.dwFileOS           as Dword
7933>>>>>    Field tVsFixedFileInfo.dwFileType         as Dword
7933>>>>>    Field tVsFixedFileInfo.dwFileSubtype      as Dword
7933>>>>>    Field tVsFixedFileInfo.dwFileDateMS       as Dword
7933>>>>>    Field tVsFixedFileInfo.dwFileDateLS       as Dword
7933>>>>>End_Type
7933>>>>>
7933>>>>>Class cVersionInfo is a cObject
7934>>>>>    Procedure Construct_Object
7936>>>>>        Forward Send Construct_Object
7938>>>>>
7938>>>>>
7938>>>>>        Property Integer piVersionMajor
7939>>>>>        Property Integer piVersionMinor
7940>>>>>        Property Integer piVersionRelease
7941>>>>>        Property Integer piVersionBuild
7942>>>>>
7942>>>>>        Property Boolean pbIncluded
7943>>>>>        Property Boolean pbSpecialBuild
7944>>>>>        Property Boolean pbPrivateBuild
7945>>>>>
7945>>>>>    End_Procedure
7946>>>>>
7946>>>>>    Procedure DoCreate String sFileName
7948>>>>>        Dword dwHandle
7948>>>>>        Integer iInfoSize iVerSize iSuccess iVersion iVoid iFlags
7948>>>>>        String sData
7948>>>>>        String sVersionBuffer
7948>>>>>        String sVsFixedFileInfo
7948>>>>>        String sSubBlock
7948>>>>>        Address aVsFixedFileInfo
7948>>>>>
7948>>>>>        move 0 To aVsFixedFileInfo
7949>>>>>        Move 0 To dwHandle
7950>>>>>        Move 0 To iVerSize
7951>>>>>
7951>>>>>        Move (GetFileVersionInfoSize(AddressOf(sFilename), AddressOf(dwHandle))) To iInfoSize
7952>>>>>        Set pbIncluded To (iInfoSize <>0)
7953>>>>>
7953>>>>>        If (pbIncluded(self)) Begin
7955>>>>>            Move (Repeat(Character(0), iInfoSize)) To sData
7956>>>>>            Move (GetFileVersionInfo(AddressOf(sFilename), 0, iInfoSize, AddressOf(sData))) To iSuccess
7957>>>>>
7957>>>>>            If (iSuccess <>0) Begin
7959>>>>>                Move "\" To sSubBlock
7960>>>>>                If (VerQueryValue(AddressOf(sData), AddressOf(sSubBlock), AddressOf(aVsFixedFileInfo), AddressOf(iVerSize))) Begin
7962>>>>>                    ZeroType tVsFixedFileInfo To sVsFixedFileInfo
7963>>>>>                    Move (memcopy(AddressOf(sVsFixedFileInfo), aVsFixedFileInfo, iVerSize)) to iVoid // copy the structure
7964>>>>>
7964>>>>>                    GetBuff from sVsFixedFileInfo at tVsFixedFileInfo.dwFileVersionMS To iVersion
7965>>>>>                    Set piVersionMajor To (Hi(iVersion))
7966>>>>>                    Set piVersionMinor To (Low(iVersion))
7967>>>>>
7967>>>>>                    GetBuff from sVsFixedFileInfo at tVsFixedFileInfo.dwFileVersionLS To iVersion
7968>>>>>                    Set piVersionRelease To (Hi(iVersion))
7969>>>>>                    Set piVersionBuild   To (Low(iVersion))
7970>>>>>
7970>>>>>                    GetBuff from sVsFixedFileInfo at tVsFixedFileInfo.dwFileFlags To iFlags
7971>>>>>                    Set pbSpecialBuild    To (iFlags IAND VS_FF_SPECIALBUILD)
7972>>>>>                    Set pbPrivateBuild    To (iFlags IAND VS_FF_PRIVATEBUILD)
7973>>>>>                End
7973>>>>>>
7973>>>>>            End
7973>>>>>>
7973>>>>>
7973>>>>>        End
7973>>>>>>
7973>>>>>    End_Procedure
7974>>>>>
7974>>>>>End_Class
7975>>>>>
7975>>>>>
7975>>>Use GlobalFunctionsProcedures.pkg
7975>>>Use Dferror.pkg
Including file: Dferror.pkg    (C:\Program Files (x86)\Visual DataFlex 17.1\Pkg\Dferror.pkg)
7975>>>>>//************************************************************************
7975>>>>> //
7975>>>>> //* Copyright (c) 1997 Data Access Corporation, Miami Florida,
7975>>>>> //* All rights reserved.
7975>>>>> //* DataFlex is a registered trademark of Data Access Corporation.
7975>>>>> //*
7975>>>>> //*  Module Name:
7975>>>>> //*      DFERROR.PKG
7975>>>>>//************************************************************************
7975>>>>>
7975>>>>>
7975>>>>>
7975>>>>>Use LanguageText.pkg
7975>>>>>
7975>>>>>
7975>>>>>Use Windows.pkg
7975>>>>>Use msgbox.pkg
7975>>>>>Use GlobalFunctionsProcedures.pkg
7975>>>>>
7975>>>>>//integer ghoErrorSource
7975>>>>>//Move 0 to ghoErrorSource
7975>>>>>//// ghoErrorSource object is expected to support this message
7975>>>>>//Register_Function Extended_Error_Message returns string
7975>>>>>
7975>>>>>// Include or define all useful symbols.
7975>>>>>Use ERRORNUM.INC
7975>>>>>// these are kept for compatibility. Don't use them
7975>>>>>
7975>>>>>// used by error handler and UserError to pull a caption out of the error string
7975>>>>>Define C_ErrorCaption for "*CAPTION*="
7975>>>>>
7975>>>>>// This array stores the set of trapped errors as toggled ranges starting
7975>>>>>// with the errors that are trapped. The array should always contain 0 and
7975>>>>>// MAX_ERROR_NUMBER + 1, which are the limits. If an array contained the
7975>>>>>// following items...
7975>>>>>//
7975>>>>>// { 0, 5, 10, MAX_ERROR_NUMBER + 1 }.
7975>>>>>//
7975>>>>>// This would mean that errors 1 - 4 are trapped, 5 - 9 are ignored, and
7975>>>>>// 10 through the rest are trapped.
7975>>>>>//
7975>>>>>Class Trapped_Errors_Array is an array
7976>>>>>
7976>>>>>    // Find largest error LE targetError. Assumes array is sorted.
7976>>>>>    Function findErrorLE Integer targetError Returns Integer
7978>>>>>
7978>>>>>        Integer lowIndex hiIndex midIndex currError
7978>>>>>
7978>>>>>        // If error is outside of boudary conditions, use
7978>>>>>        // value of closest valid error# instead.
7978>>>>>        If targetError le 0;            Move 1 to targetError
7981>>>>>        Else If targetError ge MAX_ERROR_NUMBER ;            Move ( MAX_ERROR_NUMBER - 1 ) to targetError
7985>>>>>
7985>>>>>        Move 0 to lowIndex
7986>>>>>        Move ( item_count( Self ) - 1 ) to hiIndex
7987>>>>>
7987>>>>>        // midIndex will contain the closest error LE to target upon exit.
7987>>>>>        Repeat
7987>>>>>>
7987>>>>>
7987>>>>>            Move ( ( lowIndex + hiIndex ) / 2 ) to midIndex
7988>>>>>            Move ( integer_value( Self, midIndex ) )  to currError
7989>>>>>
7989>>>>>            // midIndex is targetIndex if a match occurs
7989>>>>>            If currError eq targetError ;                Function_Return midIndex
7992>>>>>
7992>>>>>            // We are either on it or just below it.
7992>>>>>            If ( lowIndex eq midIndex ) Begin
7994>>>>>
7994>>>>>                If ( integer_value( Self, hiIndex ) le targetError ) ;                    Move hiIndex to midIndex
7997>>>>>
7997>>>>>                Function_Return midIndex
7998>>>>>
7998>>>>>            End
7998>>>>>>
7998>>>>>
7998>>>>>            // No match, so move the boundaries.
7998>>>>>            If currError gt targetError ;                Move ( midIndex - 1 ) to hiIndex
8001>>>>>            Else ;                Move midIndex to lowIndex
8003>>>>>
8003>>>>>        Until lowIndex gt hiIndex
8005>>>>>
8005>>>>>        Function_Return midIndex
8006>>>>>
8006>>>>>    End_Function
8007>>>>>
8007>>>>>    // Boundaries of the table are assumed to hold error limits.
8007>>>>>    Procedure initArray
8009>>>>>        Send delete_data
8010>>>>>        Set array_value item 0 to 0
8011>>>>>        Set array_value item 1 to ( MAX_ERROR_NUMBER + 1 )
8012>>>>>    End_Procedure
8013>>>>>
8013>>>>>    // Return 1 if Error is trapped, 0 otherwise.
8013>>>>>    Function IsTrapped Integer Error# Returns Integer
8015>>>>>        Function_Return ( not ( mod( findErrorLE( Self, Error# ), 2 ) ) )
8016>>>>>    End_Function
8017>>>>>
8017>>>>>    // Add the error as long as it doesn't violate boundary conditions.
8017>>>>>    // This routine leaves the array unsorted.
8017>>>>>    Procedure addError Integer Error#
8019>>>>>        If ( ( Error# lt MAX_ERROR_NUMBER ) and ( Error# gt 0 ) ) ;            Set array_value item ( item_count( Self ) ) to ( Integer( Error# ) )
8022>>>>>    End_Procedure
8023>>>>>
8023>>>>>    // Set error to flagged state.
8023>>>>>    Procedure handleError Integer Error# Integer trapFlag
8025>>>>>
8025>>>>>        Integer prevErrIndex prevErrFlag prevErrValue nextErrValue
8025>>>>>
8025>>>>>        If ( ( Error# gt MAX_ERROR_NUMBER ) or ( Error# lt 0 ) ) Begin
8027>>>>>            Error DFERR_ERROR_NUMBER_OUT_OF_RANGE
8028>>>>>>
8028>>>>>            Procedure_Return
8029>>>>>        End
8029>>>>>>
8029>>>>>
8029>>>>>        Get findErrorLE Error# to prevErrIndex
8030>>>>>        Get isTrapped   Error# to prevErrFlag
8031>>>>>
8031>>>>>        // if eq, Error already handled in some range.
8031>>>>>        If PrevErrFlag NE trapFlag Begin
8033>>>>>
8033>>>>>          // This is kind of complicated. If we are adding an error,
8033>>>>>          // we have to account for the error already being in the
8033>>>>>          // array as well as rejoining ranges that have been previously
8033>>>>>          // split and splitting ranges when adding a new flag.
8033>>>>>
8033>>>>>          Get integer_value item ( prevErrIndex + 1 ) to nextErrValue
8034>>>>>          Get integer_value item prevErrIndex         to prevErrValue
8035>>>>>
8035>>>>>          // Do this first so prevErrIndex stays valid.
8035>>>>>          If nextErrValue eq ( Error# + 1 ) ;              Send delete_item ( prevErrIndex + 1 )
8038>>>>>          Else ;              Send addError ( Error# + 1 )
8040>>>>>
8040>>>>>          If ( prevErrValue lt Error# ) ;              Send addError Error#
8043>>>>>          Else ;              Send delete_item prevErrIndex
8045>>>>>        End
8045>>>>>>
8045>>>>>        Send sort_items UPWARD_DIRECTION
8046>>>>>
8046>>>>>    End_Procedure
8047>>>>>
8047>>>>>    //*** Flag error as trappable
8047>>>>>    Procedure Trap_Error Integer Error#
8049>>>>>        Send handleError Error# 1
8050>>>>>    End_Procedure
8051>>>>>
8051>>>>>    //*** Flag error as non-trappable
8051>>>>>    Procedure Ignore_Error Integer Error#
8053>>>>>        Send handleError Error# 0
8054>>>>>    End_Procedure
8055>>>>>
8055>>>>>    //*** Flag all errors as trappable
8055>>>>>    Procedure Trap_All
8057>>>>>        Send initArray
8058>>>>>    End_Procedure
8059>>>>>
8059>>>>>    //*** Flag all errors as non-trappable
8059>>>>>    Procedure Ignore_All
8061>>>>>        Send delete_data
8062>>>>>        Set array_value item 0 to 0
8063>>>>>        Set array_value item 1 to 1
8064>>>>>        Set array_value item 2 to ( MAX_ERROR_NUMBER + 1 )
8065>>>>>    End_Procedure
8066>>>>>
8066>>>>>End_Class
8067>>>>>
8067>>>>>
8067>>>>>Class ErrorSystem is a cObject
8068>>>>>
8068>>>>>    Procedure construct_object
8070>>>>>        Forward Send construct_object
8072>>>>>
8072>>>>>        Set delegation_mode to no_delegate_or_error
8073>>>>>
8073>>>>>        Property Integer Verbose_State            True
8074>>>>>        Property Integer Current_Error_Number     0
8075>>>>>        Property Integer Error_Line_Number        0
8076>>>>>        
8076>>>>>        // If set false, this makes the error handler work the old way which
8076>>>>>        // does not use the new unhandled dialog. Only exists for compatibility reasons
8076>>>>>        Property Boolean pbUnhandledErrorSupport       True
8077>>>>>
8077>>>>>        // shows error numbers with user errors. Only set this true if your
8077>>>>>        // application has meaningful numbers that helps the end user. Note that
8077>>>>>        // unhandled errors always show numbers.
8077>>>>>        // this is ignored if pbUnhandledErrorSupport is false
8077>>>>>        Property Boolean pbShowErrorNumber        False
8078>>>>>        
8078>>>>>        
8078>>>>>        // This is the caption that appears for unhandled errors dialog box
8078>>>>>        Property String psUnhandledErrorCaption C_$UnhandledProgramError
8079>>>>>
8079>>>>>        // This is the caption that appears for standard user errors
8079>>>>>        Property String psUserErrorCaption C_$Error
8080>>>>>
8080>>>>>        // Flag which is sent when error is being processed. This
8080>>>>>        // stops error recursion.
8080>>>>>        Property Integer Error_Processing_State  False
8081>>>>>
8081>>>>>        // array of errors that we consider User Errors
8081>>>>>        Property Integer[] pUserErrorsArray
8082>>>>>
8082>>>>>        //  This allows us to skip find errors (GT & LT) and to only
8082>>>>>        //  ring a bell when these occur.
8082>>>>>        //
8082>>>>>        Property Integer Bell_on_Find_Error_State True
8083>>>>>        
8083>>>>>        Object TrappedErrors is a Trapped_Errors_Array
8085>>>>>            Send initArray
8086>>>>>        End_Object
8087>>>>>
8087>>>>>        Send Trap_All
8088>>>>>
8088>>>>>        // define the standard user error numbers
8088>>>>>        Send AddUserError 0
8089>>>>>        Send AddUserError DFERR_NUMBER_TOO_LARGE             
8090>>>>>        Send AddUserError DFERR_WINDOW_RANGE                 
8091>>>>>        Send AddUserError DFERR_ENTRY_REQUIRED               
8092>>>>>        Send AddUserError DFERR_ENTER_A_NUMBER               
8093>>>>>        Send AddUserError DFERR_BAD_ENTRY                    
8094>>>>>        Send AddUserError DFERR_ENTER_VALID_DATE             
8095>>>>>        Send AddUserError DFERR_NUMERIC_RANGE                
8096>>>>>        Send AddUserError DFERR_DUPLICATE_REC
8097>>>>>        Send AddUserError DFERR_TEXT_FIELD_TOO_LONG          
8098>>>>>        Send AddUserError DFERR_FIND_PRIOR_BEG_OF_FILE       
8099>>>>>        Send AddUserError DFERR_FIND_PAST_END_OF_FILE        
8100>>>>>        Send AddUserError DFERR_NO_REC_TO_DELETE
8101>>>>>        Send AddUserError DFERR_FIELD_NOT_INDEXED // can be invoked w/ find keys       
8102>>>>>        Send AddUserError DFERR_REC_NUMBER_RANGE             
8103>>>>>        Send AddUserError DFERR_ENTER_VALID_REC_ID           
8104>>>>>        Send AddUserError DFERR_OPERATOR_ERROR               
8105>>>>>        Send AddUserError DFERR_CANT_CHANGE_KEY_FIELD        
8106>>>>>        Send AddUserError DFERR_NO_DELETE_RELATED_RECORDS_EXIST
8107>>>>>        Send AddUserError DFERR_OPERATION_NOT_ALLOWED        
8108>>>>>        Send AddUserError DFERR_OPERATOR                     
8109>>>>>        Send AddUserError DFERR_XML_HTTP              
8110>>>>>        Send AddUserError DFERR_CLIENT_SOAP_TRANSFER  
8111>>>>>        Send AddUserError DFERR_CLIENT_SOAP_FAULT     
8112>>>>>        Send AddUserError DFERR_TEXT_TOO_LARGE_FOR_FIELD     
8113>>>>>        Send AddUserError DFERR_WINPRINT
8114>>>>>        Send AddUserError DFERR_CRYSTAL_REPORT
8115>>>>>        Send AddUserError DFERR_MAPI
8116>>>>>        Send AddUserError DFERR_FILE_ACCESS_VIOLATION
8117>>>>>        Send AddUserError DFERR_VISUAL_REPORT_WRITER
8118>>>>>        Send AddUserError 999 // This is defined as DD_DEFAULT_ERROR_NUMBER in DataDict.pkg and is the default Field_error
8119>>>>>                              // number of DDs. 
8119>>>>>        Move Self to Error_Object_Id
8120>>>>>    End_Procedure
8121>>>>>
8121>>>>>    Function Help_Context Integer Context_Type Returns String
8123>>>>>       Function_Return (Current_Error_Number(Self))
8124>>>>>    End_Function
8125>>>>>
8125>>>>>    //*** Catch and display error Error#.
8125>>>>>    Procedure Trap_Error Integer Error#
8127>>>>>        Send Trap_Error to ( trappedErrors( Self ) ) Error#
8128>>>>>    End_Procedure
8129>>>>>
8129>>>>>    //*** Pass error Error# on to the regular DataFlex error handler.
8129>>>>>    Procedure Ignore_Error Integer Error#
8131>>>>>        Send Ignore_Error to ( trappedErrors( Self ) ) Error#
8132>>>>>    End_Procedure
8133>>>>>
8133>>>>>    //*** Catch and display all errors.
8133>>>>>    Procedure Trap_All
8135>>>>>        Send Trap_All to ( trappedErrors( Self ) )
8136>>>>>    End_Procedure
8137>>>>>
8137>>>>>    //*** Forward all error to regular DataFlex error handler.
8137>>>>>    Procedure Ignore_All
8139>>>>>        Send Ignore_All to ( trappedErrors( Self ) )
8140>>>>>    End_Procedure
8141>>>>>
8141>>>>>    //*** Build complete error description from Flexerrs and user error message.
8141>>>>>    Function Error_Description Integer Error# String ErrMsg Returns String
8143>>>>>       String Full_Error_Text
8143>>>>>
8143>>>>>       trim ErrMsg to ErrMsg
8144>>>>>>
8144>>>>>       Move (trim(error_text(DESKTOP,Error#))) to Full_Error_Text
8145>>>>>
8145>>>>>       If (ErrMsg<>"") Begin
8147>>>>>
8147>>>>>         If ( ( Full_Error_Text<>"" ) and ;                 error_text_available( DESKTOP, Error# ) ) Begin
8149>>>>>             // Make sure last character of error text is a separating symbol.
8149>>>>>             // if not, add a "." So we have format of "error-text. error-detail"
8149>>>>>             If ( pos(right(Full_error_text,1),".,:;")=0 ) ;                 Move (Full_Error_Text - ".") to Full_Error_Text
8152>>>>>             Move (Full_Error_Text * ErrMsg) to Full_Error_Text
8153>>>>>        End
8153>>>>>>
8153>>>>>            Else ;             Move ErrMsg to Full_Error_Text
8155>>>>>
8155>>>>>          End
8155>>>>>>
8155>>>>>
8155>>>>>       Function_Return Full_Error_Text
8156>>>>>    End_Function
8157>>>>>
8157>>>>>    //** return true if an error number is critical
8157>>>>>    Function Is_Critical Integer Error# Returns Integer
8159>>>>>       Function_Return (".3.10.18.19.20.21.22.43.70.72.74.75.78.80.97.";             contains ("."+String(Error#)+"."))
8160>>>>>    End_Function
8161>>>>>    
8161>>>>>    // adds a user error to the array
8161>>>>>    Procedure AddUserError Integer iError
8163>>>>>        Integer[] UserErrors
8164>>>>>        Get pUserErrorsArray to UserErrors
8165>>>>>        // We assume that there are few enough user errors to worry about speed of finding
8165>>>>>        // the an array item. It always does a linear seach, which should be plenty fast.
8165>>>>>        If (SearchArray(iError,UserErrors)=-1) Begin
8167>>>>>            Move iError to UserErrors[SizeOfArray(UserErrors)]
8168>>>>>            Set pUserErrorsArray to UserErrors
8169>>>>>        End
8169>>>>>>
8169>>>>>    End_Procedure
8170>>>>>    
8170>>>>>    // removes an error from the user array
8170>>>>>    Procedure RemoveUserError Integer iError
8172>>>>>        Integer[] UserErrors
8173>>>>>        Integer iIndex iSize
8173>>>>>        Get pUserErrorsArray to UserErrors
8174>>>>>        Move (SearchArray(iError,UserErrors)) to iIndex
8175>>>>>        If (iIndex<>-1) Begin
8177>>>>>            // replace the removed error with the last error and resize the array
8177>>>>>            Move (SizeOfArray(UserErrors)) to iSize
8178>>>>>            Move UserErrors[iSize-1] to UserErrors[iIndex]
8179>>>>>            Set pUserErrorsArray to (ResizeArray(UserErrors,iSize-1))
8180>>>>>        End
8180>>>>>>
8180>>>>>    End_Procedure
8181>>>>>
8181>>>>>    // removes all user errors
8181>>>>>    Procedure RemoveAllUserErrors
8183>>>>>        Integer[] UserErrors
8184>>>>>        Set pUserErrorsArray to UserErrors
8185>>>>>    End_Procedure
8186>>>>>
8186>>>>>    // returns true if this is an unhandled error (i.e., not a user error
8186>>>>>    Function IsUnhandledError Integer iError Returns Boolean
8188>>>>>        Integer[] UserErrors
8189>>>>>        Get pUserErrorsArray to UserErrors
8190>>>>>        Function_Return (SearchArray(iError,UserErrors)=-1)
8191>>>>>    End_Function
8192>>>>>    
8192>>>>>    Procedure UnhandledErrorDisplay Integer iErrorLine String sMessage 
8194>>>>>        String sCaption sCRLF
8194>>>>>        Move (Character(13)+Character(10)) to sCRLF
8195>>>>>        Get psUnhandledErrorCaption to sCaption
8196>>>>>        Move (Replaces("\n",sMessage,sCRLF)) to sMessage
8197>>>>>        Move (Replaces("\"+sCRLF, sMessage, "\n")) to sMessage
8198>>>>>        ErrorDisplay iErrorLine sMessage sCaption C_$OK C_$Copy
8199>>>>>    End_Procedure
8200>>>>>
8200>>>>>    //*** Handle error event, displaying error info to user.
8200>>>>>    Procedure Error_Report Integer ErrNum Integer Err_Line String ErrMsg
8202>>>>>       Integer iReply iIcon
8202>>>>>       String  sErrorText sMess
8202>>>>>       String  sSource sCaption
8202>>>>>       Integer iSrcPos iSrc iTxtLen
8202>>>>>       Boolean bIsUnhandled bUnhandledSupport bCritical bVerbose
8202>>>>>       
8202>>>>>       If (Error_processing_State(Self)) Begin // don't allow error
8204>>>>>          Procedure_Return                     // recursion
8205>>>>>       End
8205>>>>>>
8205>>>>>
8205>>>>>       Set Error_Processing_State to True // we are now in an error reporting state
8206>>>>>
8206>>>>>       Set Current_Error_Number to ErrNum
8207>>>>>       Set Error_Line_Number    to Err_Line
8208>>>>>
8208>>>>>       // if this is false, this will work old-style -- all errors go through message box
8208>>>>>       Get pbUnhandledErrorSupport to bUnhandledSupport
8209>>>>>       
8209>>>>>       Get Is_Critical errnum to bCritical
8210>>>>>       Get IsUnhandledError ErrNum to bIsUnhandled
8211>>>>>
8211>>>>>       
8211>>>>>       //
8211>>>>>       //   Changes made so find errors don't report - just beep
8211>>>>>       //
8211>>>>>
8211>>>>>       If ( Bell_On_find_Error_State(Self) and ;            ErrNum=DFERR_FIND_PRIOR_BEG_OF_FILE or ErrNum=DFERR_FIND_PAST_END_OF_FILE) Begin
8213>>>>>          Send Bell
8214>>>>>       End
8214>>>>>>
8214>>>>>       Else If not ( isTrapped( TrappedErrors( Self ), ErrNum ) ) Begin
8217>>>>>          // if trapped do nothing
8217>>>>>
8217>>>>>          // We used to forward send. Since this is based on array, it does not understand this message, the forward was
8217>>>>>          // not understood. Since arrays don't delegate or error, nothing happened.
8217>>>>>          // An easier way to do nothing, is to do nothing, hence this line if removed
8217>>>>>          //forward send Error_Report ErrNum Err_Line ErrMsg
8217>>>>>       End
8217>>>>>>
8217>>>>>       Else Begin
8218>>>>>
8218>>>>>         // See if source information is provided (Source = module.function). If so remove
8218>>>>>         // as detail. Must find last instance of this in string
8218>>>>>         Move (pos(C_ErrorContextSourceText,ErrMsg)) to iSrc
8219>>>>>         If iSrc Begin
8221>>>>>            Move (iSrc-1) to iSrcPos
8222>>>>>            Move (length(C_ErrorContextSourceText)) to  iTxtLen
8223>>>>>            Move ErrMsg to sSource
8224>>>>>            Repeat // this makes sure we find last instance of this
8224>>>>>>
8224>>>>>                Move (remove(sSource, 1, iSrc-1 + iTxtLen )) to sSource // right part of string
8225>>>>>                Move (pos(C_ErrorContextSourceText,sSource)) to iSrc           // see if it was the last
8226>>>>>                If iSrc ;                                               // if not, track length                   Move (iSrcPos + iTxtLen + iSrc-1) to iSrcPos
8229>>>>>            Until (iSrc=0)
8231>>>>>            Move (trim(left(ErrMsg,iSrcPos))) to ErrMsg
8232>>>>>            If (right(ErrMsg,1)=',') ;               Move (left(ErrMsg,length(ErrMsg)-1)) to ErrMsg
8235>>>>>         End
8235>>>>>>
8235>>>>>         
8235>>>>>         // the caption normally used for handled user errors
8235>>>>>         Get psUserErrorCaption to sCaption
8236>>>>>         // if an operator error this may be a Procedure UserError situation where the
8236>>>>>         // caption is passed in the error text. If so, get the caption
8236>>>>>         If (ErrNum=DFERR_OPERATOR) Begin
8238>>>>>             Move (pos(C_ErrorCaption,ErrMsg)) to iSrc
8239>>>>>             If iSrc Begin
8241>>>>>                Move (length(C_ErrorCaption)) to  iTxtLen
8242>>>>>                Move (remove(ErrMsg, 1, iSrc-1 + iTxtLen )) to sCaption
8243>>>>>                Move (Left(ErrMsg,iSrc-1)) to ErrMsg
8244>>>>>             End
8244>>>>>>
8244>>>>>         End
8244>>>>>>
8244>>>>>
8244>>>>>         Get Error_Description ErrNum ErrMsg to sErrorText
8245>>>>>
8245>>>>>         // if the error source is identified we can get extended error
8245>>>>>         // text for our error message
8245>>>>>         If ghoErrorSource Begin
8247>>>>>            Get extended_error_Message of ghoErrorSource to sMess
8248>>>>>            If sMess ne '' ;               Move (sErrorText + "\n\n" + sMess ) to sErrorText
8251>>>>>         End
8251>>>>>>
8251>>>>>         
8251>>>>>         If (bUnhandledSupport) Begin
8253>>>>>             // as of 14.1, this is the preferred way to do errors
8253>>>>>             If ( bCritical or bIsUnhandled) Begin
8255>>>>>                 Move ( sErrorText + "\n\n" + C_$Error + ":" * String(ErrNum) ) to sErrorText
8256>>>>>                 If (sSource<>"") Begin
8258>>>>>                    Move (sErrorText + "\n" + C_$ErrorSource +" =" * sSource) to sErrorText
8259>>>>>                 End
8259>>>>>>
8259>>>>>             End
8259>>>>>>
8259>>>>>             Else If (pbShowErrorNumber(Self)) Begin
8262>>>>>                  // if a user error, we provide a way to see error numbers.
8262>>>>>                  Move ( sErrorText + "\n\n" + C_$Error + ":" * String(ErrNum) ) to sErrorText
8263>>>>>             End
8263>>>>>>
8263>>>>>         End
8263>>>>>>
8263>>>>>         Else Begin
8264>>>>>             // we get here if we want it to work the old (less good) way. This is provided
8264>>>>>             // only for backwards compatibility. All errors go through the message box
8264>>>>>             Get Verbose_State to bVerbose
8265>>>>>             If (bVerbose)  Begin
8267>>>>>                 Move ( sErrorText + "\n\n" + SFormat(C_$TechnicalDetails, ErrNum, Err_Line) ) to sErrorText
8268>>>>>                 If (sSource<>"") Begin
8270>>>>>                    Move (sErrorText + "\n" + C_$ErrorSource +" =" * sSource) to sErrorText
8271>>>>>                 End
8271>>>>>>
8271>>>>>             End
8271>>>>>>
8271>>>>>         End
8271>>>>>>
8271>>>>>         
8271>>>>>         If ( (bCritical or bIsUnhandled) and bUnhandledSupport) Begin
8273>>>>>             Send UnhandledErrorDisplay Err_Line sErrorText
8274>>>>>         End
8274>>>>>>
8274>>>>>         Else Begin
8275>>>>>             Move (If(bCritical,MB_IconHand,MB_IconExclamation)) to iIcon
8276>>>>>             Get Message_Box sErrorText sCaption MB_Ok iIcon to iReply
8277>>>>>         End
8277>>>>>>
8277>>>>>
8277>>>>>         // abort on critical errors
8277>>>>>         If bCritical Abort
8280>>>>>
8280>>>>>       End
8280>>>>>>
8280>>>>>       Move 0 to ghoErrorSource
8281>>>>>       Set Error_Processing_State to False // no longer reporting an error
8282>>>>>    End_Procedure
8283>>>>>
8283>>>>>
8283>>>>>    // JJT- Note if you are using the WINDAF windows help system
8283>>>>>    //      the following functions are not used.
8283>>>>>
8283>>>>>    // The functions below are used to construct a general help
8283>>>>>    // name for errors that are generated by the system.  If processing
8283>>>>>    // comes here, then there was no module specific help found.  These
8283>>>>>    // functions will provide a more general help name that appears in
8283>>>>>    // the form of SYSTEM..ERROR:#.  All global errors should be
8283>>>>>    // places in the help file under this application and module name.
8283>>>>>
8283>>>>>    //*** Returns "ERROR:errornum" to supply error help.
8283>>>>>    Function Help_Name Returns String
8285>>>>>       Function_Return (Append("ERROR:",lastErr))
8286>>>>>    End_Function
8287>>>>>
8287>>>>>    Function Application_Name Returns String
8289>>>>>       Function_Return 'SYSTEM'
8290>>>>>    End_Function
8291>>>>>
8291>>>>>    Function Module_Name Returns String
8293>>>>>       Function_Return ''
8294>>>>>    End_Function
8295>>>>>End_Class
8296>>>>>
8296>>>>>Object Error_Info_Object is a ErrorSystem
8298>>>>>End_Object
8299>>>>>
8299>>>>>
8299>>>>>Procedure UserError Global String sMessage String sCaption
8301>>>>>    String sCapt
8301>>>>>    If (Error_Object_Id=0) Begin
8303>>>>>        Error DFERR_PROGRAM "No Error Handler"
8304>>>>>>
8304>>>>>        Procedure_Return
8305>>>>>    End
8305>>>>>>
8305>>>>>    
8305>>>>>    // Accept not passing a caption in which case the error handler's
8305>>>>>    // default caption. It had been the intention to require a caption ("" if none)
8305>>>>>    // but having no caption kind of worked where the caption would be "0". Since it
8305>>>>>    // kind of worked, I don't want to remove this which might generate runtime errors.
8305>>>>>    If (num_arguments>1) Begin
8307>>>>>        Move sCaption to sCapt
8308>>>>>    End
8308>>>>>>
8308>>>>>    
8308>>>>>    Error DFERR_OPERATOR (sMessage + If(sCapt<>"",C_ErrorCaption + sCapt,""))
8309>>>>>>
8309>>>>>    
8309>>>>>End_Procedure
8310>>>Use tWinStructs.pkg
8310>>>
8310>>>Register_Function phoWorkspace Returns Handle
8310>>>Register_Function phoCommandLine Returns Handle
8310>>>Register_Function pbEnterKeyAsTabKey Returns Boolean
8310>>>Register_Function GetApplicationName Returns String
8310>>>Register_Function GetApplicationFileName Returns String
8310>>>
8310>>>Register_Function Statusbar_State Returns Integer
8310>>>Register_Function Toolbar_State Returns Integer
8310>>>Register_Procedure Set Statusbar_State
8310>>>Register_Procedure Set Toolbar_State
8310>>>
8310>>>Class cApplication is a cObject
8311>>>    Procedure Construct_Object
8313>>>        Forward Send Construct_Object
8315>>>
8315>>>        Move self To ghoApplication
8316>>>
8316>>>        Property Handle phoVersionInfo
8317>>>        Property Handle phoWorkspace
8318>>>        Property Handle phoCommandLine
8319>>>        Property Handle phoMainPanel       // main panel will set this for us.
8320>>>        Property String psHelpFile         // type of file is determined by peHelpType
8321>>>        Property Integer peHelpType htWinHelp // htNoHelp htHtmlHelp htWinHelp
8322>>>
8322>>>        Property String psCompany "Data Access Worldwide"
8323>>>        Property String psProduct "Visual DataFlex Applications"
8324>>>        Property String psVersion "1"
8325>>>        Property String psProgram (Module_Name(desktop))
8326>>>        
8326>>>        // set to '' to stop the auto open workspace behavior
8326>>>        Property String psAutoOpenWorkspace 'Config.ws' 
8327>>>
8327>>>
8327>>>        Property Boolean pbPreserveEnvironment True
8328>>>
8328>>>        Object oCommandLine is a cCommandLine
8330>>>            delegate Set phoCommandLine To self
8332>>>        End_Object
8333>>>
8333>>>        Object oWorkspace is a cWorkspace
8335>>>            delegate Set phoWorkspace To self
8337>>>        End_Object
8338>>>
8338>>>        Object oVersionInfo is a cVersionInfo
8340>>>            delegate Set phoVersionInfo To self
8342>>>            Send DoCreate (GetApplicationFileName(parent(self)))
8343>>>        End_Object
8344>>>        
8344>>>        Set pbUseWindowsFont to True
8345>>>
8345>>>    End_Procedure
8346>>>
8346>>>    //************************************************************************************
8346>>>    // Get/Set pbEnterKeyAsTabKey
8346>>>    // Determines if the Enter key should act like the Tab key (and send msg_Next)
8346>>>    // The use of a global variable, gbKEnterNext, makes this an application-wide property
8346>>>    //************************************************************************************
8346>>>    Procedure Set pbEnterKeyAsTabKey Boolean bNext
8348>>>        Move bNext to gbKEnterNext
8349>>>    End_Procedure
8350>>>
8350>>>    Function pbEnterKeyAsTabKey Returns Boolean
8352>>>        Function_Return gbKEnterNext
8353>>>    End_Function
8354>>>
8354>>>    Procedure DoLoadEnvironment Handle hoContainer Boolean bProgram
8356>>>// not used with webapp
8356>>>        Handle hoRegistry hoCommandBars
8356>>>        Integer iError cxy
8356>>>        tWinWindowPlacement WindowPlacement
8356>>>        tWinWindowPlacement WindowPlacement
8356>>>        String sKey
8356>>>        Boolean bSuccess
8356>>>        String sObjectName
8356>>>
8356>>>        If (pbPreserveEnvironment(self)) Begin
8358>>>            Get Create U_cRegistry To hoRegistry
8359>>>            Set pfAccessRights of hoRegistry To KEY_READ
8360>>>
8360>>>            Get RegistryKeyString To sKey
8361>>>
8361>>>            If (bProgram = False) Begin
8363>>>                Move (sKey +"\WINDOWS") To sKey
8364>>>                Get Object_Label of hoContainer To sObjectName  // just get the local name
8365>>>                Move (sKey +"\" +sObjectName) To sKey
8366>>>            End
8366>>>>
8366>>>            Else ;                Move (sKey + "\Preferences") To sKey
8368>>>
8368>>>            Get OpenKey of hoRegistry sKey To bSuccess
8369>>>
8369>>>            If bSuccess Begin
8371>>>                If (ValueExists(hoRegistry, 'Placement')) Begin
8373>>>                    Get ReadBinary of hoRegistry "Placement" (AddressOf(WindowPlacement)) (SizeOfType(tWinWindowPlacement)) to bSuccess
8374>>>                    If bSuccess Begin
8376>>>                        // Do not restore size if the window is not resizable
8376>>>                        If (Border_Style(hoContainer) <> BORDER_THICK) Begin
8378>>>                            // restore always works with outer size
8378>>>                            Get GuiWindowSize     of hoContainer to cxy
8379>>>                            Move (WindowPlacement.NormalPosition.left + Low(cxy)) to WindowPlacement.NormalPosition.right 
8380>>>                            Move (WindowPlacement.NormalPosition.top + Hi(cxy)) to WindowPlacement.NormalPosition.bottom
8381>>>                        End
8381>>>>
8381>>>                        Move (SetWindowPlacement(Window_Handle(hoContainer), AddressOf(WindowPlacement))) to bSuccess
8382>>>                    End
8382>>>>
8382>>>                End
8382>>>>
8382>>>                If bProgram Begin
8384>>>                    Get phoCommandBars of hoContainer to hoCommandBars
8385>>>                    If not hoCommandBars Begin
8387>>>                        If (ValueExists(hoRegistry, 'IsStatusBarVisible')) ;                            Set Statusbar_State of hoContainer to (ReadDword(hoRegistry, 'IsStatusBarVisible'))
8390>>>                        If (ValueExists(hoRegistry, 'IsToolBarVisible'))   ;                            Set Toolbar_State   of hoContainer to (ReadDword(hoRegistry, 'IsToolBarVisible'))
8393>>>                    End
8393>>>>
8393>>>                End
8393>>>>
8393>>>
8393>>>                Send CloseKey of hoRegistry
8394>>>            End
8394>>>>
8394>>>
8394>>>            Send Destroy of hoRegistry
8395>>>        End
8395>>>>
8395>>>    End_Procedure
8396>>>
8396>>>    Procedure DoSaveEnvironment Handle hoContainer Boolean bProgram
8398>>>// not used with webapp
8398>>>        Handle hoRegistry 
8398>>>        Integer iError
8398>>>        tWinWindowPlacement WindowPlacement
8398>>>        tWinWindowPlacement WindowPlacement
8398>>>        String sKey
8398>>>        Boolean bSuccess
8398>>>        Integer eShowCmd
8398>>>        String sObjectName
8398>>>
8398>>>        If (pbPreserveEnvironment(self)) Begin
8400>>>            Get Create U_cRegistry To hoRegistry
8401>>>            Get RegistryKeyString To sKey
8402>>>
8402>>>            If (bProgram = False) Begin
8404>>>                Move (sKey +"\WINDOWS") To sKey
8405>>>                Get Object_Label of hoContainer To sObjectName  // just get the local name
8406>>>                Move (sKey +"\" +sObjectName) To sKey
8407>>>            End
8407>>>>
8407>>>            Else ;                Move (sKey +"\Preferences") To sKey
8409>>>
8409>>>            Get CreateKey of hoRegistry sKey To iError
8410>>>            If (iError = 0) Begin
8412>>>                Move (SizeOfType(tWinWindowPlacement)) to WindowPlacement.length
8413>>>                Move (GetWindowPlacement(Window_Handle(hoContainer), AddressOf(WindowPlacement))) to bSuccess
8414>>>                If bSuccess Begin
8416>>>                    // if minimized, assume restored, as we don't want to restart minimized!
8416>>>                    If (WindowPlacement.showCmd = SW_SHOWMINIMIZED) Begin
8418>>>                        Move SW_SHOWNORMAL to WindowPlacement.showCmd
8419>>>                    End
8419>>>>
8419>>>                    Send WriteBinary of hoRegistry "Placement" (AddressOf(WindowPlacement)) WindowPlacement.length
8420>>>                End
8420>>>>
8420>>>
8420>>>                If bProgram Begin
8422>>>                    Send WriteDword of hoRegistry 'IsStatusBarVisible' (Statusbar_State(hoContainer))
8423>>>                    Send WriteDword of hoRegistry 'IsToolBarVisible'   (Toolbar_State(hoContainer))
8424>>>                End
8424>>>>
8424>>>
8424>>>
8424>>>                Send CloseKey of hoRegistry
8425>>>            End
8425>>>>
8425>>>
8425>>>            Send Destroy of hoRegistry
8426>>>        End
8426>>>>
8426>>>    End_Procedure
8427>>>
8427>>>    Function RegistryKeyString Returns String
8429>>>        String sCompany sProduct sVersion sProgram
8429>>>
8429>>>        Get psCompany To sCompany
8430>>>        Get psProduct To sProduct
8431>>>        Get psVersion To sVersion
8432>>>        Get psProgram To sProgram
8433>>>
8433>>>        If (sCompany = "") Move "Data Access Worldwide"        To sCompany
8436>>>        If (sProduct = "") Move "Visual DataFlex Applications" To sProduct
8439>>>        If (sVersion = "") Move "1"                            To sVersion
8442>>>        If (sProgram ="") Move (Module_Name(desktop))             To sProgram
8445>>>
8445>>>        Function_Return ("SOFTWARE\" +sCompany +"\" +sProduct +"\" +sVersion +"\" +sProgram)
8446>>>    End_Function
8447>>>
8447>>>    Procedure WriteString String sSubKey String sValueName String sValueData
8449>>>        String sKey
8449>>>        Handle hoRegistry
8449>>>        Integer iError
8449>>>
8449>>>        Get Create U_cRegistry To hoRegistry
8450>>>        Get RegistryKeyString To sKey
8451>>>        If (sSubKey <>"") Move (sKey +'\' +sSubKey) To sKey
8454>>>        Get CreateKey of hoRegistry sKey To iError
8455>>>        If (iError = 0) Begin
8457>>>            Send WriteString of hoRegistry sValueName sValueData
8458>>>            Send CloseKey of hoRegistry
8459>>>        End
8459>>>>
8459>>>
8459>>>        Send Destroy of hoRegistry
8460>>>    End_Procedure
8461>>>    Procedure WriteDword String sSubKey String sValueName Dword dwValueData
8463>>>        String sKey
8463>>>        Handle hoRegistry
8463>>>        Integer iError
8463>>>
8463>>>        Get Create U_cRegistry To hoRegistry
8464>>>        Get RegistryKeyString To sKey
8465>>>        If (sSubKey <>"") Move (sKey +'\' +sSubKey) To sKey
8468>>>        Get CreateKey of hoRegistry sKey To iError
8469>>>        If (iError = 0) Begin
8471>>>            Send WriteDword of hoRegistry sValueName dwValueData
8472>>>            Send CloseKey of hoRegistry
8473>>>        End
8473>>>>
8473>>>
8473>>>        Send Destroy of hoRegistry
8474>>>    End_Procedure
8475>>>    Procedure WriteBinary String sSubKey String sValueName Address aValueData Integer iDataLength
8477>>>        String sKey
8477>>>        Handle hoRegistry
8477>>>        Integer iError
8477>>>
8477>>>        Get Create U_cRegistry To hoRegistry
8478>>>        Get RegistryKeyString To sKey
8479>>>        If (sSubKey <>"") Move (sKey +'\' +sSubKey) To sKey
8482>>>        Get CreateKey of hoRegistry sKey To iError
8483>>>        If (iError = 0) Begin
8485>>>            Send WriteBinary of hoRegistry sValueName aValueData iDataLength
8486>>>            Send CloseKey of hoRegistry
8487>>>        End
8487>>>>
8487>>>
8487>>>        Send Destroy of hoRegistry
8488>>>    End_Procedure
8489>>>
8489>>>    // returns true if both sub-key and value exists.
8489>>>    Function ValueExists string sSubKey string sValueName returns Boolean
8491>>>        String sKey
8491>>>        Handle hoRegistry
8491>>>        Boolean bOK
8491>>>        Get Create U_cRegistry To hoRegistry
8492>>>        Get RegistryKeyString To sKey
8493>>>        If (sSubKey <>"") Move (sKey +'\' +sSubKey) To sKey
8496>>>        Get OpenKey of hoRegistry sKey To bOk
8497>>>        If (bOK) Begin
8499>>>           Move (ValueExists(hoRegistry, sValueName)) TO bOk
8500>>>           Send CloseKey of hoRegistry
8501>>>        End
8501>>>>
8501>>>        Send Destroy of hoRegistry
8502>>>        Function_Return bOk
8503>>>    End_Function
8504>>>
8504>>>    Function ReadString String sSubKey String sValueName string sDefault Returns String
8506>>>        String sKey sData
8506>>>        Handle hoRegistry
8506>>>        Boolean bOK
8506>>>
8506>>>        Move sDefault to sData
8507>>>        Get Create U_cRegistry To hoRegistry
8508>>>        Get RegistryKeyString To sKey
8509>>>        If (sSubKey <>"") Move (sKey +'\' +sSubKey) To sKey
8512>>>        Get OpenKey of hoRegistry sKey To bOk
8513>>>        If (bOK) Begin
8515>>>            If (ValueExists(hoRegistry, sValueName)) ;                Get ReadString of hoRegistry sValueName To sData
8518>>>            Send CloseKey of hoRegistry
8519>>>        End
8519>>>>
8519>>>
8519>>>        Send Destroy of hoRegistry
8520>>>        Function_Return sData
8521>>>    End_Function
8522>>>
8522>>>    Function ReadDword String sSubKey String sValueName dword dwDefault Returns DWord
8524>>>        String sKey
8524>>>        DWord dwData
8524>>>        Handle hoRegistry
8524>>>        Boolean bOK
8524>>>
8524>>>        Move dwDefault to dwData
8525>>>        Get Create U_cRegistry To hoRegistry
8526>>>        Get RegistryKeyString To sKey
8527>>>        If (sSubKey <>"") Move (sKey +'\' +sSubKey) To sKey
8530>>>        Get OpenKey of hoRegistry sKey To bOk
8531>>>        If bOK Begin
8533>>>            If (ValueExists(hoRegistry, sValueName)) ;                Get ReadDword of hoRegistry sValueName To dwData
8536>>>            Send CloseKey of hoRegistry
8537>>>        End
8537>>>>
8537>>>
8537>>>        Send Destroy of hoRegistry
8538>>>        Function_Return dwData
8539>>>    End_Function
8540>>>
8540>>>    Function ReadBinary String sSubKey String sValueName Address aValueData Integer iDataLength Returns Boolean
8542>>>        String sKey
8542>>>        Handle hoRegistry
8542>>>        Boolean bOK bSuccess
8542>>>
8542>>>        Get Create U_cRegistry To hoRegistry
8543>>>        Get RegistryKeyString To sKey
8544>>>        If (sSubKey <>"") Move (sKey +'\' +sSubKey) To sKey
8547>>>        Get OpenKey of hoRegistry sKey To bOk
8548>>>        If bOK Begin
8550>>>            Get ReadBinary of hoRegistry sValueName aValueData iDataLength To bSuccess
8551>>>            Send CloseKey of hoRegistry
8552>>>        End
8552>>>>
8552>>>
8552>>>        Send Destroy of hoRegistry
8553>>>        Function_Return bSuccess
8554>>>    End_Function
8555>>>
8555>>>    Procedure DoOpenWorkspace String sWorkspace
8557>>>        // Tries to open in this order:
8557>>>        // 1) if absolute path, use that; otherwise
8557>>>        // 2) try to open in the path of the EXE; otherwise
8557>>>        // 3) load it via the Registered list
8557>>>
8557>>>        Integer eOpened
8557>>>        String sError sWSFile
8557>>>        Handle hoWorkspace
8557>>>
8557>>>        // As soon as an open is attempted, the application's object psAutoOpenWorkspace property
8557>>>        // is cleared. This way any attempt to manually open a workspace during its construction,
8557>>>        // which includes OnCreate, will stop the object from attempting to automatically open the
8557>>>        // workspace. This was added to make psAutoOpenWorkspace compatible with older applications.
8557>>>        // Typically these application will open a workspace in OnCreate. If this happens we assume
8557>>>        // that there should be no automatic opening of a worskpace.  
8557>>>        Set psAutoOpenWorkspace to ""
8558>>>        
8558>>>        Get phoWorkspace to hoWorkspace
8559>>>
8559>>>        Get OpenWorkspaceFile of hoWorkspace sWorkspace To eOpened
8560>>>        If (eOpened = wsWorkspaceFileNotFound) Begin
8562>>>            If (IsRegistered(hoWorkspace, sWorkspace) =True) Begin
8564>>>                Get OpenWorkspace of hoWorkspace sWorkspace To eOpened
8565>>>            End
8565>>>>
8565>>>        End
8565>>>>
8565>>>        If (eOpened <> wsWorkspaceOpened) Begin
8567>>>            Get OpenWorkspaceErrorMessage of hoWorkspace eOpened To sError
8568>>>            Get psWorkspaceWSFile of hoWorkspace to sWSFile
8569>>>            Error DFERR_CAPPLICATION (SFormat(C_$TheProgramCannotRun, sWorkspace) + ":\n\n" + if(sWSFile<>"",sWSfile+"\n\n","") +sError)
8570>>>>
8570>>>            Abort
8571>>>>
8571>>>        End
8571>>>>
8571>>>    End_Procedure
8572>>>
8572>>>    Procedure OnCreate
8574>>>        // Event called when the Application object is ready to be used
8574>>>        // to open a Workspace, etc.
8574>>>    End_Procedure
8575>>>
8575>>>    Procedure End_Construct_Object
8577>>>        String sName
8577>>>        Forward Send End_Construct_Object
8579>>>        Send OnCreate
8580>>>        // note that psAutoOpenWorkspace will get cleared of OnCreate attempts to open a workspace
8580>>>        Get psAutoOpenWorkspace to sName
8581>>>        If (sName<>"") Begin
8583>>>            Send DoOpenWorkspace sName
8584>>>        end
8584>>>>
8584>>>    End_Procedure
8585>>>
8585>>>    Function GetApplicationFileName Returns String
8587>>>        // Returns the filename from Windows
8587>>>        Integer iNumChars
8587>>>        String sFilename
8587>>>
8587>>>        Move (Repeat(Character(0), 1024)) To sFileName
8588>>>        Move (GetModuleFileName(0, AddressOf(sFilename), 1024)) To iNumChars
8589>>>
8589>>>        Function_Return (CString(sFilename))
8590>>>    End_Function
8591>>>
8591>>>    Function GetApplicationPath Returns String
8593>>>        // Returns the path of the Application (no trailing "\")
8593>>>        String sApplicationFileName sPath
8593>>>        Boolean bRemoved
8593>>>
8593>>>        Get GetApplicationFileName  To sApplicationFileName
8594>>>        Move (PathRemoveFileSpec(AddressOf(sApplicationFileName))) To bRemoved
8595>>>        Move (CString(sApplicationFileName)) To sPath
8596>>>
8596>>>        If (Right(sPath, 1) ="\") Move (Left(sPath, Length(sPath) -1)) To sPath
8599>>>        Function_Return sPath
8600>>>    End_Function
8601>>>
8601>>>    Function GetApplicationName Returns String
8603>>>        // Returns the name of the Application (without its Path or Extension)
8603>>>        String sApplicationFileName sApplicationName
8603>>>        Boolean bRemoved
8603>>>        Integer iVoid
8603>>>
8603>>>        Get GetApplicationFileName To sApplicationFileName
8604>>>        Move (ExtractFileName(sApplicationFileName)) To sApplicationName
8605>>>        Move (PathRemoveExtension(AddressOf(sApplicationName))) To iVoid
8606>>>        Function_Return (CString(sApplicationName))
8607>>>    End_Function
8608>>>    
8608>>>    // this just directs to the desktop property. If you are using an application object you are
8608>>>    // encouraged to set this here.
8608>>>    Procedure Set pbUseWindowsFont Boolean bUseWindowsFont
8610>>>        Set pbUseWindowsFont of Desktop to bUseWindowsFont
8611>>>    End_Procedure
8612>>>    
8612>>>    Function pbUseWindowsFont Returns Boolean
8614>>>        Boolean bUseWindowsFont
8614>>>        Get pbUseWindowsFont of Desktop to bUseWindowsFont
8615>>>        Function_Return bUseWindowsFont
8616>>>    End_Function
8617>>>
8617>>>End_Class
8618>>>
8618>Use cWorkspace.pkg
8618>
8618>Object oHtmlHelp is a cHtmlHelp
8620>End_Object
8621>
8621>
8621>Object oApplication is a cApplication
8623>    Set pbPreserveEnvironment to False
8624>    Set peHelpType to htHtmlHelp
8625>End_Object
8626>
8626>Use for_each.pkg
Including file: for_each.pkg    (C:\data\VDF\ForEach\AppSrc\for_each.pkg)
8626>>>// Sort of Open Source. 
8626>>>// Written by Sean Bamforth - 
8626>>>// email - sean@theguru.co.uk 
8626>>>
8626>>>Use Datadict.pkg
Including file: Datadict.pkg    (C:\Program Files (x86)\Visual DataFlex 17.1\Pkg\Datadict.pkg)
8626>>>>>//************************************************************************
8626>>>>>// Confidential Trade Secret.
8626>>>>>// Copyright (c) 1997-2008 Data Access Corporation, Miami Florida
8626>>>>>// as an unpublished work.  All rights reserved.
8626>>>>>// DataFlex is a registered trademark of Data Access Corporation.
8626>>>>>//
8626>>>>>//************************************************************************
8626>>>>>
8626>>>>>Register_Procedure File_Field_Value_Changed
8626>>>>>Register_Procedure File_Field_Mask_Changed
8626>>>>>Register_Procedure File_Field_Label_Changed
8626>>>>>Register_Procedure File_Field_Option_Changed
8626>>>>>Register_Function  Extended_DEO_State returns Integer
8626>>>>>Register_Function  Entry_Refresh_State Returns integer
8626>>>>>//Register_Function  Item_NoPut integer iItem Returns integer
8626>>>>>Register_Procedure set Entry_Refresh_State integer iState
8626>>>>>Register_Function  Allow_Foreign_New_Save_State returns integer
8626>>>>>Register_Function  Server returns integer
8626>>>>>
8626>>>>>use VDFBase.pkg
8626>>>>>Use LanguageText.pkg // language support VDF pkg replacement strings
8626>>>>>
8626>>>>>Define Support$extended$fields
8626>>>>>
8626>>>>>Use Data_Set.pkg
Including file: Data_set.pkg    (C:\Program Files (x86)\Visual DataFlex 17.1\Pkg\Data_set.pkg)
8626>>>>>>>//************************************************************************
8626>>>>>>>//
8626>>>>>>>// Confidential Trade Secret.
8626>>>>>>>// Copyright 1987-1997 Data Access Corporation, Miami FL, USA
8626>>>>>>>// All Rights reserved
8626>>>>>>>// DataFlex is a registered trademark of Data Access Corporation.
8626>>>>>>>//
8626>>>>>>>//************************************************************************/
8626>>>>>>>
8626>>>>>>>//************************************************************************
8626>>>>>>>//     File Name: Data_Set.Pkg
8626>>>>>>>// Creation Date: January 1, 1991
8626>>>>>>>// Modified Date: April 21, 1992
8626>>>>>>>//     Author(s): Steven A. Lowe
8626>>>>>>>//
8626>>>>>>>// This module contains the Data_Set class definition.
8626>>>>>>>//************************************************************************/
8626>>>>>>>// 4/21/99   JJT Added OnConstrain support
8626>>>>>>>// 11/26/97  JJT Moved data_set_should_save into class from dfclient.pkg
8626>>>>>>>// 04/11/97  JJT Added Refind_DD_Records which is just like Refind_records
8626>>>>>>>//              except it only operates on in_use DDs. Otherwise, non
8626>>>>>>>//              connected not-in-use DDs clear the buffer (very bad for
8626>>>>>>>//              sysfiles).
8626>>>>>>>// 11/05/96 JJT Added Set DDO_Server Message (same as Attach_Server)
8626>>>>>>>// 08/29/96 JJT Item_Find Fix, where send attach_main_File sent to server
8626>>>>>>>// 07/23/96 JJT Renamed to DataSet (Maintain Data_Set as well)
8626>>>>>>>//************************************************************************/
8626>>>>>>>// 2/26/2002  JJT - 8.2 clean up (indirect_file, local, self, etc.)
8626>>>>>>>
8626>>>>>>>
8626>>>>>>>use VDFBase.pkg
8626>>>>>>>use fndmodes.pkg
Including file: fndmodes.pkg    (C:\Program Files (x86)\Visual DataFlex 17.1\Pkg\fndmodes.pkg)
8626>>>>>>>>>//
8626>>>>>>>>>// special find modes
8626>>>>>>>>>//
8626>>>>>>>>>define NEXT_RECORD  for 5 //* find-next   *//
8626>>>>>>>>>define FIRST_RECORD for 6 //* find-first  *//
8626>>>>>>>>>define LAST_RECORD  for 7 //* find-last   *//
8626>>>>>>>use refmodes.pkg
Including file: refmodes.pkg    (C:\Program Files (x86)\Visual DataFlex 17.1\Pkg\refmodes.pkg)
8626>>>>>>>>>//
8626>>>>>>>>>// constants for REFRESH message parameter values
8626>>>>>>>>>//
8626>>>>>>>>>define MODE_CLEAR             for 1  //notification from origin of clear
8626>>>>>>>>>define MODE_FIND_OR_CLEAR_SET for 2  //notification from find or clear
8626>>>>>>>>>define MODE_CLEAR_ALL         for 3  //notification from clear-all
8626>>>>>>>>>define MODE_DELETE            for 4  //notification after successful delete
8626>>>>>>>>>define MODE_SAVE              for 5  //notification after successful save
8626>>>>>>>>>
8626>>>>>>>//use enclient.pkg
8626>>>>>>>
8626>>>>>>>
8626>>>>>>>// removed in 14.1 (These were never used)
8626>>>>>>>// Define defaults (If not previously defined)
8626>>>>>>>//define DEFAULT$SMART$FILEMODE$STATE for FALSE
8626>>>>>>>//define DEFAULT$CASCADE$DELETE$STATE for TRUE
8626>>>>>>>
8626>>>>>>>//
8626>>>>>>>//Global integer status values
8626>>>>>>>//
8626>>>>>>>define OPERATION_MODE   for |VI99  //status of data-sets in application
8626>>>>>>>define OPERATION_ORIGIN for |VI108 //origin of current of data-set operation
8626>>>>>>>
8626>>>>>>>//
8626>>>>>>>//Constants for Operation_Mode global int values
8626>>>>>>>//
8626>>>>>>>define MODE_WAITING  for 0  //wait-mode
8626>>>>>>>define MODE_FINDING  for 1  //find-mode
8626>>>>>>>define MODE_CLEARING for 2  //clear-mode
8626>>>>>>>define MODE_CREATING for 3  //create-mode
8626>>>>>>>define MODE_SAVING   for 4  //save-mode
8626>>>>>>>define MODE_DELETING for 5  //delete-mode
8626>>>>>>>define MODE_ABORTING for 6  //abort-mode
8626>>>>>>>define MODE_VALIDATING for 7  //request_validate-mode : added for VDF7
8626>>>>>>>define MODE_CLEARINGALL for 8 //clear-all mode (added in VDF8)
8626>>>>>>>
8626>>>>>>>//
8626>>>>>>>// Description
8626>>>>>>>//
8626>>>>>>>//   The Data_Set class is implemented as a subclass of Entry_Client, with
8626>>>>>>>//   a C language handler providing the majority of new behavior.  The
8626>>>>>>>//   Data_Set class is intended to be a grouping agent for data-entry objects
8626>>>>>>>//   and a container for subordinate Data_Sets.
8626>>>>>>>//
8626>>>>>>>// Assumptions/Preconditions
8626>>>>>>>//
8626>>>>>>>//   None.
8626>>>>>>>//
8626>>>>>>>// Exceptions
8626>>>>>>>//
8626>>>>>>>//   None.
8626>>>>>>>//
8626>>>>>>>// Notes
8626>>>>>>>//
8626>>>>>>>//  Syntax:
8626>>>>>>>//
8626>>>>>>>//  Object <name> is a DataSet <image> {ACTION_BAR <ActionBar>} {POP_UP}
8626>>>>>>>//      {RING} {MAIN_FILE <Main_File> {BY <Index>} }
8626>>>>>>>//      {UPDATING <File> | <DataSetID> ... } }
8626>>>>>>>//   :
8626>>>>>>>//  End_Object
8626>>>>>>>//
8626>>>>>>>//  Data_Sets may be used to group DEOs as well as other Data_Sets.
8626>>>>>>>//  Note also that a nested (component) Data_Set automatically enforces an
8626>>>>>>>//  UPDATES visibility and a RELATES TO constraint between its main_file and
8626>>>>>>>//  its parent's main_file.
8626>>>>>>>//
8626>>>>>>>
8626>>>>>>>// _Data_Set class deinition, private class layer. (Extra class layer needed
8626>>>>>>>// to augment procedures defined in C class handler.)
8626>>>>>>>//
8626>>>>>>>// _Data_Set class deinition, private class layer. (Extra class layer needed
8626>>>>>>>// to augment procedures defined in C class handler.)
8626>>>>>>>//
8626>>>>>>>//Class _Data_Set is an Entry_Client ;  //_Data_Set inherits from Entry_Client
8626>>>>>>>//    STARTMAC dsStart ;                //dsStart macro is used to handle syntax
8626>>>>>>>//    0 0 ;                             //default colors
8626>>>>>>>//    Data_Set_Handler                  //C-function for base class behavior
8626>>>>>>>
8626>>>>>>>//  !A [] $461 U__DATA_SET              //register C messages
8626>>>>>>>
8626>>>>>>>//#IFDEF IS$WINDOWS
8626>>>>>>>Use BaseData_Set.pkg
8626>>>>>>>
8626>>>>>>>// Data_Set class definition, public class layer. (Extra class layer needed
8626>>>>>>>// to augment C-based (Constrain) procedure(s).)
8626>>>>>>>
8626>>>>>>>Class DataSet is a BaseData_Set
8627>>>>>>>
8627>>>>>>>
8627>>>>>>>   // maintain old name for the time being to maximize compatability
8627>>>>>>>   // between character mode and windows versions. Developers should be
8627>>>>>>>   // able to move DS classes back and forth without changes.
8627>>>>>>>   Replace_Class_Name Data_Set DataSet
8627>>>>>>>
8627>>>>>>>   Procedure Construct_Object //Integer Img#
8629>>>>>>>     Forward Send Construct_Object No_Image //Img#
8631>>>>>>>
8631>>>>>>>     Property Integer Constrain_File 0
8632>>>>>>>     Property Integer Auto_Fill_State False
8633>>>>>>>     Property Integer Change_Disabled_State  False
8634>>>>>>>     // RT sets this inside of Mark_components a part of old entry_client DSO behavior. Now it is never used
8634>>>>>>>     Property Integer Component_State False
8635>>>>>>>
8635>>>>>>>     // just use RT default of False & True
8635>>>>>>>     //Set Smart_Filemode_State to DEFAULT$SMART$FILEMODE$STATE
8635>>>>>>>     //Set Cascade_Delete_State to DEFAULT$CASCADE$DELETE$STATE
8635>>>>>>>     // Set Focus_Mode to NO_ACTIVATE
8635>>>>>>>   End_Procedure  // Construct_Object
8636>>>>>>>
8636>>>>>>>
8636>>>>>>>  //
8636>>>>>>>  // This may be called by legacy DSO and DDO code
8636>>>>>>>  //
8636>>>>>>>  // IMPORTANT NOTE of change for 8.2:
8636>>>>>>>  //         DO NOT call or augment this anymore.
8636>>>>>>>  //
8636>>>>>>>  //         for sending: Find all cases of Field_main_index and change it to File_Field_Index
8636>>>>>>>  //
8636>>>>>>>  //         for augmenting: In DSOs - replace Field_main_index with File_field_index
8636>>>>>>>  //                         In DDOs - replace Field_main_Index with Field_Index and do not pass
8636>>>>>>>  //                                   the file parameter.
8636>>>>>>>  //                                   See DDOs Field_index and File_field_Index for more
8636>>>>>>>  //
8636>>>>>>>  function Field_Main_Index integer file integer field returns integer
8638>>>>>>>    integer dataType fldNdx retval ordr
8638>>>>>>>    move -1 to retval      //field has no main index (default)
8639>>>>>>>    if file ne 0 begin
8641>>>>>>>//      FIELD_DEF file field to dataType fldNdx
8641>>>>>>>      get_attribute DF_FIELD_INDEX of file field to fldNdx // main index field
8644>>>>>>>      if (fldNdx > 0 OR field = 0) move fldNdx to retval //field has main index
8647>>>>>>>    end
8647>>>>>>>>
8647>>>>>>>    if file eq (main_file(self)) begin
8649>>>>>>>      get ordering to ordr
8650>>>>>>>      if ordr ge 0 move ordr to retval  //ordering takes precedence over main index
8653>>>>>>>    end
8653>>>>>>>>
8653>>>>>>>    function_return retval
8654>>>>>>>  end_function
8655>>>>>>>
8655>>>>>>>    // This allows packages that still use data-sets instead of DDOs to use this
8655>>>>>>>    // message syntax.
8655>>>>>>>    // Note that this will never get here if the DD class is used as
8655>>>>>>>    // it has its own handler for this. It only is called if DSOs are used in which
8655>>>>>>>    // case it calls the old message field_main_index above.
8655>>>>>>>    // DDO based objects will NEVER call this code
8655>>>>>>>    //
8655>>>>>>>    function File_Field_Index integer iFile integer iField returns integer
8657>>>>>>>        function_return (Field_main_Index(self,iFile,iField))
8658>>>>>>>    end_function
8659>>>>>>>
8659>>>>>>>
8659>>>>>>>  procedure Item_Find integer eFindMode ;                      integer iFile integer iField ;                      integer bDoEntryUpdate integer bShowFindErr integer bDeferred
8661>>>>>>>
8661>>>>>>>    RowId   riRow
8661>>>>>>>    integer iIndex
8661>>>>>>>    Handle  hoServer
8661>>>>>>>    integer iSegments iSeg iSegFld iSegFldMainIndex
8661>>>>>>>    boolean bChanged bDoCheck bOk
8661>>>>>>>
8661>>>>>>>    //Get Field_Main_Index iFile iField to iIndex
8661>>>>>>>    Get File_Field_Index iFile iField to iIndex
8662>>>>>>>    If (iIndex<>-1) Begin
8664>>>>>>>      // get prior rowId before it get cleared
8664>>>>>>>      Move (GetRowID(iFile)) to riRow
8665>>>>>>>      //  'hold' buffer to prepare for entry_update
8665>>>>>>>      Set_Attribute DF_FILE_STATUS of iFile to DF_FILE_INACTIVE
8668>>>>>>>      if bDoEntryUpdate Begin
8670>>>>>>>        send Request_Entry_Update iFile 1  //entUpdt all DEOs as required
8671>>>>>>>
8671>>>>>>>        // If the buffer is cleared (no record and no changed data) then we want
8671>>>>>>>        // to do a constrained_clear which will force the buffer to get cleared
8671>>>>>>>        // according to the rules of the current constraints.
8671>>>>>>>        //Get_field_value iFile 0 to iRec
8671>>>>>>>        //Move (GetRowID(iFile)) to riRow // 12.1 moved above the set file inactive
8671>>>>>>>
8671>>>>>>>        // If there was an active record to begin with we consider this changed (not cleared)
8671>>>>>>>        If (not(IsNullRowId(riRow))) Begin
8673>>>>>>>            Move True to bChanged
8674>>>>>>>        End
8674>>>>>>>>
8674>>>>>>>        Else Begin
8675>>>>>>>            // or, if the record was already changed or the entry_update created a change
8675>>>>>>>            // we consider this changed
8675>>>>>>>            Get_Attribute DF_FILE_CHANGED of iFile to bChanged
8678>>>>>>>        End
8678>>>>>>>>
8678>>>>>>>
8678>>>>>>>        If not bChanged Begin
8680>>>>>>>            // if buffer is unchanged, do a constrained clear. It is unchanged if there was not
8680>>>>>>>            // active record, the record was unchanged, and the update didn't change anything.
8680>>>>>>>            Constrained_Clear eFindMode iFile by iIndex
8683>>>>>>>        End
8683>>>>>>>>
8683>>>>>>>        Else If (eFindMode=GE or eFindMode=LE and iIndex>0) Begin
8686>>>>>>>
8686>>>>>>>             // If mode is GE or LE we need to do some extra processing. We want to clear
8686>>>>>>>             // all index segemnt fields that occur after this field in the index. This way
8686>>>>>>>             // dbList searches and find ge searches (f9) will always find the first record
8686>>>>>>>             // that matches the data in the field being searched. This was if an index like
8686>>>>>>>             // customer.name x customer.number where you had 10 identical names "john" typing
8686>>>>>>>             // john will find the first record, because customer.number will get cleared.
8686>>>>>>>             // Note we can no do this with GT or LT or you'd get stuck in fields
8686>>>>>>>
8686>>>>>>>             // check all fields for index. Once you find the iField field, clear all
8686>>>>>>>             // fields that follow it. Only do this if the other fields do not use the
8686>>>>>>>             // same index as its primary index (in which case we assume the data is intentional).
8686>>>>>>>             // This should handle most cases.
8686>>>>>>>             get_attribute DF_INDEX_NUMBER_SEGMENTS of iFile iIndex to iSegments
8689>>>>>>>             for iSeg from 1 to iSegments
8695>>>>>>>>
8695>>>>>>>                 get_Attribute DF_INDEX_SEGMENT_FIELD of iFile iIndex iSeg to iSegFld
8698>>>>>>>                 If not bDoCheck begin
8700>>>>>>>                     If (iSegFld=iField) ;                         Move True to bDoCheck // marked after we find the find field in the index
8703>>>>>>>                 end
8703>>>>>>>>
8703>>>>>>>                 else Begin // we get here after we've found the main field segment
8704>>>>>>>                    // if main index if this segment is same as our find index, do nothing
8704>>>>>>>                    Get File_Field_Index iFile iSegFld to iSegFldMainIndex
8705>>>>>>>                    If (iSegFldMainIndex<>iIndex) ;                        set_field_value iFile iSegFld to ''
8710>>>>>>>                end
8710>>>>>>>>
8710>>>>>>>             loop
8711>>>>>>>>
8711>>>>>>>        end
8711>>>>>>>>
8711>>>>>>>
8711>>>>>>>        Get Which_Data_Set iFile to hoServer
8712>>>>>>>        if (hoServer AND iFile=main_file(hoServer)) ;             send Attach_Main_File to hoServer
8715>>>>>>>        else ;             attach iFile
8717>>>>>>>      end
8717>>>>>>>>
8717>>>>>>>
8717>>>>>>>      indicate err false
8718>>>>>>>
8718>>>>>>>      if (Is_SuperFind_Required(self,iFile)) ;          send Request_SuperFind eFindMode iFile iField
8721>>>>>>>      else if bDeferred ;          send Request_Read eFindMode iFile iIndex
8725>>>>>>>      else ;          send Request_Find eFindMode iFile iIndex
8727>>>>>>>
8727>>>>>>>      If (not(found) and not(err)) begin
8729>>>>>>>          // refind original record (or leave it cleared if not record)
8729>>>>>>>          Move (FindByRowId(iFile,riRow)) to bOk
8730>>>>>>>
8730>>>>>>>          if bShowFindErr ;              error (if(eFindMode<2, DFERR_FIND_PRIOR_BEG_OF_FILE, DFERR_FIND_PAST_END_OF_FILE))
8733>>>>>>>          indicate FOUND FALSE
8734>>>>>>>      end
8734>>>>>>>>
8734>>>>>>>    end
8734>>>>>>>>
8734>>>>>>>    else ;        if bShowFindErr error DFERR_FIELD_NOT_INDEXED
8738>>>>>>>  end_procedure
8739>>>>>>>
8739>>>>>>>
8739>>>>>>>  // We only care about should_saves of DEOs and not DSOs when
8739>>>>>>>  // exiting the app. Create a handler for data set class. We still
8739>>>>>>>  // broadcast in case we've got nested deos in the dso (hopefully not).
8739>>>>>>>  //
8739>>>>>>>  Function Exit_Application_Check Returns Integer
8741>>>>>>>    Integer rVal
8741>>>>>>>    BroadCast Get Exit_Application_Check to Rval // check w/ kids
8743>>>>>>>    Function_return rVal
8744>>>>>>>  End_Function
8745>>>>>>>
8745>>>>>>>   Procedure Constrain
8747>>>>>>>     Integer iFile
8747>>>>>>>     Send OnConstrain
8748>>>>>>>     Forward Send Constrain
8750>>>>>>>     Get Constrain_File to iFile
8751>>>>>>>     If iFile ;        Constrain (Main_file(self)) relates to iFile
8754>>>>>>>   End_procedure
8755>>>>>>>
8755>>>>>>>   Procedure OnConstrain
8757>>>>>>>   End_Procedure
8758>>>>>>>
8758>>>>>>>   // Less confusing Message for adding Updating servers
8758>>>>>>>   //
8758>>>>>>>   Procedure Set DDO_Server Handle ObjId
8760>>>>>>>      Send Attach_Server ObjId
8761>>>>>>>   End_Procedure // Set DDO_Server
8762>>>>>>>
8762>>>>>>>   // This is called when a view takes or retakes the
8762>>>>>>>   // focus. If DD not in use, do nothing.
8762>>>>>>>   //
8762>>>>>>>   Procedure Refind_DD_Records
8764>>>>>>>        if (in_use_state(self)) Send refind_records
8767>>>>>>>   end_procedure
8768>>>>>>>
8768>>>>>>>   // this returns true if the data-set is changed AND there are attached
8768>>>>>>>   // DEO objects. Without this you can get "changes exist" condition reported
8768>>>>>>>   // that the user will have no way of saving.
8768>>>>>>>   //
8768>>>>>>>   Function Data_Set_Should_Save returns integer
8770>>>>>>>        Function_Return (Should_Save(self) AND ;                           Data_Set_User_interface_count(self))
8771>>>>>>>   End_Function
8772>>>>>>>
8772>>>>>>>   // returns 0 indicating that this is not DD enabled. DataDictionary objects will return 1.
8772>>>>>>>   // Add DSOs and DDOs must understand this message
8772>>>>>>>
8772>>>>>>>   Function Extended_DSO_State Returns Integer
8774>>>>>>>       Function_return 0
8775>>>>>>>   End_Function // Extended_DSO_State
8776>>>>>>>
8776>>>>>>>
8776>>>>>>>end_class
8777>>>>>>>
8777>>>>>>>//#COMMAND bind_main_file // this should not be used anymore
8777>>>>>>>//  #IF (!0>1)
8777>>>>>>>//    #IFSAME !1 MAIN_FILE
8777>>>>>>>//      #IFDEF !2.RECNUM
8777>>>>>>>//        #PUSH !u
8777>>>>>>>//        #SET U$ !2.RECNUM
8777>>>>>>>//        set main_file to |CI!u
8777>>>>>>>//        #POP u$
8777>>>>>>>//      #ELSE
8777>>>>>>>//        #ERROR DFERR_COMPILE If !2 is a file it is unopened
8777>>>>>>>//      #ENDIF
8777>>>>>>>//    #ELSE
8777>>>>>>>//      bind_main_file !2 !3 !4 !5 !6 !7 !8 !9
8777>>>>>>>//    #ENDIF
8777>>>>>>>//  #ENDIF
8777>>>>>>>//#ENDCOMMAND
8777>>>>>>>
8777>>>>>>>//#COMMAND bind_index
8777>>>>>>>//  #IF (!0>1)
8777>>>>>>>//    #IFSAME !1 BY
8777>>>>>>>//      set ordering to !2
8777>>>>>>>//    #ELSE
8777>>>>>>>//      bind_index !2 !3 !4 !5 !6 !7 !8 !9
8777>>>>>>>//    #ENDIF
8777>>>>>>>//  #ENDIF
8777>>>>>>>//#ENDCOMMAND
8777>>>>>>>
8777>>>>>>>//#COMMAND Bind_Updating
8777>>>>>>>//  #IF (!0>1)
8777>>>>>>>//    #IFSAME !1 UPDATING
8777>>>>>>>//      SetDependents !2 !3 !4 !5 !6 !7 !8 !9
8777>>>>>>>//    #ELSE
8777>>>>>>>//      Bind_Updating !2 !3 !4 !5 !6 !7 !8 !9
8777>>>>>>>//    #ENDIF
8777>>>>>>>//  #ENDIF
8777>>>>>>>//#ENDCOMMAND
8777>>>>>>>
8777>>>>>>>//#COMMAND SetDependents   //<File>|<Server#> [ ... ] ...obsolete
8777>>>>>>>//  #IF (!0>0)
8777>>>>>>>//    #IFDEF !1
8777>>>>>>>//      send Attach_Server !1
8777>>>>>>>//    #ELSE
8777>>>>>>>//      #IFDEF !1.OBJ
8777>>>>>>>//        send attach_Server !1.OBJ
8777>>>>>>>//      #ELSE
8777>>>>>>>//        #IFDEF !1.RECNUM
8777>>>>>>>//          #PUSH !u
8777>>>>>>>//          #SET U$ !1.RECNUM
8777>>>>>>>//          send Add_Parent_File |CI!u
8777>>>>>>>//          #POP U$
8777>>>>>>>//        #ELSE
8777>>>>>>>//          #ERROR DFERR_COMPILE If !1 is a file it is unopened
8777>>>>>>>//        #ENDIF
8777>>>>>>>//      #ENDIF
8777>>>>>>>//    #ENDIF
8777>>>>>>>//    SetDependents !2 !3 !4 !5 !6 !7 !8 !9
8777>>>>>>>//  #ENDIF
8777>>>>>>>//#ENDCOMMAND
8777>>>>>>>
8777>>>>>>>
8777>>>>>Use DDValtbl.pkg  // validation table classes
Including file: Ddvaltbl.pkg    (C:\Program Files (x86)\Visual DataFlex 17.1\Pkg\Ddvaltbl.pkg)
8777>>>>>>>//****************************************************************************//
8777>>>>>>>//                                                                            //
8777>>>>>>>// $File name  : ddvaltbl.pkg                                                 //
8777>>>>>>>// $File title :                                                              //
8777>>>>>>>// Notice      :                                                              //
8777>>>>>>>// $System     : Extended Data Sets 3.1                                       //
8777>>>>>>>// Created     : 03/28/96 04:48 pm                                            //
8777>>>>>>>// $Last Rev   : 03/28/96 04:48 pm41                                          //
8777>>>>>>>//                                                                            //
8777>>>>>>>// $Description                                                               //
8777>>>>>>>//                                                                            //
8777>>>>>>>//                                                                            //
8777>>>>>>>// $Rev History                                                               //
8777>>>>>>>//JT 02/04/97 Changed Validate_value in FileValidationTable to no use the code//
8777>>>>>>>//            DSO if operation mode is busy. In DDOs validtion sets operation_//
8777>>>>>>>//            mode to busy.                                                   //
8777>>>>>>>//JT 12/23/96 Made sure field values are always trimmed!                      //
8777>>>>>>>//JT 07/23/96 New Class names                                                 //
8777>>>>>>>//JT 06/12/96 Modified "indirect-file" finding methods and replaced them with //
8777>>>>>>>//            3.1 API commands                                                //
8777>>>>>>>//JT 05/28/96 Add Public Message Find_Code_Description. Passes Code and       //
8777>>>>>>>//            returns the description. Created properties current_description //
8777>>>>>>>//            current_code and current_Record to speed up this process        //
8777>>>>>>>//JT 02-04-96 Changed Validation_xxx_table to xxx_Validation_Table            //
8777>>>>>>>//JT 28-03-96 File header created                                             //
8777>>>>>>>//                                                                            //
8777>>>>>>>//****************************************************************************//
8777>>>>>>>
8777>>>>>>>
8777>>>>>>>//****************************************************************************//
8777>>>>>>>//  Validation Table Support for Extended Data-Sets. Fields may               //
8777>>>>>>>//  attached to validation tables which can then be used for                  //
8777>>>>>>>//  validation (if Validate_state is true) or list loading.                   //
8777>>>>>>>//  Developers can create their own validation tables as long as they         //
8777>>>>>>>//  conform to the following external interface:                              //
8777>>>>>>>//                                                                            //
8777>>>>>>>// Properties                                                                 //
8777>>>>>>>//   Static_State       - if list must be rebuilt each validation, load       //
8777>>>>>>>//   Allow_Blank_state  - If Blank or 0 is a valid response                   //
8777>>>>>>>//   Validate_State     - should table be used for validation                 //
8777>>>>>>>//   Table_Loaded_State - is the validation table initialized?                //
8777>>>>>>>//                                                                            //
8777>>>>>>>// Methods                                                                    //
8777>>>>>>>//  Get Validate_Value sValue to iVal - if iVal=0, it is legal                //
8777>>>>>>>//  Send Fill_list                    - fills a static list                   //
8777>>>>>>>//  Send Request_Fill_From_List iObject iMessage                              //
8777>>>>>>>//        This is a callback that will fill an external list by sending       //
8777>>>>>>>//        the passed message (iMessage) back to the requesting object         //
8777>>>>>>>//        (iObject). It will send this message for each item in the           //
8777>>>>>>>//        validation table. It always passes back four params. Those are:     //
8777>>>>>>>//                     iItem - Item count being passed back                   //
8777>>>>>>>//                     sData - The Database value of the item                 //
8777>>>>>>>//                     sDesc - The Value's description, "" if none            //
8777>>>>>>>//                     iFile - File number associated with the item (if any)  //
8777>>>>>>>//                     iRec  - Record associated with the item (if any)       //
8777>>>>>>>// Developers can create classes of any complexity to support validation      //
8777>>>>>>>// tables. We have provided the following four classes.                       //
8777>>>>>>>//                                                                            //
8777>>>>>>>//  ValidationTable is an Array                                               //
8777>>>>>>>//           Provides simple one dimensional table support. The table must be //
8777>>>>>>>//           loaded manually by creating fill_list and sending the message    //
8777>>>>>>>//           Add_Table_Value (send Add_Table_Value Value). If list is static      //
8777>>>>>>>//           it is filled once. If non-static it is filled each time it is    //
8777>>>>>>>//           requested to validate or fill a foreign lis.                     //
8777>>>>>>>//                                                                            //
8777>>>>>>>//  DescriptionValidationTable is a ValidationTable                           //
8777>>>>>>>//           Provides a more complex three dimension array allowing the       //
8777>>>>>>>//           object to store a data value, description value and a record     //
8777>>>>>>>//           number. The developer must fill this list using the Add_table_   //
8777>>>>>>>//           value message passing up to three values (data, desc, record).   //
8777>>>>>>>//                                                                            //
8777>>>>>>>//  FileValidationTable is a DescriptionValidationTable                       //
8777>>>>>>>//           Provides a data aware table. This can be used to load data from  //
8777>>>>>>>//           data-files, from data-sets. If you use data-sets you can place   //
8777>>>>>>>//           constraints within the data-set. You must define the file-number,//
8777>>>>>>>//           data-set (if any), the file index, the file's data field, and    //
8777>>>>>>>//           the file's description field. You can also define an optional    //
8777>>>>>>>//           "Type". All records are constrained to this type (with or with-  //
8777>>>>>>>//           data-sets). If is assumed that this file has an optimized finding//
8777>>>>>>>//           index.                                                           //
8777>>>>>>>//                                                                            //
8777>>>>>>>//  CodeValidationTable is a FileValidationTable                              //
8777>>>>>>>//           Used for Code lists. Simply set Type_Value to the "type"         //
8777>>>>>>>//                                                                            //
8777>>>>>>>//                                                                            //
8777>>>>>>>//****************************************************************************//
8777>>>>>>>use VDFBase.pkg
8777>>>>>>>
8777>>>>>>>
8777>>>>>>>Class ValidationTable is an Array
8778>>>>>>>
8778>>>>>>>   Procedure Construct_Object
8780>>>>>>>      Forward Send Construct_Object
8782>>>>>>>      Property Integer Static_State        True
8783>>>>>>>
8783>>>>>>>      Property Integer Table_Loaded_State  False
8784>>>>>>>
8784>>>>>>>      Property Integer Validate_State      True
8785>>>>>>>      Property Integer Allow_Blank_State   False
8786>>>>>>>      Property Integer Main_File           0
8787>>>>>>>      Property String  Table_Title         DD_VALIDATION_LIST_TITLE
8788>>>>>>>
8788>>>>>>>      Property Integer Number_Elements     1
8789>>>>>>>
8789>>>>>>>      // System maintained. Sub-classes use these
8789>>>>>>>      // These are SET by Next_Code_Record. You may GET their values
8789>>>>>>>
8789>>>>>>>      Property String  Current_Code            ''
8790>>>>>>>
8790>>>>>>>      Property String  Current_Description     ''
8791>>>>>>>
8791>>>>>>>      Property RowId Current_RowId
8792>>>>>>>   End_Procedure // Construct_Object
8793>>>>>>>
8793>>>>>>>   Function Data_Item_Count returns integer
8795>>>>>>>     Function_return (Item_Count(Self))
8796>>>>>>>   End_Function
8797>>>>>>>
8797>>>>>>>   Function Data_Value Integer iItem returns string
8799>>>>>>>      Function_return (Value(Self,iItem))
8800>>>>>>>   End_function
8801>>>>>>>
8801>>>>>>>   Procedure Set Data_Value Integer iItem String sValue
8803>>>>>>>      Set Value Item iItem to sValue
8804>>>>>>>   End_Procedure
8805>>>>>>>
8805>>>>>>>   Function Data_Description Integer iItem returns string
8807>>>>>>>      Function_Return ''
8808>>>>>>>   End_function
8809>>>>>>>
8809>>>>>>>   Procedure Set Data_Description Integer iItem String sValue
8811>>>>>>>   End_function
8812>>>>>>>
8812>>>>>>>   Function Data_RowId Integer iItem returns RowId
8814>>>>>>>       Function_return (NullRowId())
8815>>>>>>>   End_function
8816>>>>>>>
8816>>>>>>>   Procedure Set Data_RowId Integer iItem RowId riValue
8818>>>>>>>   End_function
8819>>>>>>>
8819>>>>>>>
8819>>>>>>>   Procedure Add_Table_Value String sValue
8821>>>>>>>     Set Data_Value Item (Data_Item_Count(self)) to sValue
8822>>>>>>>   End_Procedure
8823>>>>>>>
8823>>>>>>>   Function Validate_Value String sCode Returns Integer
8825>>>>>>>      Integer iMax
8825>>>>>>>      Integer iCnt
8825>>>>>>>      If sCode eq '';         Function_Return (not(Allow_Blank_State(Self)))
8828>>>>>>>      If (Table_Loaded_State(Self)=0 or Static_State(Self)=0) Begin
8830>>>>>>>         Send Delete_Data
8831>>>>>>>         Send Fill_list
8832>>>>>>>         Set Table_Loaded_State to TRUE
8833>>>>>>>      End
8833>>>>>>>>
8833>>>>>>>      Get Data_Item_Count to iMax
8834>>>>>>>      Decrement iMax
8835>>>>>>>      For iCnt from 0 to iMax
8841>>>>>>>>
8841>>>>>>>          If (sCode=Data_Value(Self,iCnt)) Begin
8843>>>>>>>             Set Current_Code        to sCode
8844>>>>>>>             Set Current_Description to (Data_Description(Self,iCnt))
8845>>>>>>>             Set Current_RowId       to (Data_RowId(Self,iCnt))
8846>>>>>>>             Function_return 0
8847>>>>>>>          End
8847>>>>>>>>
8847>>>>>>>      Loop
8848>>>>>>>>
8848>>>>>>>      Function_Return 1 // 0=OK
8849>>>>>>>   End_Function
8850>>>>>>>
8850>>>>>>>   Function Find_Code_Description String sCode Returns String
8852>>>>>>>      If (sCode='' OR ;           (sCode<>Current_Code(Self) AND ;            Validate_Value(Self,sCode) ) );                Function_Return ''
8855>>>>>>>      Function_Return (Current_Description(Self))
8856>>>>>>>   End_Function
8857>>>>>>>
8857>>>>>>>
8857>>>>>>>   //  The deveveloper (or a sub-class) must fill this list. It is done
8857>>>>>>>   //  by finding the item and sending the Message:
8857>>>>>>>   //    Send Add_Table_Value sValue {sDescr}
8857>>>>>>>   //
8857>>>>>>>   Procedure Fill_List
8859>>>>>>>      Set Table_Loaded_State to TRUE
8860>>>>>>>   End_Procedure
8861>>>>>>>
8861>>>>>>>   Procedure Request_Fill_From_List integer iObj integer iMsg
8863>>>>>>>      Integer iMax
8863>>>>>>>      Integer iCnt
8863>>>>>>>      Integer iFile
8863>>>>>>>
8863>>>>>>>      If (iObj=0 or iMsg=0) Procedure_return
8866>>>>>>>
8866>>>>>>>      If (Table_Loaded_State(Self)=0 OR Static_State(Self)=0) Begin
8868>>>>>>>         Send Delete_Data
8869>>>>>>>         Send Fill_list
8870>>>>>>>         Set Table_Loaded_State to TRUE
8871>>>>>>>      End
8871>>>>>>>>
8871>>>>>>>      Get Main_File to iFile
8872>>>>>>>      Get Data_Item_Count to iMax
8873>>>>>>>      Decrement iMax
8874>>>>>>>      For iCnt from 0 to iMax
8880>>>>>>>>
8880>>>>>>>          Send iMsg to iObj iCnt (Data_Value(Self,iCnt)) ;                                 (Data_Description(Self,iCnt)) iFile ;                                 (Data_RowId(Self,iCnt))
8881>>>>>>>      Loop
8882>>>>>>>>
8882>>>>>>>   End_Procedure
8883>>>>>>>
8883>>>>>>>
8883>>>>>>>    // returns all data in a two dimension variant array.
8883>>>>>>>    // [i][0] = data
8883>>>>>>>    // [i][1] = description
8883>>>>>>>    // This can be used by Crystal CDO classes (this is why a variant array is used)
8883>>>>>>>    Function TableData returns variant[][]
8885>>>>>>>        Variant[][2] vData
8886>>>>>>>        Integer iMax i
8886>>>>>>>        If (Table_Loaded_State(Self)=0 OR Static_State(Self)=0) Begin
8888>>>>>>>            Send Delete_Data
8889>>>>>>>            Send Fill_list
8890>>>>>>>            Set Table_Loaded_State to TRUE
8891>>>>>>>        End
8891>>>>>>>>
8891>>>>>>>        Get Data_Item_Count to iMax
8892>>>>>>>        For i from 0 to (iMax-1)
8898>>>>>>>>
8898>>>>>>>            Get Data_Value       i to vData[i][0]
8899>>>>>>>            Get Data_Description i to vData[i][1]
8900>>>>>>>        Loop
8901>>>>>>>>
8901>>>>>>>        function_Return vData
8902>>>>>>>    End_Function
8903>>>>>>>
8903>>>>>>>End_Class
8904>>>>>>>
8904>>>>>>>
8904>>>>>>>
8904>>>>>>>Class DescriptionValidationTable is an ValidationTable
8905>>>>>>>
8905>>>>>>>    Procedure Construct_Object
8907>>>>>>>       Forward Send Construct_Object
8909>>>>>>>       Set Number_Elements to 2
8910>>>>>>>    End_Procedure // Construct_Object
8911>>>>>>>
8911>>>>>>>    Function Data_Item_Count returns integer
8913>>>>>>>       function_return (item_count(Self)/3)
8914>>>>>>>    End_Function // Data_item_Count
8915>>>>>>>
8915>>>>>>>    Function Data_Value Integer iItem returns string
8917>>>>>>>       Function_return (Value(Self,iItem*3))
8918>>>>>>>    End_function
8919>>>>>>>
8919>>>>>>>    Procedure Set Data_Value Integer iItem String sValue
8921>>>>>>>       Set Value Item (iItem*3) to sValue
8922>>>>>>>    End_Procedure
8923>>>>>>>
8923>>>>>>>    Function Data_Description Integer iItem returns string
8925>>>>>>>       Function_return (Value(Self,iItem*3+1))
8926>>>>>>>    End_function
8927>>>>>>>
8927>>>>>>>    Procedure Set Data_Description Integer iItem String sValue
8929>>>>>>>       Set Value Item (iItem*3+1) to sValue
8930>>>>>>>    End_function
8931>>>>>>>
8931>>>>>>>    Function Data_RowId Integer iItem returns RowId
8933>>>>>>>       String sRowId
8933>>>>>>>       Get Value (iItem*3+2) to sRowId
8934>>>>>>>       Function_return (DeSerializeRowId(sRowId))
8935>>>>>>>    End_function
8936>>>>>>>
8936>>>>>>>    Procedure Set Data_RowId Integer iItem RowId riValue
8938>>>>>>>       Set Value Item (iItem*3+2) to (SerializeRowId(riValue))
8939>>>>>>>    End_function
8940>>>>>>>
8940>>>>>>>    Procedure Add_Table_Value String sData String sDescr RowId riRec
8942>>>>>>>      String  sVal
8942>>>>>>>      RowId   riRecVal
8942>>>>>>>      Integer iCnt
8942>>>>>>>      Get Data_Item_Count to iCnt
8943>>>>>>>      Set Data_Value iCnt to sData
8944>>>>>>>
8944>>>>>>>      // If one param passed use it for both display and database values
8944>>>>>>>      If num_arguments le 1 Move sData  to sVal
8947>>>>>>>      Else                  Move sDescr to sVal
8949>>>>>>>      Set Data_Description iCnt to sVal
8950>>>>>>>
8950>>>>>>>      If num_arguments le 2 Move (NullRowId()) to riRecVal
8953>>>>>>>      Else                  Move riRec        to riRecVal
8955>>>>>>>      Set Data_RowId iCnt to riRecVal
8956>>>>>>>    End_Procedure
8957>>>>>>>End_Class
8958>>>>>>>
8958>>>>>>>
8958>>>>>>>Class FileValidationTable is an DescriptionValidationTable
8959>>>>>>>
8959>>>>>>>   Procedure Construct_Object
8961>>>>>>>      Forward Send Construct_Object
8963>>>>>>>      Property Integer No_Fill_State     False // this is never used and is obsolete. (JJT)
8964>>>>>>>      Property Integer Ordering          1   // Indx1 is a good guess.
8965>>>>>>>      Property String  Type_Value        ''  // default these two to
8966>>>>>>>      Property Integer Type_Field        0   // Undefined (none).
8967>>>>>>>      Property Integer Code_Field        1   // Fld 1=code, 2=descr
8968>>>>>>>      Property Integer Description_Field 2   // are good guesses.
8969>>>>>>>
8969>>>>>>>      Property Integer Code_Load_Object  0   // or (Code_Loader(Self))
8970>>>>>>>   End_Procedure // Construct_Object
8971>>>>>>>
8971>>>>>>>   Function Table_Loaded_State Returns Integer
8973>>>>>>>      integer iRVal
8973>>>>>>>      Get No_fill_State to iRVal // if true, table always is loaded
8974>>>>>>>      If Not iRval ;         Forward get table_loaded_State to iRVal
8978>>>>>>>      Function_Return iRval
8979>>>>>>>   End_Function
8980>>>>>>>
8980>>>>>>>   Function Validate_Value String sCode Returns Integer
8982>>>>>>>      Integer iRVal
8982>>>>>>>      Integer iDSO
8982>>>>>>>      Get Code_Load_Object  to iDSO
8983>>>>>>>      // we use standard validate, if code is blank, OR if
8983>>>>>>>      //   1. if no code DSO or the code DSO exists but is not busy.
8983>>>>>>>      //   2. AND it is not no-fill
8983>>>>>>>      //   3. AND it is static
8983>>>>>>>      // Else we find the record directly
8983>>>>>>>      // Note that the operation mode is busy during request_validate (the
8983>>>>>>>      // ddo does this). WHen operation mode is busy we must not use
8983>>>>>>>      // the code dso (must find manually).
8983>>>>>>>      If (sCode='' OR ;           ( (iDSO=0 OR Operation_Mode=0)    AND ; // if no code DSO or DSO not busy             No_Fill_State(Self)=0 AND ;             Static_State(Self) ) ) ;               Forward Get Validate_Value sCode to iRVal
8987>>>>>>>      Else If (sCode<>Current_Code(Self)) ;          Get Find_Value sCode to iRVal
8991>>>>>>>      Function_Return iRVal // OK
8992>>>>>>>   End_Function
8993>>>>>>>
8993>>>>>>>   Procedure Initialize_File
8995>>>>>>>      integer iFile iCodeField iDescField iDSO iIndex iTypeField
8995>>>>>>>      Get Code_Load_Object  to iDSO
8996>>>>>>>      Get Main_File         to iFile
8997>>>>>>>      Get Code_Field        to iCodeField
8998>>>>>>>      Get Description_Field to iDescField
8999>>>>>>>      Get Ordering          to iIndex
9000>>>>>>>      Get Type_Field        to iTypeField
9001>>>>>>>      If (iDSO AND Operation_Mode=0) ;         Send Initialize_File to iDSO ;              iFile iIndex iCodeField iDescField ;              iTypeField (Type_Value(Self))
9004>>>>>>>      Else Begin
9005>>>>>>>         Clear iFile
9006>>>>>>>         // if Type exists, seed the type value
9006>>>>>>>         If iTypeField ;            Set_Field_Value iFile iTypeField to (Type_Value(Self))
9011>>>>>>>      End
9011>>>>>>>>
9011>>>>>>>   End_Procedure
9012>>>>>>>
9012>>>>>>>   Function Find_Value string Code returns Integer
9014>>>>>>>     integer iFile iCodeField iDescField iDSO iIndex iTypeField
9014>>>>>>>     Get Code_Load_Object  to iDSO
9015>>>>>>>     Get Main_File         to iFile
9016>>>>>>>     Get Ordering          to iIndex
9017>>>>>>>     Get Code_Field        to iCodeField
9018>>>>>>>     Get Description_Field to iDescField
9019>>>>>>>     Get Type_Field        to iTypeField
9020>>>>>>>     Send Initialize_File
9021>>>>>>>     //
9021>>>>>>>     Set_Field_Value iFile iCodeField to Code
9024>>>>>>>     If (iDSO AND Operation_Mode=0) ;        Send Request_Find to iDSO EQ iFile iIndex
9027>>>>>>>     Else ;        vFind iFile iIndex EQ
9030>>>>>>>     If not (Found) Function_Return 1
9033>>>>>>>     // Set properties Current_code and Current_Description
9033>>>>>>>     Send Store_Current_Data iFile iCodeField iDescField
9034>>>>>>>     Function_Return 0
9035>>>>>>>   End_Function // Function
9036>>>>>>>
9036>>>>>>>   // internal
9036>>>>>>>   Procedure Store_Current_Data Integer iFile Integer iCodeField Integer iDescField
9038>>>>>>>     String sVal
9038>>>>>>>//     Integer iRec
9038>>>>>>>     Get_Field_Value iFile iCodeField to sVal
9041>>>>>>>     Set Current_Code to (trim(sVal))
9042>>>>>>>     If iDescField Begin
9044>>>>>>>        Get_Field_Value iFile iDescField to sVal
9047>>>>>>>        Set Current_Description to (trim(sVal))
9048>>>>>>>     End
9048>>>>>>>>
9048>>>>>>>     Set Current_RowId to (GetRowId(iFile))
9049>>>>>>>//     Get_Field_Value iFile 0 to iRec // recnum
9049>>>>>>>//     Set Current_Record to iRec
9049>>>>>>>   End_Procedure
9050>>>>>>>
9050>>>>>>>   Function Next_Code_Record Returns boolean
9052>>>>>>>     integer iFile iCodeField iDescField iIndex
9052>>>>>>>     Integer iTypeField
9052>>>>>>>     String sTypeValue sFoundTypeValue
9052>>>>>>>     boolean bFound
9052>>>>>>>     handle hoDSO
9052>>>>>>>     Get Code_Load_Object  to hoDSO
9053>>>>>>>     Get Description_Field to iDescField
9054>>>>>>>     Get Code_Field        to iCodeField
9055>>>>>>>     Get Main_File         to iFile
9056>>>>>>>
9056>>>>>>>     If hoDSO begin
9058>>>>>>>        Get Next_Code_record of hoDSO to bFound
9059>>>>>>>     end
9059>>>>>>>>
9059>>>>>>>     Else Begin
9060>>>>>>>        Get Ordering to iIndex
9061>>>>>>>        vFind iFile iIndex GT
9063>>>>>>>        Move (Found) to bFound
9064>>>>>>>        If bFound Begin
9066>>>>>>>            // if found see if we are at the end of the valid list of types
9066>>>>>>>            Get Type_Field To iTypeField
9067>>>>>>>            Get Type_Value To sTypeValue
9068>>>>>>>            If ((iTypeField<>0) And (sTypeValue<>"")) Begin
9070>>>>>>>                Get_Field_Value iFile iTypeField To sFoundTypeValue
9073>>>>>>>                Move (Trim(sTypeValue)=Trim(sFoundTypeValue)) To bFound
9074>>>>>>>             End
9074>>>>>>>>
9074>>>>>>>        End
9074>>>>>>>>
9074>>>>>>>     End
9074>>>>>>>>
9074>>>>>>>     if bFound Begin
9076>>>>>>>        Send Store_Current_Data iFile iCodeField iDescField
9077>>>>>>>     End
9077>>>>>>>>
9077>>>>>>>     Function_Return bFound
9078>>>>>>>   End_Function // next_Code_record
9079>>>>>>>
9079>>>>>>>   Procedure Fill_List
9081>>>>>>>      RowId riId
9081>>>>>>>      boolean bFound
9081>>>>>>>      String sCode sDesc
9081>>>>>>>      If (Static_State(Self)=0 OR No_Fill_State(Self)) ;         Procedure_Return
9084>>>>>>>      //
9084>>>>>>>      Send Delete_Data
9085>>>>>>>      Send Initialize_File
9086>>>>>>>      Get Next_Code_Record to bFound
9087>>>>>>>      While bFound
9091>>>>>>>         Get Current_Code        to sCode
9092>>>>>>>         Get Current_Description to sDesc
9093>>>>>>>         Get Current_RowId       to riId
9094>>>>>>>         Send Add_Table_Value sCode sDesc riId
9095>>>>>>>         Get Next_Code_Record to bFound
9096>>>>>>>      Loop
9097>>>>>>>>
9097>>>>>>>      Set Table_Loaded_State to TRUE
9098>>>>>>>   End_Procedure // Fill_list
9099>>>>>>>
9099>>>>>>>   Procedure Request_Fill_From_List integer iObj integer iMsg
9101>>>>>>>      Integer iItem
9101>>>>>>>      Integer iFile
9101>>>>>>>      RowId   riId
9101>>>>>>>      Boolean bFound
9101>>>>>>>      String sCode sDesc
9101>>>>>>>
9101>>>>>>>      If (iObj=0 or iMsg=0) Procedure_return
9104>>>>>>>
9104>>>>>>>      If (Static_State(Self) AND No_Fill_State(Self)=0 ) ;         Forward Send Request_Fill_From_List iObj iMsg
9108>>>>>>>      Else Begin
9109>>>>>>>         Get Main_File to iFile
9110>>>>>>>         Send Initialize_File
9111>>>>>>>         Get Next_Code_Record to bFound
9112>>>>>>>         While bFound
9116>>>>>>>            Get Current_Code        to sCode
9117>>>>>>>            Get Current_Description to sDesc
9118>>>>>>>            Get Current_RowId       to riId
9119>>>>>>>            Send iMSG to iObj iItem sCode sDesc iFile riId
9120>>>>>>>            Increment iItem
9121>>>>>>>            Get Next_Code_Record to bFound
9122>>>>>>>         Loop
9123>>>>>>>>
9123>>>>>>>      End
9123>>>>>>>>
9123>>>>>>>   End_procedure
9124>>>>>>>End_Class
9125>>>>>>>
9125>>>>>>>use CodeLoad.pkg
Including file: codeload.pkg    (C:\Program Files (x86)\Visual DataFlex 17.1\Pkg\codeload.pkg)
9125>>>>>>>>>//************************************************************************
9125>>>>>>>>>//
9125>>>>>>>>>// Confidential Trade Secret.
9125>>>>>>>>>// Copyright 1987-1995 Data Access Corporation, Miami FL, USA
9125>>>>>>>>>// All Rights reserved
9125>>>>>>>>>// DataFlex is a registered trademark of Data Access Corporation.
9125>>>>>>>>>//
9125>>>>>>>>>//************************************************************************
9125>>>>>>>>>
9125>>>>>>>>>//************************************************************************
9125>>>>>>>>>// CodeLoad.pkg   - Code loading data-set
9125>>>>>>>>>// Version: 1.1
9125>>>>>>>>>//  03/18/94 - created
9125>>>>>>>>>//  04/04/94 - modified and made more general
9125>>>>>>>>>// 2/26/2002  JJT - 8.2 clean up (indirect_file, local, self, etc.)
9125>>>>>>>>>//
9125>>>>>>>>>// Author: John J. Tuohy
9125>>>>>>>>>//
9125>>>>>>>>>//
9125>>>>>>>>>// Interface:
9125>>>>>>>>>//
9125>>>>>>>>>//  Procedure Initialize_File Integer File# Integer Index# Integer Code# ;
9125>>>>>>>>>//                            Integer Desc# Integer Type# String Type
9125>>>>>>>>>//
9125>>>>>>>>>//      This initializes the data-set for finding. You MUST pass all five
9125>>>>>>>>>//      parameters here. They are:
9125>>>>>>>>>//          File#  -  main file to use
9125>>>>>>>>>//         Index#  - Index to use for finding
9125>>>>>>>>>//          Code#  - field number of the code
9125>>>>>>>>>//          Desc#  - field number of the code's description
9125>>>>>>>>>//          Type#  - field number of the constraining Type (0 if none)
9125>>>>>>>>>//           Type  - the constrain type value ('' = allow all records)
9125>>>>>>>>>//
9125>>>>>>>>>//      You MUST send this message before finding records. Alternately,
9125>>>>>>>>>//      you could set the individual properties and send rebuild_constraints
9125>>>>>>>>>//      and CLEAR to initalize the file (see code on how to do this).
9125>>>>>>>>>//
9125>>>>>>>>>//    Get Next_Code_record to ret_Int
9125>>>>>>>>>//
9125>>>>>>>>>//      Returns the next record number. 0 if no more. If record exists it
9125>>>>>>>>>//      sets the value of Current_Code and Crnt_Description.
9125>>>>>>>>>//
9125>>>>>>>>>//    Get Current_Code to Ret_String
9125>>>>>>>>>//    Get Crnt_Description to Ret_String
9125>>>>>>>>>//
9125>>>>>>>>>//      Returns the code and description of the last valid record found
9125>>>>>>>>>//      with the Next_Code_Record Message
9125>>>>>>>>>//
9125>>>>>>>>>//   Sample Usage:  This was created primarily to be used by the
9125>>>>>>>>>//                  radio-entry-form classes. In particular those using
9125>>>>>>>>>//                  the "code" look up file. Look at those packages if
9125>>>>>>>>>//                  you wish to use them yourself.
9125>>>>>>>>>//
9125>>>>>>>>>//
9125>>>>>>>>>//
9125>>>>>>>>>//************************************************************************
9125>>>>>>>>>
9125>>>>>>>>>use Data_Set.pkg
9125>>>>>>>>>
9125>>>>>>>>>Class Code_Loader_Data_Set is a DataSet
9126>>>>>>>>>
9126>>>>>>>>>  Procedure Construct_Object Integer Img#
9128>>>>>>>>>      Forward Send Construct_Object Img#
9130>>>>>>>>>      // These should be set by the Initialize_File message
9130>>>>>>>>>      Property String  Type_Value           '' // assume no defaults.
9131>>>>>>>>>      Property Integer Type_Field           0  // These values should be
9132>>>>>>>>>      Property Integer Code_Field           0  // set by initialize_file
9133>>>>>>>>>      Property Integer Description_Field    0  //
9134>>>>>>>>>
9134>>>>>>>>>      // These are SET by Next_Code_Record. You may GET their values
9134>>>>>>>>>      Property String  Current_Code         ''
9135>>>>>>>>>      Property String  Current_Description  ''
9136>>>>>>>>>  End_Procedure // Construct_Object
9137>>>>>>>>>
9137>>>>>>>>>  // If a Type exists (not a '') and there is a type field and a
9137>>>>>>>>>  // main_file constrain to the type. Else no constraints
9137>>>>>>>>>  Begin_Constraints
9139>>>>>>>>>     String sType
9139>>>>>>>>>     Integer iFile iField
9139>>>>>>>>>     Get Type_Value to sType
9140>>>>>>>>>     Get Main_File  to iFile
9141>>>>>>>>>     Get Type_Field to iField
9142>>>>>>>>>     If (sType<>'' AND iFile<>0 AND iField<>0) ;        VConstrain iFile iField eq sType
9147>>>>>>>>>  End_Constraints
9150>>>>>>>>>
9150>>>>>>>>>  //  This initializes the data-set for finding. You MUST pass all five
9150>>>>>>>>>  //  parameters here. They are:
9150>>>>>>>>>  //     File#  -  main file to use
9150>>>>>>>>>  //    Index#  - Index to use for finding
9150>>>>>>>>>  //     Code#  - field number of the code
9150>>>>>>>>>  //     Desc#  - field number of the code's description
9150>>>>>>>>>  //     Type#  - field number of the constraining Type (0 if none)
9150>>>>>>>>>  //      Type  - the constrain type value ('' = allow all records)
9150>>>>>>>>>  //
9150>>>>>>>>>  Procedure Initialize_File Integer File# Integer Index# Integer Code# ;                            Integer Desc# Integer Type# String Type
9152>>>>>>>>>     // note: all params are required!
9152>>>>>>>>>     Set Main_File         to File#
9153>>>>>>>>>     Set Ordering          to Index#
9154>>>>>>>>>     Set Code_Field        to Code#
9155>>>>>>>>>     Set Description_Field to Desc#
9156>>>>>>>>>     Set Type_Field        to Type#
9157>>>>>>>>>     Set Type_Value        to Type
9158>>>>>>>>>     //
9158>>>>>>>>>     Send Rebuild_Constraints // set up constraints
9159>>>>>>>>>     Send Clear               // initialize the file
9160>>>>>>>>>  End_Procedure
9161>>>>>>>>>
9161>>>>>>>>>  //  Find the next record: Return 0 if no record, 1 if record exists
9161>>>>>>>>>  //   if record exists set Current_Code and Current_Description
9161>>>>>>>>>  //
9161>>>>>>>>>  Function Next_Code_Record Returns boolean
9163>>>>>>>>>     integer iFile iField
9163>>>>>>>>>     string sValue
9163>>>>>>>>>     Send Request_Find GT (Main_File(self)) (Ordering(self))
9164>>>>>>>>>     If not (Found) Function_Return false
9167>>>>>>>>>     // Set properties Current_code and Current_Description
9167>>>>>>>>>     Get Main_File to iFile
9168>>>>>>>>>
9168>>>>>>>>>     Get Code_Field to iField
9169>>>>>>>>>     Get_Field_Value iFile iField to sValue
9172>>>>>>>>>     Set Current_Code to sValue
9173>>>>>>>>>
9173>>>>>>>>>     Get Description_Field to iField
9174>>>>>>>>>     Get_Field_Value iFile iField to sValue
9177>>>>>>>>>     Set Current_Description to sValue
9178>>>>>>>>>     Function_return True
9179>>>>>>>>>  End_Function // Function
9180>>>>>>>>>
9180>>>>>>>>>End_Class
9181>>>>>>>Use cCodeMaintOpen_Mixin.pkg
Including file: cCodeMaintOpen_Mixin.pkg    (C:\Program Files (x86)\Visual DataFlex 17.1\Pkg\cCodeMaintOpen_Mixin.pkg)
9181>>>>>>>>>// Mixin class to support transistion support for CodeType and CodeMast files.
9181>>>>>>>>>// These files used to be in filelist and they used to reside at 207 and 208 and they
9181>>>>>>>>>// were always opened with "open as"
9181>>>>>>>>>// We want these to be in the filelist at 253 and 254. These open methods will attempt to open these files
9181>>>>>>>>>// as such. If these are old files (not in filelist or wrong number) they will get loaded with the old
9181>>>>>>>>>// open as - thus keeping this backwards compatible.
9181>>>>>>>>>// By adding to filelist, we can sort the files and we can open them as other database sources.
9181>>>>>>>>>use VDFBase.pkg
9181>>>>>>>>>
9181>>>>>>>>>Declare_DataFile CodeType
Including file: CodeType.fd    (C:\data\VDF\ForEach\DDSrc\CodeType.fd)
9181>>>>>>>>>Declare_DataFile CodeMast
Including file: CodeMast.fd    (C:\data\VDF\ForEach\DDSrc\CodeMast.fd)
9181>>>>>>>>>Define C_Expected_CodeType_FileNumber for 253  // and the logical name must be CODETYPE
9181>>>>>>>>>Define C_Expected_CodeMast_FileNumber for 254  // and the logical name must be CODEMAST
9181>>>>>>>>>
9181>>>>>>>>>Class cCodeMaintOpen_Mixin is a Mixin
9182>>>>>>>>>
9182>>>>>>>>>    Procedure OpenCodeMast
9184>>>>>>>>>        string sName
9184>>>>>>>>>        If (Codemast.File_number=C_Expected_CodeMast_FileNumber) begin
9186>>>>>>>>>            get_attribute DF_FILE_LOGICAL_NAME of Codemast.File_number to sName
9189>>>>>>>>>            If (uppercase(trim(sName))="CODEMAST") begin
9191>>>>>>>>>                Open CodeMast
9193>>>>>>>>>                Procedure_return
9194>>>>>>>>>            end
9194>>>>>>>>>>
9194>>>>>>>>>        end
9194>>>>>>>>>>
9194>>>>>>>>>        Open "CodeMast" as Codemast.File_number
9196>>>>>>>>>    End_Procedure
9197>>>>>>>>>
9197>>>>>>>>>    Procedure OpenCodeType
9199>>>>>>>>>        string sName
9199>>>>>>>>>        If (Codetype.File_number=C_Expected_CodeType_FileNumber) begin
9201>>>>>>>>>            get_attribute DF_FILE_LOGICAL_NAME of CodeType.File_number to sName
9204>>>>>>>>>            If (uppercase(trim(sName))="CODETYPE") begin
9206>>>>>>>>>                Open CodeType
9208>>>>>>>>>                Procedure_return
9209>>>>>>>>>            end
9209>>>>>>>>>>
9209>>>>>>>>>        end
9209>>>>>>>>>>
9209>>>>>>>>>        Open "CodeType" as CodeType.File_number
9211>>>>>>>>>    End_Procedure
9212>>>>>>>>>
9212>>>>>>>>>End_Class
9213>>>>>>>
9213>>>>>>>  //
9213>>>>>>>  //  This is the object we need for loading files.
9213>>>>>>>  //
9213>>>>>>>  Object Code_loader is a Code_loader_Data_Set no_Image
9215>>>>>>>  End_Object
9216>>>>>>>
9216>>>>>>>
9216>>>>>>>Class CodeValidationTable is an FileValidationTable
9217>>>>>>>
9217>>>>>>>    // supports opening of file in reserved filelist area.
9217>>>>>>>    Import_Class_Protocol cCodeMaintOpen_Mixin
9218>>>>>>>
9218>>>>>>>    Procedure Construct_Object
9220>>>>>>>        Forward Send Construct_Object
9222>>>>>>>
9222>>>>>>>        Send OpenCodeMast                       // methods supports w/ filelist (new) and without (old)
9223>>>>>>>
9223>>>>>>>        Set Main_File to CodeMast.File_Number   // name of file is CODEMAST
9224>>>>>>>        Set Ordering to 1                       // Index 1: Types x Code
9225>>>>>>>        Set Type_Field to 1                     // Fld 1: Type
9226>>>>>>>        Set Code_Field to 2                     // Fld 2: Code
9227>>>>>>>        Set Description_Field to 3              // Fld 3: Description
9228>>>>>>>        Set Code_load_Object to (Code_Loader(self))
9229>>>>>>>    End_Procedure // Construct_Object
9230>>>>>>>
9230>>>>>>>End_Class
9231>>>>>>>
9231>>>>>>>
9231>>>>>
9231>>>>>// values passed to OnPre/PostFind to indicate the operation type
9231>>>>>Enum_List 
9231>>>>>    Define DDFindRequestFind    // request_find
9231>>>>>    Define DDFindFindByRowRec   // FindByRowId, Find_By_Recnum
9231>>>>>    Define DDFindRequestAssign  // Request_assign  
9231>>>>>    Define DDFindClear          // Clear (note Clear_All doesn't do this)
9231>>>>>End_Enum_List
9231>>>>>
9231>>>>>
9231>>>>>// Structs used for the DD-dynamic field remember feature
9231>>>>>// these are private
9231>>>>>Define DD_RememberLast for "_REMEMBER$LAST_"
9231>>>>>Struct tDDRemembered
9231>>>>>    Integer iField
9231>>>>>    String sDefault
9231>>>>>    String sLastValue
9231>>>>>End_Struct
9231>>>>>
9231>>>>>// comparision used for searching for field
9231>>>>>Function CompareDDDefault_Field Desktop tDDRemembered FirstReference tDDRemembered SecondReference Returns Integer
9233>>>>>    If (FirstReference.iField=SecondReference.iField) Begin
9235>>>>>        Function_Return (EQ)
9236>>>>>    End
9236>>>>>>
9236>>>>>    Else If (FirstReference.iField>SecondReference.iField) Begin
9239>>>>>        Function_Return (GT)
9240>>>>>    End
9240>>>>>>
9240>>>>>    Function_Return (LT)
9241>>>>>End_Function
9242>>>>>
9242>>>>>
9242>>>>>
9242>>>>>// Used to assign a global validation_object. This can be used for
9242>>>>>// automatic prompt object on non-relational validations (checks, validation_
9242>>>>>// tables, etc.)
9242>>>>>Integer DD_Global_Validation_Prompt_Object
9242>>>>>Move 0 to DD_Global_Validation_Prompt_Object
9243>>>>>
9243>>>>>// Used for Dso traversal marking - Private (do not use)
9243>>>>>Integer   DD_Current_Mark_Id
9243>>>>>Move 0 to DD_Current_Mark_Id
9244>>>>>
9244>>>>>// Used to validate DSO structures during Save and deletes
9244>>>>>Enumeration_List
9244>>>>>  Define DD_VALIDATE_STRUCTURE_ALWAYS // Validate each save/delete operation.
9244>>>>>  Define DD_VALIDATE_STRUCTURE_NEVER  // Never validate these operations.
9244>>>>>  Define DD_VALIDATE_STRUCTURE_ONCE   // Validate Once (first save or delete).
9244>>>>>End_Enumeration_List
9244>>>>>
9244>>>>>// Used as a start for error handing in DSOs. Only affects errors that go
9244>>>>>// through operation_not_allowed and Field_Error. Used by Error_Report_Mode
9244>>>>>Enumeration_List
9244>>>>>  Define DD_ERROR_REPORT              // Report Error on screen
9244>>>>>  Define DD_ERROR_NO_REPORT           // Show no Error..
9244>>>>>End_Enumeration_List
9244>>>>>
9244>>>>>Enumeration_List
9244>>>>>  Define DD_Lock_on_All             for  7  // 111
9244>>>>>  Define DD_Lock_on_New_Save_Delete for  5  // 101
9244>>>>>  Define DD_Lock_on_Delete          for  4  // 100
9244>>>>>  Define DD_Lock_on_Save            for  2  // 010
9244>>>>>  Define DD_Lock_on_New_Save        for  1  // 001
9244>>>>>End_Enumeration_List
9244>>>>>
9244>>>>>
9244>>>>>Define DD_DEFAULT_ERROR_NUMBER  for 999
9244>>>>>
9244>>>>>
9244>>>>>// This table gives an overview of the Item_Options property of an item.
9244>>>>>//
9244>>>>>// AUTOFIND-------------------------------------------------------------------+
9244>>>>>// FINDREQ------------------------------------------------------------------+ |
9244>>>>>// NOPUT------------------------------------------------------------------+ | |
9244>>>>>// NOENTER--------------------------------------------------------------+ | | |
9244>>>>>//                                                                      | | | |
9244>>>>>// SKIPFOUND---------------------------------------------------------+  | | | |
9244>>>>>// RETAIN----------------------------------------------------------+ |  | | | |
9244>>>>>// RETAINALL-----------------------------------------------------+ | |  | | | |
9244>>>>>// FORCEPUT----------------------------------------------------+ | | |  | | | |
9244>>>>>//                                                             | | | |  | | | |
9244>>>>>// AUTOFIND_GE----------------------------------------------------------------|
9244>>>>>//                                                          |  | | | |  | | | |
9244>>>>>// REQUIRED---------------------------+                     |  | | | |  | | | |
9244>>>>>// CAPSLOCK-------------------------+ |                     |  | | | |  | | | |
9244>>>>>//                                  | |                     |  | | | |  | | | |
9244>>>>>// ZERO_SUPPRESS-----------------+  | |                     |  | | | |  | | | |
9244>>>>>//                               |  | |                     |  | | | |  | | | |
9244>>>>>// AUTORETURN-----------+        |  | |                     |  | | | |  | | | |
9244>>>>>// AUTOBACK-----------+ |        |  | |                     |  | | | |  | | | |
9244>>>>>// COMMIT (NOCALC)+   | |        |  | |                     |  | | | |  | | | |
9244>>>>>// AUTOCLEAR-+    |   | |        |  | |                     |  | | | |  | | | |
9244>>>>>//           |    |   | |        |  | |                     |  | | | |  | | | |
9244>>>>>//      |x|x|||x||||x||||||x|x|x||||||||x|x||x|x|x|x||x|x|x|||||||||||||||||||||
9244>>>>>//      | | | | || | | | || | | | || | | | || | | | || | | | || | | | || | | | |
9244>>>>>//      |3|3|2|2||2|2|2|2||2|2|2|2||1|1|1|1||1|1|1|1||1|1| | || | | | || | | | |
9244>>>>>//      |1|0|9|8||7|6|5|4||3|2|1|0||9|8|7|6||5|4|3|2||1|0|9|8||7|6|5|4||3|2|1|0|
9244>>>>>
9244>>>>>
9244>>>>>
9244>>>>>// The next replaces will be used to indicate default item-options
9244>>>>>// instead of a fieldnumber which is normally used.
9244>>>>>
9244>>>>>// Special parameter options that can get passed to Set Field_Options. The
9244>>>>>// purpose is to clear all fields or the remaining passed parameters. Normally,
9244>>>>>// these are not used so it does not matter if their interface is a bit odd.
9244>>>>>Enumeration_list
9244>>>>>   Define DD_CLEAR_FIELD_OPTIONS      for -1
9244>>>>>   Define DD_CLEAR_ALL_FIELD_OPTIONS  for -2
9244>>>>>End_Enumeration_list
9244>>>>>
9244>>>>>// used to keep track of extra server file information.
9244>>>>>Struct tDDServerInformation
9244>>>>>    Integer iParent             // parent file number
9244>>>>>    Boolean bAllowNullParent    // does this DD (child) allow a null parent
9244>>>>>    Integer bParentNoSwitchIfCommitted // does this DD (child) allow switching committed parents
9244>>>>>End_Struct
9244>>>>>
9244>>>>>Use DDExtFld.pkg // adds extended field/pointer support
Including file: DDExtFld.pkg    (C:\Program Files (x86)\Visual DataFlex 17.1\Pkg\DDExtFld.pkg)
9244>>>>>>>//****************************************************************************//
9244>>>>>>>//                                                                            //
9244>>>>>>>// $File name  : DDExtFld.pkg                                                 //
9244>>>>>>>// $File title : DD extended field objects                                    //
9244>>>>>>>// Notice      :                                                              //
9244>>>>>>>// $Author(s)  : John Tuohy                                                   //
9244>>>>>>>//                                                                            //
9244>>>>>>>//                                                                            //
9244>>>>>>>// Confidential Trade Secret.                                                 //
9244>>>>>>>// Copyright 1998-1999 Data Access Corporation, Miami FL, USA                 //
9244>>>>>>>// All Rights reserved                                                        //
9244>>>>>>>// DataFlex is a registered trademark of Data Access Corporation.             //
9244>>>>>>>//                                                                            //
9244>>>>>>>// $Rev History                                                               //
9244>>>>>>>//                                                                            //
9244>>>>>>>// JJT   10/18/99 Fixed bug where string of lesser length was not updated     //
9244>>>>>>>// JJT   11/9/98  Added !zb code around conditionally created objects         //
9244>>>>>>>// JT   10/26/98 Added Set Field_pValue                                       //
9244>>>>>>>// JT    8/6/98  Added bShowErr to Field_pEntry (currently does nothing)      //
9244>>>>>>>// JW    7/10/98 Changed IF test in Field_pEntry where address type           //
9244>>>>>>>//               was used to integer type. It dose not work with address      //
9244>>>>>>>//               I did also remove some old debug code                        //
9244>>>>>>>//                                                                            //
9244>>>>>>>// JT   7/9/98   Added passed length to set field_pEntry                      //
9244>>>>>>>// JT  6/25/98   Moved into this package.                                     //                                                                           //
9244>>>>>>>//****************************************************************************//
9244>>>>>>>
9244>>>>>>>// This is used by the DataDictionary class and provides a method for
9244>>>>>>>// windows DDs (for now) to support local buffers for text and binary buffers.
9244>>>>>>>// Field objects are created within the DD by sending the message:
9244>>>>>>>// The DD interface is:
9244>>>>>>>//
9244>>>>>>>//      Get  Field_Object iField to hExtFieldObject
9244>>>>>>>//      Send DefineExtendedField iField
9244>>>>>>>//      Send DefineAllExtendedFields
9244>>>>>>>//      Send ExtendedFieldsUpdate bSave
9244>>>>>>>//      Send ExtendedFieldsRefresh bCleared
9244>>>>>>>//      Set  File_Field_Current_Pointer_Value iFile iField iLen to pValue
9244>>>>>>>//      Set  Field_Current_Pointer_Value iField iLen to pValue
9244>>>>>>>//      Set  File_Field_Pointer_Entry iFile iField iLen bShowErr to pValue
9244>>>>>>>//      Set  Field_Pointer_Entry iField iOpts iLen bShowErr to pValue
9244>>>>>>>//      Get  File_Field_Current_Pointer_Value iFile iField to pData
9244>>>>>>>//      Get  Field_Current_Pointer_Value iField to pData
9244>>>>>>>//
9244>>>>>>>// Once object is identified, the following interface can be used
9244>>>>>>>//      Get FieldPointer of hExtFieldObject to iMemoryPointer
9244>>>>>>>//      Get FieldLength  of hExtFieldObject to iLen
9244>>>>>>>//      Get File_Number  of hExtFieldObject to iFile
9244>>>>>>>//      Get Field_Number of hExtFieldObject to iFile
9244>>>>>>>//      Set Update_Save_State of hExtFieldObject to bState         // be careful!
9244>>>>>>>//      Set Update_Find_State of hExtFieldObject to bState         // be careful
9244>>>>>>>//      Set FieldRefresh_Save_State of hExtFieldObject to bState   // be careful
9244>>>>>>>//
9244>>>>>>>
9244>>>>>>>//
9244>>>>>>>//  DD structure:
9244>>>>>>>//       DD Object           (property Field_objects points to child)
9244>>>>>>>//           FieldObjects    (array of field#s and field objs)
9244>>>>>>>//              FieldObject1 (heap alloc for each field)
9244>>>>>>>//              FieldObjectn
9244>>>>>>>//
9244>>>>>>>
9244>>>>>>>//
9244>>>>>>>// This is used to create a single extended field object.
9244>>>>>>>//
9244>>>>>>>// Interface
9244>>>>>>>//      Get FieldPointer to iMemoryPointer
9244>>>>>>>//      Get FieldLength  to iLen
9244>>>>>>>//      Get File_Number  to iFile
9244>>>>>>>//      Get Field_Number to iFile
9244>>>>>>>//      get/Set Update_Save_State to bState         // be careful!
9244>>>>>>>//      get/Set Update_Find_State to bState         // be careful
9244>>>>>>>//      get/Set FieldRefresh_Save_State to bState   // be careful
9244>>>>>>>//      get/set FieldChangedState
9244>>>>>>>//      send defineField  iFile iField
9244>>>>>>>//      Send FieldUpdate  bSave
9244>>>>>>>//      Send FieldRefresh bCleared bClearFieldChange
9244>>>>>>>//      Set  Field_pEntry iOpts iLen to pValue
9244>>>>>>>//      Set  Field_pValue iLen to pValue
9244>>>>>>>//
9244>>>>>>>use VDFBase.pkg
9244>>>>>>>
9244>>>>>>>Class FieldObject is an Array
9245>>>>>>>
9245>>>>>>>    Procedure Construct_Object
9247>>>>>>>        Forward send construct_object
9249>>>>>>>        // these are all set by DefineField and should not be changed
9249>>>>>>>        Property Integer File_Number        0
9250>>>>>>>        Property Integer Field_Number       0
9251>>>>>>>        Property Integer FieldLength        0
9252>>>>>>>        Property Address FieldPointer       0
9253>>>>>>>
9253>>>>>>>        // these can be changed, with care, by the developer
9253>>>>>>>        Property Integer Update_Save_State  True
9254>>>>>>>        Property Integer Update_Find_State  False // usually no point for finds
9255>>>>>>>        Property Integer FieldRefresh_State True
9256>>>>>>>    End_procedure
9257>>>>>>>
9257>>>>>>>    Procedure set FieldChangedState integer bState
9259>>>>>>>       integer iField
9259>>>>>>>       Get Field_Number to iField
9260>>>>>>>       Delegate Set Field_Changed_state iField to bState
9262>>>>>>>    end_procedure
9263>>>>>>>
9263>>>>>>>    Function FieldChangedState returns integer
9265>>>>>>>       integer iField  bState
9265>>>>>>>       Get Field_Number to iField
9266>>>>>>>       Delegate get Field_Changed_state iField to bState
9268>>>>>>>       Function_return bState
9269>>>>>>>    end_function
9270>>>>>>>
9270>>>>>>>
9270>>>>>>>    Function CreateFieldHeap integer iFldLen returns Integer
9272>>>>>>>        Integer bOk
9272>>>>>>>        Address pField pOldField
9272>>>>>>>        // The heap must be fieldlength+1. Get_Field_Value with memory pointers
9272>>>>>>>        // always adds a 0 at the end of the returned value. We will never look at
9272>>>>>>>        // that extra character which is why we only zero up to iFldLen
9272>>>>>>>        Get FieldPointer to pOldField
9273>>>>>>>        If pOldField ;            Move (ReAlloc(pOldField, iFldLen+1)) to pField
9276>>>>>>>        Else ;            Move (Alloc(iFldLen+1)) to pField
9278>>>>>>>        If pField Move (MemSet(pField,0,iFldLen+1)) to bOK
9281>>>>>>>        Function_return pField
9282>>>>>>>    End_Function
9283>>>>>>>
9283>>>>>>>    Procedure DestroyFieldHeap
9285>>>>>>>        integer bOK
9285>>>>>>>        address pField
9285>>>>>>>        Get FieldPointer to pField
9286>>>>>>>        if (pField ) ;           Move (Free(pField)) to bOk
9289>>>>>>>        Set FieldPointer to 0
9290>>>>>>>    End_procedure
9291>>>>>>>
9291>>>>>>>    // augment to realse heap allocation
9291>>>>>>>    Procedure Destroy_Object
9293>>>>>>>        Send DestroyFieldHeap
9294>>>>>>>        forward send Destroy_object
9296>>>>>>>    End_procedure
9297>>>>>>>
9297>>>>>>>    // for object: define file, field, fieldlength and allocate heap memory
9297>>>>>>>    //             and set memory pointer
9297>>>>>>>    Procedure DefineField integer iFile integer iField
9299>>>>>>>        address pField
9299>>>>>>>        integer iFldLen
9299>>>>>>>        Set File_Number  to iFile
9300>>>>>>>        Set Field_Number to iField
9301>>>>>>>        Get_Attribute DF_FIELD_LENGTH of iFile iField to iFldLen
9304>>>>>>>        Set FieldLength  to iFldLen
9305>>>>>>>        Get CreateFieldHeap iFldLen to pField
9306>>>>>>>        Set FieldPointer to pField
9307>>>>>>>    End_procedure
9308>>>>>>>
9308>>>>>>>    // Move from the DD Buffer to the file buffer
9308>>>>>>>    Procedure FieldUpdate integer bSave
9310>>>>>>>        Integer iFile iField iFieldLen
9310>>>>>>>        Address pField
9310>>>>>>>        integer iType
9310>>>>>>>
9310>>>>>>>        // if bSave, part of save which means only update if changed
9310>>>>>>>        // if not bsave, part of find. You usually would not update this. You
9310>>>>>>>        // don't index on these types of fields
9310>>>>>>>        If ( (bSave AND Update_Save_State(self) and FieldChangedState(Self)) OR ;             (Not(bSave) And Update_Find_state(Self) ) ) Begin
9312>>>>>>>            Get FieldPointer to pField
9313>>>>>>>            Get File_Number to iFile
9314>>>>>>>            Get Field_Number to iField
9315>>>>>>>            if (pField AND iFile) Begin
9317>>>>>>>                // if datatype is Text we want to pass the real text length. Anything else (binary) we pass
9317>>>>>>>                // the entire thing. Changed for 9.1 (used to pass entire length). This also required a RT change
9317>>>>>>>                // this code will not work before build 9.1.44.
9317>>>>>>>                // If binary, we must set a length limit because the heap is one char longer.
9317>>>>>>>                Get_Attribute DF_FIELD_TYPE of iFile iField to iType
9320>>>>>>>                If (iType=DF_TEXT) Begin
9322>>>>>>>                     Move (CStringLength(pField)) to iFieldLen
9323>>>>>>>                End
9323>>>>>>>>
9323>>>>>>>                Else Begin
9324>>>>>>>                     Get FieldLength to iFieldLen 
9325>>>>>>>                End
9325>>>>>>>>
9325>>>>>>>                Set_Field_Value iFile iField to pField LENGTH iFieldLen
9328>>>>>>>            end
9328>>>>>>>>
9328>>>>>>>        End
9328>>>>>>>>
9328>>>>>>>    end_procedure
9329>>>>>>>
9329>>>>>>>    // Move from File buffer to local DD Buffer
9329>>>>>>>    // bCleared determines if this is a find or a clear.
9329>>>>>>>    // bClearFieldChange determines if we should clear the FieldChangedState.
9329>>>>>>>    Procedure FieldRefresh Boolean bCleared Boolean bClearFieldChange
9331>>>>>>>        Integer iFile iField
9331>>>>>>>        Integer bOk
9331>>>>>>>        Address pField
9331>>>>>>>        If (FieldRefresh_state(Self)) Begin
9333>>>>>>>            Get FieldPointer to pField
9334>>>>>>>            Get File_Number to iFile
9335>>>>>>>            Get Field_Number to iField
9336>>>>>>>            // move from file buffer to memory pointed to by pField
9336>>>>>>>            If (pField and iFile) Begin
9338>>>>>>>                If not bCleared Begin
9340>>>>>>>                   Get_Field_Value iFile iField to pField
9343>>>>>>>                End
9343>>>>>>>>
9343>>>>>>>                Else Begin
9344>>>>>>>                   Move (MemSet(pField,0,FieldLength(Self))) to bOk
9345>>>>>>>                End
9345>>>>>>>>
9345>>>>>>>            End
9345>>>>>>>>
9345>>>>>>>        End
9345>>>>>>>>
9345>>>>>>>        If bClearFieldChange Begin
9347>>>>>>>            Set FieldChangedstate to False
9348>>>>>>>        End
9348>>>>>>>>
9348>>>>>>>    End_Procedure
9349>>>>>>>
9349>>>>>>>    Procedure set Field_pEntry integer iOpts integer iLen integer bShowErr Address pValue
9351>>>>>>>        integer iFile iField iFldLen iMemLen
9351>>>>>>>        Integer bChanged
9351>>>>>>>        Address pField
9351>>>>>>>        integer bOK
9351>>>>>>>
9351>>>>>>>        // currently we do nothing with bShowErr because we don't checkfor errors!
9351>>>>>>>
9351>>>>>>>        // if No-enter or Displayonly, this shouldn't be changed. For now we will
9351>>>>>>>        // let NoPut through, since a user might need it for finding.
9351>>>>>>>        If (iOpts IAND DD_NOENTER) Procedure_Return
9354>>>>>>>
9354>>>>>>>        // maybe in the future
9354>>>>>>>        // Force a caplsock if required
9354>>>>>>>        //If (iOpts IAND DD_CAPSLOCK) Move (Uppercase(sValue)) to sValue
9354>>>>>>>
9354>>>>>>>        Get File_Number  to iFile
9355>>>>>>>        Get Field_Number to iField
9356>>>>>>>        Get FieldLength  to iFldLen  // max length of the field buffer
9357>>>>>>>        Get FieldPointer to pField
9358>>>>>>>        If (pField AND iFile) Begin
9360>>>>>>>
9360>>>>>>>            // always work with the smallest field size. We know the length of the
9360>>>>>>>            // field buffer and we are passed the length of the data
9360>>>>>>>            Move (iLen MIN iFldLen) to iMemLen
9361>>>>>>>            // is there a change??
9361>>>>>>>            If (pValue) ; // check for empty pointer               Move (MemCompare(pField,pValue,iMemLen)) to bChanged
9364>>>>>>>            // See if new string is shorter than the old one. If it is we might get no change when one exists
9364>>>>>>>            // So, check if the old Field's next char is 0, if not, the new field is shorter.. and changed,
9364>>>>>>>            // if the field's next char is 0, then it is at the end and the strings are the same
9364>>>>>>>            If (Not(bChanged) AND iMemLen<iFldLen) ;               Move (derefc(pField, iMemLen)<>0)  to bChanged
9367>>>>>>>
9367>>>>>>>            If ( bChanged or (iOpts IAND DD_FORCEPUT) ) Begin
9369>>>>>>>                If (iMemLen<iFldLen) ; // if a partial copy, zero the entire string first                    Move (MemSet(pField,0,iFldLen)) to bOk
9372>>>>>>>                If (pValue) ;                    Move (MemCopy(pField,pValue,iMemLen)) to bOk
9375>>>>>>>            End
9375>>>>>>>>
9375>>>>>>>            // Set changed state if changed and it is not No_put. This
9375>>>>>>>            // is an improvement on DEOs which would set changed-state for
9375>>>>>>>            // a no-put. This way, finds use the changed value but saves will
9375>>>>>>>            // not trigger a phony data loss
9375>>>>>>>            //If ( bChanged ) ;
9375>>>>>>>            If ( bChanged AND Not(iOpts IAND DD_NOPUT) ) ;                Set FieldChangedState to True
9378>>>>>>>
9378>>>>>>>            // The following is really highly unlikely!!!
9378>>>>>>>            // perform autofinds if needed. Note that required checking will occur as
9378>>>>>>>            // part of validation.
9378>>>>>>>            // We will only autofind if the field value is changed. This is consistent with
9378>>>>>>>            // DEOs which do not autofind on unchanged values. This provides optimizations
9378>>>>>>>            // when a parent record is already loaded.
9378>>>>>>>            If (bChanged OR FieldChangedState(self)) Begin
9380>>>>>>>                If (iOpts IAND DD_AUTOFIND)         Delegate Send File_Field_AutoFind iFile iField EQ
9384>>>>>>>                Else If (iOpts IAND DD_AUTOFIND_GE) Delegate Send File_Field_AutoFind iFile iField GE
9389>>>>>>>            End
9389>>>>>>>>
9389>>>>>>>        end
9389>>>>>>>>
9389>>>>>>>
9389>>>>>>>    End_Procedure
9390>>>>>>>
9390>>>>>>>    // Raw update of value.
9390>>>>>>>    Procedure set Field_pValue integer iLen Address pValue
9392>>>>>>>        integer iFile iField iFldLen iMemLen
9392>>>>>>>        Integer bOk
9392>>>>>>>        Address pField
9392>>>>>>>        Get File_Number  to iFile
9393>>>>>>>        Get Field_Number to iField
9394>>>>>>>        Get FieldLength  to iFldLen  // max length of the field buffer
9395>>>>>>>        Get FieldPointer to pField
9396>>>>>>>        If (pField AND iFile) Begin
9398>>>>>>>            // always work with the smallest field size. We know the length of the
9398>>>>>>>            // field buffer and we are passed the length of the data
9398>>>>>>>            Move (iLen MIN iFldLen) to iMemLen
9399>>>>>>>            // is there a change??
9399>>>>>>>            If (iMemLen<iFldLen) ; // if a partial copy, zero the entire string first                Move (MemSet(pField,0,iFldLen)) to bOk
9402>>>>>>>            If (pValue) ;                Move (MemCopy(pField,pValue,iMemLen)) to bOk
9405>>>>>>>        end
9405>>>>>>>>
9405>>>>>>>    End_Procedure
9406>>>>>>>
9406>>>>>>>    Function Is_pValueChanged Integer iLen Address pValue Returns Boolean
9408>>>>>>>        Integer iFile iField iFldLen iMemLen
9408>>>>>>>        Boolean bChanged
9408>>>>>>>        Address pField
9408>>>>>>>
9408>>>>>>>        Get File_Number  to iFile
9409>>>>>>>        Get Field_Number to iField
9410>>>>>>>        Get FieldLength  to iFldLen  // max length of the field buffer
9411>>>>>>>        Get FieldPointer to pField
9412>>>>>>>        // always work with the smallest field size. We know the length of the
9412>>>>>>>        // field buffer and we are passed the length of the data
9412>>>>>>>        Move (iLen min iFldLen) to iMemLen
9413>>>>>>>        // is there a change??
9413>>>>>>>        If (pValue and iLen) Begin // check for empty pointer
9415>>>>>>>             Move (MemCompare(pField,pValue,iMemLen)) to bChanged
9416>>>>>>>        End
9416>>>>>>>>
9416>>>>>>>        // See if new string is shorter than the old one. If it is we might get no change when one exists
9416>>>>>>>        // So, check if the old Field's next char is 0, if not, the new field is shorter.. and changed,
9416>>>>>>>        // if the field's next char is 0, then it is at the end and the strings are the same
9416>>>>>>>        If (not(bChanged) and iMemLen<iFldLen) Begin
9418>>>>>>>            Move (derefc(pField, iMemLen)<>0)  to bChanged
9419>>>>>>>        End        
9419>>>>>>>>
9419>>>>>>>        Function_Return bChanged
9420>>>>>>>  End_Function
9421>>>>>>>
9421>>>>>>>End_Class
9422>>>>>>>
9422>>>>>>>// This contains all extended field objects.
9422>>>>>>>// The array contains a list of all objects where item=field#
9422>>>>>>>// and item+1=field object.
9422>>>>>>>//
9422>>>>>>>// Interface is:
9422>>>>>>>//     Get Field_object iField to hFldObj
9422>>>>>>>//     Send DefineFieldObject iField
9422>>>>>>>//     Send ExtendedFieldsUpdate bSave
9422>>>>>>>//     Send ExtendedFieldsRefresh bCleared
9422>>>>>>>//
9422>>>>>>>Class FieldObjects is an Array
9423>>>>>>>
9423>>>>>>>    // return object Id for iField. 0 if none.
9423>>>>>>>    Function Field_Object integer iField Returns integer
9425>>>>>>>        integer iItm iCnt
9425>>>>>>>        Get Item_Count to iCnt
9426>>>>>>>        Move 0 to iItm
9427>>>>>>>        While iItm lt iCnt
9431>>>>>>>            If (Value(self,iItm)=iField) ;               Function_Return (Value(self,iItm+1))
9434>>>>>>>            Increment iItm
9435>>>>>>>            Increment iItm
9436>>>>>>>        Loop
9437>>>>>>>>
9437>>>>>>>        Function_Return 0
9438>>>>>>>    End_Function
9439>>>>>>>
9439>>>>>>>    // define an extended object for field
9439>>>>>>>    Procedure DefineFieldObject integer iField
9441>>>>>>>        integer hFld
9441>>>>>>>        Integer iCnt  iFile
9441>>>>>>>        Boolean bInUse
9441>>>>>>>        Boolean bHasRecord
9441>>>>>>>        Delegate Get Main_File to iFile
9443>>>>>>>        Get Field_Object iField to hFld // this shouldn't exist yet
9444>>>>>>>        If not hFld Begin
9446>>>>>>>           Get Create U_FieldObject to hFld
9447>>>>>>>           Send DefineField to hFld iFile iField
9448>>>>>>>           Get Item_Count to iCnt          // add to array
9449>>>>>>>           Set Value item iCnt to iField   // Pos   = field#
9450>>>>>>>           Set Value item (iCnt+1) to hFld // Pos+1 = field object
9451>>>>>>>           Delegate Get In_Use_State to bInUse
9453>>>>>>>           If bInUse Begin
9455>>>>>>>               Delegate Send Refind_Records
9457>>>>>>>               Delegate Get HasRecord to bHasRecord
9459>>>>>>>               // updating the newly created field with the file buffer contents we don't
9459>>>>>>>               // want to change the field's changed state, which might have been set already.
9459>>>>>>>               Send FieldRefresh of hFld (not(bHasRecord)) False
9460>>>>>>>           End
9460>>>>>>>>
9460>>>>>>>        End
9460>>>>>>>>
9460>>>>>>>    End_Procedure
9461>>>>>>>
9461>>>>>>>    // update all extended fields. Field buffer <-- DD buffer
9461>>>>>>>    Procedure ExtendedFieldsUpdate integer bSave
9463>>>>>>>        integer iItm iCnt
9463>>>>>>>        Get Item_Count to iCnt
9464>>>>>>>        Move 0 to iItm
9465>>>>>>>        While iItm lt iCnt
9469>>>>>>>            Increment iItm
9470>>>>>>>            Send FieldUpdate to (Value(self,iItm)) bSave
9471>>>>>>>            Increment iItm
9472>>>>>>>        Loop
9473>>>>>>>>
9473>>>>>>>    End_procedure
9474>>>>>>>
9474>>>>>>>    // refresh all extended fields. Field buffer --> DD buffer
9474>>>>>>>    Procedure ExtendedFieldsRefresh Boolean bCleared
9476>>>>>>>        integer iItm iCnt
9476>>>>>>>        Get Item_Count to iCnt
9477>>>>>>>        Move 0 to iItm
9478>>>>>>>        While iItm lt iCnt
9482>>>>>>>            Increment iItm
9483>>>>>>>            Send FieldRefresh to (Value(self,iItm)) bCleared True
9484>>>>>>>            Increment iItm
9485>>>>>>>        Loop
9486>>>>>>>>
9486>>>>>>>    End_procedure
9487>>>>>>>
9487>>>>>>>    //
9487>>>>>>>    // these are sent from the child field object. We need to direct them
9487>>>>>>>    // to the DDO (the parent).
9487>>>>>>>    Procedure set Field_Changed_State integer iField integer bState
9489>>>>>>>       Delegate Set Field_Changed_state iField to bState
9491>>>>>>>    end_procedure
9492>>>>>>>
9492>>>>>>>    Function Field_Changed_State integer iField returns integer
9494>>>>>>>       integer bState
9494>>>>>>>       Delegate get Field_Changed_state iField to bState
9496>>>>>>>       Function_return bState
9497>>>>>>>    end_function
9498>>>>>>>
9498>>>>>>>    Procedure File_Field_AutoFind integer iFile integer iField integer iMode
9500>>>>>>>       delegate send File_field_AutoFind iFile iField iMode
9502>>>>>>>    End_procedure
9503>>>>>>>
9503>>>>>>>    Procedure Destroy_Object
9505>>>>>>>       delegate set Field_Objects to 0
9507>>>>>>>       Forward Send Destroy_object
9509>>>>>>>    End_Procedure
9510>>>>>>>
9510>>>>>>>End_Class
9511>>>>>>>
9511>>>>>>>
9511>>>>>>>
9511>>>>>>>
9511>>>>>>>
9511>>>>>>>
9511>>>>>>>
9511>>>>>>>
9511>>>>>>>
9511>>>>>>>
9511>>>>>>>
9511>>>>>>>
9511>>>>>>>
9511>>>>>>>
9511>>>>>>>
9511>>>>>>>
9511>>>>>>>
9511>>>>>>>
9511>>>>>>>
9511>>>>>>>
9511>>>>>>>
9511>>>>>>>
9511>>>>>>>
9511>>>>>>>
9511>>>>>>>
9511>>>>>>>
9511>>>>>>>
9511>>>>>>>
9511>>>>>>>
9511>>>>>>>
9511>>>>>>>
9511>>>>>>>
9511>>>>>>>
9511>>>>>>>
9511>>>>>>>
9511>>>>>>>
9511>>>>>>>
9511>>>>>>>
9511>>>>>>>
9511>>>>>>>
9511>>>>>>>
9511>>>>>>>
9511>>>>>>>
9511>>>>>>>
9511>>>>>>>
9511>>>>>>>
9511>>>>>>>
9511>>>>>>>
9511>>>>>>>
9511>>>>>>>
9511>>>>>>>
9511>>>>>>>
9511>>>>>>>
9511>>>>>>>
9511>>>>>>>
9511>>>>>>>
9511>>>>>>>
9511>>>>>>>
9511>>>>>>>
9511>>>>>>>
9511>>>>>>>
9511>>>>>>>
9511>>>>>>>
9511>>>>>>>
9511>>>>>>>
9511>>>>>>>
9511>>>>>>>
9511>>>>>>>
9511>>>>>>>
9511>>>>>>>
9511>>>>>>>
9511>>>>>>>
9511>>>>>>>
9511>>>>>>>
9511>>>>>>>
9511>>>>>>>
9511>>>>>>>
9511>>>>>>>
9511>>>>>>>
9511>>>>>>>
9511>>>>>>>
9511>>>>>>>
9511>>>>>>>
9511>>>>>>>
9511>>>>>>>
9511>>>>>>>
9511>>>>>>>
9511>>>>>>>
9511>>>>>>>
9511>>>>>                 // for text and binary. Must support Address Type
9511>>>>>
9511>>>>>//**************************************************************************//
9511>>>>>//                                                                          //
9511>>>>>// RECORD_BUFFER                                                            //
9511>>>>>//                                                                          //
9511>>>>>// Every data_set will have a object based on this class. It will hold      //
9511>>>>>// the values for the fields, the entry_options and the messages IDs of the //
9511>>>>>// iEntry, iExit and iValidate messages for each field.                     //
9511>>>>>// It is assumed that an object of this class will always be used as a      //
9511>>>>>// child object of a Data_Set object.                                       //
9511>>>>>//                                                                          //
9511>>>>>// Currently the fieldtypes Overlap, Text and Binary are *not* supported.   //
9511>>>>>//                                                                          //
9511>>>>>// ITEM-PROPERTY   ASSIGNED-FUNCTION                                        //
9511>>>>>//                                                                          //
9511>>>>>// Value           The value of the field. Will be updated whenever the     //
9511>>>>>//                 value of a field changes due to data-entry or a found    //
9511>>>>>//                 record.                                                  //
9511>>>>>// Data_File       Contains the filenumber. Is the same for every item.     //
9511>>>>>// Data_Field      Contains the fieldnumber for the item. Is equal to the   //
9511>>>>>//                 items' itemnumber.                                       //
9511>>>>>// Item_Options    Used to store the standard item-options of a field.      //
9511>>>>>// Aux_Value       Used to store the foreign-item-options of a field.       //
9511>>>>>//                                                                          //
9511>>>>>//**************************************************************************//
9511>>>>>
9511>>>>>Class Record_Buffer is an cm_Entrylist
9512>>>>>
9512>>>>>
9512>>>>>  Procedure Construct_Object
9514>>>>>    Forward Send Construct_Object
9516>>>>>    Property Boolean[] pFieldNoPutOverrides
9517>>>>>  End_Procedure
9518>>>>>
9518>>>>>  //************************************************************************//
9518>>>>>  // End_Construct_Object.                                                  //
9518>>>>>  // Make sure this object cannot be activated implicitely or explicitely.  //
9518>>>>>  //************************************************************************//
9518>>>>>
9518>>>>>  Procedure End_Construct_Object
9520>>>>>    Forward Send End_Construct_Object
9522>>>>>    Set Focus_Mode to NO_ACTIVATE
9523>>>>>  End_Procedure
9524>>>>>
9524>>>>>
9524>>>>>
9524>>>>>  //************************************************************************//
9524>>>>>  // Create_Items.                                                          //
9524>>>>>  // This procedure will be called from the Data_Set when the Main_File is  //
9524>>>>>  // being set. It will create an item for each field of the file in this   //
9524>>>>>  // object. Fields of the types DF_OVERLAP, DF_TEXT and DF_BINARY are      //
9524>>>>>  // currently not added.                                                   //
9524>>>>>  //************************************************************************//
9524>>>>>
9524>>>>>  Procedure Create_Items Integer iFile
9526>>>>>    Integer iField_Count
9526>>>>>    Integer iField_Type
9526>>>>>    Integer iField
9526>>>>>    Boolean bRecnumTable
9526>>>>>
9526>>>>>    Get_Attribute DF_FILE_RECNUM_TABLE Of iFile To bRecnumTable
9529>>>>>    Get_Attribute DF_FILE_NUMBER_FIELDS of iFile to iField_Count
9532>>>>>    Send Delete_Data
9533>>>>>    For iField from 0 to iField_Count
9539>>>>>>
9539>>>>>      Send Add_Item MSG_None ""
9540>>>>>      Get_Attribute DF_FIELD_TYPE of iFile iField to iField_Type
9543>>>>>      If (iField_Type<>DF_TEXT and iField_Type<>DF_BINARY and iField_Type<>DF_OVERLAP) Begin // if not text, binary or overlap
9545>>>>>        // only setup field 0 is there is one
9545>>>>>        If ((iField <> 0) or (bRecnumTable)) Begin
9547>>>>>          Set Data_File  iField to iFile
9548>>>>>          Set Data_Field iField to iField
9549>>>>>        End
9549>>>>>>
9549>>>>>      end
9549>>>>>>
9549>>>>>    Loop
9550>>>>>>
9550>>>>>    Send ClearNoPutArray
9551>>>>>  End_Procedure
9552>>>>>  
9552>>>>>  // this clears the noput override array and must be called each time a record is found or cleared
9552>>>>>  Procedure ClearNoPutArray
9554>>>>>    Integer iFields
9554>>>>>    Boolean[] FieldNoPutOverrides
9555>>>>>    Get Item_Count to iFields
9556>>>>>    Set pFieldNoPutOverrides to (ResizeArray(FieldNoPutOverrides,iFields+1,0))
9557>>>>>  End_Procedure
9558>>>>>  
9558>>>>>  // set this field as NoPutOverride. This happens when a NoPut field is entered into the bufer. This will usually happen
9558>>>>>  // with foreign_field DD_Index (default is NoPut). We need to update the buffer so a find will work but we need to know
9558>>>>>  // that this update should not be used during a save. See Entry_Update_Data_Sets.
9558>>>>>  Procedure SetNoPutOverride Integer iField
9560>>>>>      Boolean[] FieldNoPutOverrides
9561>>>>>      Get pFieldNoPutOverrides to FieldNoPutOverrides          
9562>>>>>      Move True to FieldNoPutOverrides[iField]
9563>>>>>      Set pFieldNoPutOverrides to FieldNoPutOverrides          
9564>>>>>  End_Procedure
9565>>>>>
9565>>>>>
9565>>>>>  
9565>>>>>  
9565>>>>>  // when an alias is created, we want to clear any values that will not be applied to
9565>>>>>  // this alias DD such as prompt and zoom objects (which would point to the superclass master)
9565>>>>>  Procedure ReDefineAliasItems Integer iFile
9567>>>>>    Integer i iItems
9567>>>>>    Integer iDFile
9567>>>>>
9567>>>>>    Get item_count to iItems
9568>>>>>    For i from 0 to (iItems-1)
9574>>>>>>
9574>>>>>      Get Data_File i to iDFile
9575>>>>>      If iDFile Begin
9577>>>>>          Set Data_File i to iFile
9578>>>>>          Set Prompt_Object i to 0
9579>>>>>          Set Zoom_Object i to 0
9580>>>>>      End
9580>>>>>>
9580>>>>>    Loop
9581>>>>>>
9581>>>>>  End_Procedure
9582>>>>>  
9582>>>>>
9582>>>>>  //************************************************************************//
9582>>>>>  // New_Current_Record.                                                    //
9582>>>>>  // This procedure will be called from the parent Data_Set whenever the    //
9582>>>>>  // Data_Set changes its Current_Record property, or after a Save, Delete  //
9582>>>>>  // or Clear operation.                                                    //
9582>>>>>  // We use this event to store the values of the fields in our local       //
9582>>>>>  // record buffer.                                                         //
9582>>>>>  //************************************************************************//
9582>>>>>
9582>>>>>  Procedure OnNewCurrentRecord RowId riOld RowId riNew
9584>>>>>    Integer iMain_File
9584>>>>>    Integer iOldState
9584>>>>>    tDDRemembered[] DefaultValues
9584>>>>>    tDDRemembered[] DefaultValues
9585>>>>>    Boolean bRetain
9585>>>>>    Integer iFld iFlds iIndex
9585>>>>>    Handle hoDD
9585>>>>>
9585>>>>>    Get Parent to hoDD
9586>>>>>    Delegate Get Main_File to iMain_File
9588>>>>>    
9588>>>>>    If not (IsNullRowId(riNew)) ;      Send Entry_Display iMain_File TRUE // TRUE means DisplayAll
9591>>>>>    Else Begin
9592>>>>>        
9592>>>>>      // if we have any 17.0 Remember last value items, we must add those items to our array
9592>>>>>      // only do this if this is the operation origin or a parent (i.e., skip if a child DDO)
9592>>>>>      If ( ( (Operation_Origin=hoDD) or ( OPERATION_ORIGIN and (Which_data_set(Operation_Origin,iMain_File)<>0) ) ) ) Begin
9594>>>>>          Get pDDDefaults to DefaultValues
9595>>>>>          Move (SizeOfArray(DefaultValues)) to iFlds
9596>>>>>          For iFld from 0 to (iFlds-1)
9602>>>>>>
9602>>>>>              Move (DefaultValues[iFld].sDefault=DD_RememberLast) to bRetain // if this is a dynamically assigned remember-last
9603>>>>>// I don't think this test is needed              
9603>>>>>//              // if a parent DD and not allow-foreign we want to ignore this if this is not an indexed field (for autofind)
9603>>>>>//              If ( bRetain and (Operation_Origin<>hoDD) and not(Allow_Foreign_New_Save_State(hoDD))) Begin
9603>>>>>//                 Get_Attribute DF_FIELD_INDEX of iMain_File DefaultValues[iFld].iField to iIndex
9603>>>>>//                 Move (iIndex<>0) to bRetain
9603>>>>>//              End
9603>>>>>              If bRetain Begin
9605>>>>>                  Get Value DefaultValues[iFld].iField to DefaultValues[iFld].sLastValue
9606>>>>>              End
9606>>>>>>
9606>>>>>              Else Begin
9607>>>>>                  Move '' to DefaultValues[iFld].sLastValue
9608>>>>>              End
9608>>>>>>
9608>>>>>          Loop  
9609>>>>>>
9609>>>>>          Set pDDDefaults to DefaultValues
9610>>>>>      End
9610>>>>>>
9610>>>>>      
9610>>>>>      // we must do this to make retains not set changed_state
9610>>>>>      Delegate Get Change_Disabled_State to iOldState
9612>>>>>      Delegate Set Change_Disabled_State to True
9614>>>>>      // if mode is anything other than clear we do a clear all (clear keeps retains, clear all does not)
9614>>>>>      // also do clear-all if the DDO is foreign.
9614>>>>>      If (Operation_mode=MODE_CLEARING and ;           ( (Operation_Origin=parent(Self)) or ;             (Which_data_set(Operation_Origin,iMain_File)<>0) ) ) ;          Send Entry_Clear False // FALSE means ClearedFilesOnly = No
9617>>>>>      Else ;          Send Entry_Clear_all False
9619>>>>>      Delegate Set Change_Disabled_State to iOldState
9621>>>>>      Set Changed_State to False
9622>>>>>    End
9622>>>>>>
9622>>>>>    Send ClearNoPutArray
9623>>>>>  End_Procedure
9624>>>>>
9624>>>>>
9624>>>>>  //************************************************************************//
9624>>>>>  // Procedure Set Changed_State.                                           //
9624>>>>>  // Make sure to set the Changed_State of the Data_Set to TRUE when a      //
9624>>>>>  // field value changes and it's not during the Setting of the Defaults.   //
9624>>>>>  //************************************************************************//
9624>>>>>
9624>>>>>  Procedure Set Changed_State Integer iState
9626>>>>>    integer iNoChange
9626>>>>>    // Server.pkg in dso already knows this property
9626>>>>>    Delegate Get Change_disabled_State to iNoChange
9628>>>>>    If Not iNoChange Begin
9630>>>>>       Forward Set Changed_State to iState
9632>>>>>       //If iState ; // we should always delegate.
9632>>>>>          Delegate Set Changed_State to iState
9634>>>>>    End
9634>>>>>>
9634>>>>>  End_Procedure
9635>>>>>
9635>>>>>  // Augmented to handle non DF databases JJT-8/24/00
9635>>>>>  // Some tables may use some field other then recnum for their record identity.
9635>>>>>  // This will be dfrecnum or some other numeric field. When this happens the DD have
9635>>>>>  // to field buffers for the same value. When an update occurs from the DD to the DB buffer
9635>>>>>  // an update can occur twice. If the values are the same, this does not matter. Else the highest
9635>>>>>  // field value will get the update (not recnum). So if someone changes recnum but not its real field
9635>>>>>  // finding may not work right. The DD is updated when a record is found and the API keeps the two values
9635>>>>>  // the same. If the user changes recnum, the real field does not get changed. That is what we are fixing
9635>>>>>  // here. Note that: 1) this has no effect on Dataflex databases (or any DB that has a 0 field recnum).
9635>>>>>  // 2) this type of update is rarely seen anyway (you have to change just the recnum and perform an entry_update).
9635>>>>>  //
9635>>>>>End_Class // Record_Buffer
9636>>>>>
9636>>>>>
9636>>>>>
9636>>>>>
9636>>>>>//**************************************************************************//
9636>>>>>//                                                                          //
9636>>>>>// FIELD_ATTRIBUTES                                                         //
9636>>>>>//                                                                          //
9636>>>>>// Objects of this class will be used to store all kinds of attributes      //
9636>>>>>// which belong to a field.                                                 //
9636>>>>>//                                                                          //
9636>>>>>// FA_MIN_VALUE                                                             //
9636>>>>>// Used to store the mininum value of field.                                //
9636>>>>>//                                                                          //
9636>>>>>// FA_MAX_VALUE                                                             //
9636>>>>>// Used to store the maximum value of a field.                              //
9636>>>>>//                                                                          //
9636>>>>>// FA_CHECK_VALUE                                                           //
9636>>>>>// Used to store a string which contains all possible values of a field.    //
9636>>>>>//                                                                          //
9636>>>>>// FA_CHECKBOX_TRUE                                                         //
9636>>>>>// Used to store the TRUE value for a checkbox field                        //
9636>>>>>//                                                                          //
9636>>>>>// FA_CHECKBOX_FALSE                                                        //
9636>>>>>// Used to store the FALSE value of a checkbox field                        //
9636>>>>>//                                                                          //
9636>>>>>// FA_TABLE_OBJECT                                                          //
9636>>>>>// Stores object Id of a validation table.                                  //
9636>>>>>//                                                                          //
9636>>>>>// FA_ERROR_MESSAGE                                                         //
9636>>>>>// Used to store a error text which will be shown to a user when a fields   //
9636>>>>>// value violates one of the rules defined for it.                          //
9636>>>>>// This field may contain the special strings @MIN, @MAX and @CHECK. When   //
9636>>>>>// these are used, these will be replaced by the actual value of MIN_VALUE, //
9636>>>>>// MAX_VALUE or CHECK_VALUE.                                                //
9636>>>>>//                                                                          //
9636>>>>>//**************************************************************************//
9636>>>>>
9636>>>>>
9636>>>>>//#REPLACE FA_VALIDATION_TYPE           0
9636>>>>>
9636>>>>>// Validation Types
9636>>>>>Enumeration_List
9636>>>>>   Define FA_VALIDATION_TYPE_NONE
9636>>>>>   Define FA_VALIDATION_TYPE_RANGE
9636>>>>>   Define FA_VALIDATION_TYPE_CHECK
9636>>>>>   Define FA_VALIDATION_TYPE_CHECKBOX
9636>>>>>   Define FA_VALIDATION_TYPE_TABLE
9636>>>>>End_Enumeration_List
9636>>>>>
9636>>>>>
9636>>>>>Class Field_Attributes is a Array
9637>>>>>
9637>>>>>  //************************************************************************//
9637>>>>>  // Construct_object ype                                                   //
9637>>>>>  // Define storage for validation types. Access to storage is private.     //
9637>>>>>  //************************************************************************//
9637>>>>>
9637>>>>>  Procedure Construct_Object
9639>>>>>     Forward Send Construct_Object
9641>>>>>     // Private: This replaces the use of arrays to get at this value. This
9641>>>>>     // allows us to find specific validation types (like checkboxes) more
9641>>>>>     // quickly than scanning an array
9641>>>>>     Property String Private.Validation_Types     ''
9642>>>>>  End_Procedure
9643>>>>>
9643>>>>>  //************************************************************************//
9643>>>>>  // Get/Set Field_Validation_Type                                          //
9643>>>>>  // Returns the extended validation type for the passed field.             //
9643>>>>>  //************************************************************************//
9643>>>>>
9643>>>>>  Function Field_Validation_Type Integer iField Returns Integer
9645>>>>>    Integer iType
9645>>>>>    If iField ;       Move (mid(Private.Validation_Types(self),1,iField)) to iType
9648>>>>>    Else ;       Move FA_VALIDATION_TYPE_NONE to iType
9650>>>>>    Function_Return iType
9651>>>>>  End_Function
9652>>>>>
9652>>>>>  Procedure Set Field_Validation_Type Integer iField String sType
9654>>>>>    Integer iType
9654>>>>>    String sTypes
9654>>>>>    If iField Begin
9656>>>>>       Get Private.Validation_Types to sTypes
9657>>>>>       Set Private.Validation_Types to (Overstrike(sType, sTypes, iField))
9658>>>>>    End
9658>>>>>>
9658>>>>>  End_Procedure
9659>>>>>
9659>>>>>  //************************************************************************//
9659>>>>>  // Create_Items.                                                          //
9659>>>>>  // Set any defaults required by this class when the main file is created. //
9659>>>>>  // Create a string which contains all validation types. Set all to        //
9659>>>>>  // No extended validation type.                                           //
9659>>>>>  //************************************************************************//
9659>>>>>
9659>>>>>  Procedure Create_Items
9661>>>>>     String  sType
9661>>>>>     Integer iCount
9661>>>>>     Delegate Get Field_Count to iCOunt
9663>>>>>     Move FA_VALIDATION_TYPE_NONE to sType
9664>>>>>     Set Private.Validation_Types to (Repeat(sType,iCount))
9665>>>>>  End_Procedure // Create_Items
9666>>>>>
9666>>>>>  //************************************************************************//
9666>>>>>  // Next_Validation_Type                                                   //
9666>>>>>  // Return field number of next field matching the passed validation type. //
9666>>>>>  // Pass validation type and last position checked. Return 0 if no match   //
9666>>>>>  //************************************************************************//
9666>>>>>
9666>>>>>  Function Next_Validation_Type String sType Integer iOffset returns integer
9668>>>>>     string sTypes
9668>>>>>     integer iPos
9668>>>>>     Get Private.Validation_Types to sTypes
9669>>>>>     Pos sType in (mid(sTypes,255,iOffset+1)) to iPos
9671>>>>>>
9671>>>>>     If iPos Add iOffset to iPos
9674>>>>>     Function_Return iPos
9675>>>>>  End_Function
9676>>>>>
9676>>>>>
9676>>>>>  //************************************************************************//
9676>>>>>  // Procedure Set Field_Error                                              //
9676>>>>>  // This procedure will be called by the Extended_Data_Set to set the      //
9676>>>>>  // errornumber and message which will be triggered when it needs to.      //
9676>>>>>  //************************************************************************//
9676>>>>>
9676>>>>>  Procedure Set Field_Error Integer iField Integer iErr String sMsg
9678>>>>>    Integer iBase
9678>>>>>    Move (iField * FA_COUNT) to iBase
9679>>>>>    Set Value (iBase + FA_ERROR_NUMBER) to iErr
9680>>>>>    Set Value (iBase + FA_ERROR_MESSAGE) to sMsg
9681>>>>>  End_Procedure
9682>>>>>
9682>>>>>  //************************************************************************//
9682>>>>>  // Get Field_error_Number                                                 //
9682>>>>>  // Get Field_error_Message                                                //
9682>>>>>  // Used to retreive the error number and message for a particular field   //
9682>>>>>  //************************************************************************//
9682>>>>>
9682>>>>>  Function Field_Error_Number Integer iField Returns Integer
9684>>>>>     Integer iErr
9684>>>>>     Get Value (iField*FA_COUNT + FA_ERROR_NUMBER)  to iErr
9685>>>>>     Function_Return iErr
9686>>>>>  End_Function
9687>>>>>
9687>>>>>  Function Field_Error_Message Integer iField Returns String
9689>>>>>     String sValue
9689>>>>>     Get Value (iField*FA_COUNT + FA_ERROR_MESSAGE) to sValue
9690>>>>>     Function_Return sValue
9691>>>>>  End_Function
9692>>>>>
9692>>>>>
9692>>>>>  //************************************************************************//
9692>>>>>  // Validate_Field                                                         //
9692>>>>>  // This function manages the validation of a field against its extended   //
9692>>>>>  // validations.                                                           //
9692>>>>>  //************************************************************************//
9692>>>>>
9692>>>>>  Function Validate_Field Integer iField Returns Integer
9694>>>>>    Integer iType
9694>>>>>    Integer iResult
9694>>>>>    //Get Integer_Value ((iField * FA_COUNT) + FA_VALIDATION_TYPE) to iType
9694>>>>>    //If Not iType ;
9694>>>>>    //  Function_Return
9694>>>>>    Get Field_Validation_Type iField to iType
9695>>>>>    If iType eq FA_VALIDATION_TYPE_RANGE ;       Get Validate_Field_Range iField to iResult
9698>>>>>    Else If iType eq FA_VALIDATION_TYPE_CHECK ;       Get Validate_Field_Check iField to iResult
9702>>>>>    Else If iType eq FA_VALIDATION_TYPE_CHECKBOX ;       Get Validate_Field_Checkbox iField to iResult
9706>>>>>    Else If iType eq FA_VALIDATION_TYPE_TABLE ;       Get Validate_Field_Table iField to iResult
9710>>>>>    Function_Return iResult
9711>>>>>  End_Function
9712>>>>>
9712>>>>>
9712>>>>>  //************************************************************************//
9712>>>>>  // Field_Fill_List                                                        //
9712>>>>>  // All extended validations know how to send callback messages (iMsg) to  //
9712>>>>>  // the calling object (iObj). This allows external lists to get filled w/ //
9712>>>>>  // the contents of a range. Used by combo boxes, spinners, etc.           //
9712>>>>>  //************************************************************************//
9712>>>>>
9712>>>>>  Procedure Field_Fill_List integer iField integer iObj integer iMsg
9714>>>>>    Integer iType
9714>>>>>    Integer iResult
9714>>>>>    //Get Integer_Value ((iField * FA_COUNT) + FA_VALIDATION_TYPE) to iType
9714>>>>>    //If Not iType ;
9714>>>>>    //  Procedure_Return
9714>>>>>    Get Field_Validation_Type iField to iType
9715>>>>>    If iType eq FA_VALIDATION_TYPE_RANGE ;       Send Field_Fill_List_Field_Range iField iObj iMsg
9718>>>>>    Else If iType eq FA_VALIDATION_TYPE_CHECK ;       Send Field_Fill_List_Field_Check iField iObj iMsg
9722>>>>>    Else If iType eq FA_VALIDATION_TYPE_CHECKBOX ;       Send Field_Fill_List_Field_Checkbox iField iObj iMsg
9726>>>>>    Else If iType eq FA_VALIDATION_TYPE_TABLE ;       Send Field_Fill_List_Field_Table iField iObj iMsg
9730>>>>>  End_Procedure
9731>>>>>
9731>>>>>
9731>>>>>  //************************************************************************//
9731>>>>>  // Field_Table_Object                                                     //
9731>>>>>  // Return the id of the validation table if one exists. Otherwise return  //
9731>>>>>  // a zero.                                                                //
9731>>>>>  //************************************************************************//
9731>>>>>
9731>>>>>  Function Field_Table_Object integer iField Returns integer
9733>>>>>    Integer iType
9733>>>>>    Integer iObj
9733>>>>>    Integer iBase
9733>>>>>    Move (iField * FA_COUNT) to iBase
9734>>>>>    //Get Integer_Value iBase to iType
9734>>>>>    Get Field_Validation_Type iField to iType
9735>>>>>    If iType eq FA_VALIDATION_TYPE_TABLE ;       Get Value (iBase + FA_TABLE_OBJECT) to iObj
9738>>>>>    Function_Return iObj
9739>>>>>  End_Function
9740>>>>>
9740>>>>>
9740>>>>>
9740>>>>>  //************************************************************************//
9740>>>>>  // Procedure Set Field_Value_Range                                        //
9740>>>>>  // Procedure to set the range for a field. It will automatically set the  //
9740>>>>>  // validation type of the field as well.                                  //
9740>>>>>  //************************************************************************//
9740>>>>>
9740>>>>>  Procedure Set Field_Value_Range Integer iField String sMin String sMax
9742>>>>>    Integer iBase
9742>>>>>    Move (iField * FA_COUNT) to iBase
9743>>>>>    Set Value (iBase + FA_MIN_VALUE) to sMin
9744>>>>>    Set Value (iBase + FA_MAX_VALUE) to sMax
9745>>>>>    //Set Value iBase to FA_VALIDATION_TYPE_RANGE
9745>>>>>    Set Field_Validation_Type iField to FA_VALIDATION_TYPE_RANGE
9746>>>>>  End_Procedure
9747>>>>>
9747>>>>>  //************************************************************************//
9747>>>>>  // Validate_Field_Range                                                   //
9747>>>>>  // Function to check a fields value agains a given check string.          //
9747>>>>>  //************************************************************************//
9747>>>>>
9747>>>>>  Function Validate_Field_Range Integer iField Returns Integer
9749>>>>>    String  sMin
9749>>>>>    String  sMax
9749>>>>>    String  sValue
9749>>>>>    Integer iField_Type
9749>>>>>    Integer iResult
9749>>>>>    Integer iFile
9749>>>>>    Integer iBase
9749>>>>>    Move (iField * FA_COUNT) to iBase
9750>>>>>    Get Value (iBase + FA_MIN_VALUE) to sMin
9751>>>>>    Get Value (iBase + FA_MAX_VALUE) to sMax
9752>>>>>    Delegate Get Field_Current_Value iField to sValue
9754>>>>>    Delegate Get Main_File to iFile
9756>>>>>    Get_Attribute DF_FIELD_TYPE of iFile iField to iField_Type
9759>>>>>    Move 0 to iResult
9760>>>>>    If (iField_Type=DF_ASCII) ;      Move (sValue < sMin OR sValue > sMax) to iResult
9763>>>>>    Else If (iField_Type=DF_BCD) ;      Move (Number(sValue) < Number(sMin) OR ;            Number(sValue) > Number(sMax)) to iResult
9767>>>>>    Else If (iField_Type=DF_DATE) ;      Move (Date(sValue) < Date(sMin) OR Date(sValue) > Date(sMax)) to iResult
9771>>>>>    Else If (iField_Type=DF_DATETIME) ;      Move (Cast(sValue,DateTime) < Cast(sMin,DateTime) or Cast(sValue,DateTime) > Cast(sMax,DateTime)) to iResult
9775>>>>>    If iResult Begin
9777>>>>>      Delegate Send Field_Error iField DD_INVALID_RANGE sMin sMax
9779>>>>>      Function_Return 1
9780>>>>>    End
9780>>>>>>
9780>>>>>  End_Function
9781>>>>>
9781>>>>>  //************************************************************************//
9781>>>>>  // Procedure Field_fill_list_Field_Range                                  //
9781>>>>>  // Callback to provide all valid value for this validation.               //
9781>>>>>  // Just call back with the two range values                               //
9781>>>>>  //************************************************************************//
9781>>>>>
9781>>>>>  Procedure Field_Fill_List_Field_Range Integer iField Integer iObj Integer iMsg
9783>>>>>    String  sMin
9783>>>>>    String  sMax
9783>>>>>    Integer iBase
9783>>>>>    Move (iField * FA_COUNT) to iBase
9784>>>>>    Get Value (iBase + FA_MIN_VALUE) to sMin
9785>>>>>    Get Value (iBase + FA_MAX_VALUE) to sMax
9786>>>>>    Send iMsg to iObj 0 sMin '' 0 (NullrowId())
9787>>>>>    Send iMsg to iObj 1 sMax '' 0 (NullrowId())
9788>>>>>  End_Procedure
9789>>>>>
9789>>>>>  //************************************************************************//
9789>>>>>  // Procedure Set Field_Value_Check                                        //
9789>>>>>  // Procedure to set the check for a field. It will automatically set the  //
9789>>>>>  // validation type of the field as well.                                  //
9789>>>>>  //************************************************************************//
9789>>>>>
9789>>>>>  Procedure Set Field_Value_Check Integer iField String sCheck
9791>>>>>    Integer iBase
9791>>>>>    Move (iField * FA_COUNT) to iBase
9792>>>>>    Set Value (iBase + FA_CHECK_VALUE) to sCheck
9793>>>>>    //Set Value iBase to FA_VALIDATION_TYPE_CHECK
9793>>>>>    Set Field_Validation_Type iField to FA_VALIDATION_TYPE_CHECK
9794>>>>>  End_Procedure
9795>>>>>
9795>>>>>
9795>>>>>  //************************************************************************//
9795>>>>>  // Validate_Field_Check                                                   //
9795>>>>>  // Function to check a fields value agains a given check string.          //
9795>>>>>  //************************************************************************//
9795>>>>>
9795>>>>>  Function Validate_Field_Check Integer iField Returns Integer
9797>>>>>    String  sCheck
9797>>>>>    String  sValue
9797>>>>>    Integer iBase
9797>>>>>    Integer iPos
9797>>>>>    Integer iLength
9797>>>>>    Integer iResult
9797>>>>>    Integer iFile
9797>>>>>    Move (iField * FA_COUNT) to iBase
9798>>>>>    Get Value (iBase + FA_CHECK_VALUE) to sCheck
9799>>>>>    Delegate Get Field_Current_Value iField to sValue
9801>>>>>    Delegate Get Main_File to iFile
9803>>>>>    Get_Attribute DF_FIELD_LENGTH of iFile iField to iLength
9806>>>>>    Pad sValue to sValue iLength
9808>>>>>>
9808>>>>>    // Replace the seperation characters with two of them so the user
9808>>>>>    // can't bypass the check by entering a seperation character.
9808>>>>>    Move (Replaces("|", sValue, "||")) to sValue
9809>>>>>    // Report an error if rules are violated.
9809>>>>>    Pos sValue in sCheck to iPos
9811>>>>>>
9811>>>>>    If Not iPos Begin
9813>>>>>      Delegate Send Field_Error iField DD_INVALID_CHECK sCheck
9815>>>>>      Function_Return 1
9816>>>>>    End
9816>>>>>>
9816>>>>>  End_Function
9817>>>>>
9817>>>>>  //************************************************************************//
9817>>>>>  // Procedure Field_fill_list_Field_Check                                  //
9817>>>>>  // Callback to provide all valid value for this validation.               //
9817>>>>>  // Call back with all valid check values                                  //
9817>>>>>  //************************************************************************//
9817>>>>>
9817>>>>>  Procedure Field_Fill_List_Field_Check Integer iField Integer iObj Integer iMsg
9819>>>>>    String  sCheck
9819>>>>>    Integer iBase
9819>>>>>    Integer iPos
9819>>>>>    Integer iItem
9819>>>>>    Move (iField * FA_COUNT) to iBase
9820>>>>>    Get Value (iBase + FA_CHECK_VALUE) to sCheck
9821>>>>>    Append sCheck "|"
9822>>>>>    Pos "|" in sCheck to iPos
9824>>>>>>
9824>>>>>    While iPos
9828>>>>>      If iPos gt 1 Begin
9830>>>>>         Send iMsg to iObj iItem (Left(sCheck,iPos-1)) '' 0 (NullrowId())
9831>>>>>         Increment iItem
9832>>>>>      End
9832>>>>>>
9832>>>>>      Mid sCheck to sCheck 255 (iPos+1)
9835>>>>>>
9835>>>>>      Pos "|" in sCheck to iPos
9837>>>>>>
9837>>>>>    Loop
9838>>>>>>
9838>>>>>  End_Procedure
9839>>>>>
9839>>>>>
9839>>>>>
9839>>>>>  //************************************************************************//
9839>>>>>  // Procedure Set Field_CheckBox_Values                                    //
9839>>>>>  // Procedure to set up a checkbox field. We will store the TRUE and FALSE //
9839>>>>>  // Values in the extended array.                                          //
9839>>>>>  //************************************************************************//
9839>>>>>
9839>>>>>  Procedure Set Field_CheckBox_Values Integer iField String sTrue String sFalse
9841>>>>>    Integer iBase
9841>>>>>    Move (iField * FA_COUNT) to iBase
9842>>>>>    Set Value (iBase + FA_CHECKBOX_TRUE) to sTrue
9843>>>>>    Set Value (iBase + FA_CHECKBOX_FALSE) to sFalse
9844>>>>>    //Set Value iBase to FA_VALIDATION_TYPE_CHECKBOX
9844>>>>>    Set Field_Validation_Type iField to FA_VALIDATION_TYPE_CHECKBOX
9845>>>>>  End_Procedure
9846>>>>>
9846>>>>>
9846>>>>>  //************************************************************************//
9846>>>>>  // Function Field_CheckBox_Value                                          //
9846>>>>>  // Return the Value associated with the field and its select-state.       //
9846>>>>>  //************************************************************************//
9846>>>>>
9846>>>>>  Function Field_CheckBox_Value Integer iField Integer iState returns String
9848>>>>>    Integer iBase
9848>>>>>    Integer iType
9848>>>>>    String sValue
9848>>>>>    Move (iField * FA_COUNT) to iBase
9849>>>>>    //Get Value iBase to iType
9849>>>>>    Get Field_Validation_Type iField to iType
9850>>>>>    If iType ne FA_VALIDATION_TYPE_CHECKBOX ;       Move iState to sValue
9853>>>>>    Else ;       Get Value (iBase + If(iState,FA_CHECKBOX_TRUE,FA_CHECKBOX_FALSE));           to sValue
9855>>>>>    Function_Return sValue
9856>>>>>  End_Function
9857>>>>>
9857>>>>>
9857>>>>>  //************************************************************************//
9857>>>>>  // Function Field_Value_Select_State                                      //
9857>>>>>  // Return the select_state based on the passed value and field            //
9857>>>>>  //************************************************************************//
9857>>>>>
9857>>>>>  Function Field_Value_Select_State Integer iField String sValue Returns integer
9859>>>>>    Integer iBase
9859>>>>>    Integer iType
9859>>>>>    String  sTrue
9859>>>>>    Integer iState
9859>>>>>    Integer iFile
9859>>>>>    Integer iField_Type
9859>>>>>    Move (iField * FA_COUNT) to iBase
9860>>>>>    Get Field_Validation_Type iField to iType
9861>>>>>    Get Value (iBase + FA_CHECKBOX_TRUE) to sTrue
9862>>>>>    If iType ne FA_VALIDATION_TYPE_CHECKBOX ;      Move (Not(sValue=0 OR sValue='')) to iState
9865>>>>>    Else Begin
9866>>>>>      Delegate Get Main_File to iFile
9868>>>>>      Get_Attribute DF_FIELD_TYPE of iFile iField to iField_Type
9871>>>>>      If iField_Type EQ DF_BCD ;         Move (number(sValue)=number(sTrue)) to iState
9874>>>>>      Else ; // DF_ASCII         Move (sValue=sTrue) to iState
9876>>>>>    End
9876>>>>>>
9876>>>>>    Function_Return iState
9877>>>>>  End_Function
9878>>>>>
9878>>>>>
9878>>>>>  //************************************************************************//
9878>>>>>  // Validate_Field_Checkbox
9878>>>>>  // Check that the buffer value is one of the two checkbox values.         //
9878>>>>>  //************************************************************************//
9878>>>>>
9878>>>>>  Function Validate_Field_Checkbox Integer iField Returns Integer
9880>>>>>    String  sTrue
9880>>>>>    String  sFalse
9880>>>>>    String  sValue
9880>>>>>    Integer iField_Type
9880>>>>>    Integer iResult
9880>>>>>    Integer iFile
9880>>>>>    Integer iBase
9880>>>>>    Move (iField * FA_COUNT) to iBase
9881>>>>>    Get Value (iBase + FA_CHECKBOX_TRUE) to sTrue
9882>>>>>    Get Value (iBase + FA_CHECKBOX_FALSE) to sFalse
9883>>>>>    Delegate Get Field_Current_Value iField to sValue
9885>>>>>    Delegate Get Main_File to iFile
9887>>>>>    Get_Attribute DF_FIELD_TYPE of iFile iField to iField_Type
9890>>>>>    Move 0 to iResult
9891>>>>>    If iField_Type EQ DF_BCD ;      Move (Number(sValue)=Number(sTrue) OR ;            Number(sValue)=Number(sFalse)) to iResult
9894>>>>>    Else ; // DF_ASCII      Move (sValue=sTrue OR sValue=sFalse) to iResult
9896>>>>>    If Not iResult Begin
9898>>>>>      Delegate Send Field_Error iField DD_INVALID_CHECKBOX sTrue sFalse
9900>>>>>      Function_Return 1
9901>>>>>    End
9901>>>>>>
9901>>>>>  End_Function
9902>>>>>
9902>>>>>  //************************************************************************//
9902>>>>>  // Procedure Field_fill_list_Field_Checkbox                               //
9902>>>>>  // Callback to provide all valid value for this validation.               //
9902>>>>>  // Just call back with the two true and false values                      //
9902>>>>>  //************************************************************************//
9902>>>>>
9902>>>>>  Procedure Field_Fill_List_Field_Checkbox Integer iField Integer iObj Integer iMsg
9904>>>>>    String  sTrue
9904>>>>>    String  sFalse
9904>>>>>    Integer iBase
9904>>>>>    Move (iField * FA_COUNT) to iBase
9905>>>>>    Get Value (iBase + FA_CHECKBOX_TRUE) to sTrue
9906>>>>>    Get Value (iBase + FA_CHECKBOX_FALSE) to sFalse
9907>>>>>    Send iMsg to iObj 0 sTrue '' 0 (NullrowId())
9908>>>>>    Send iMsg to iObj 1 sFalse '' 0 (NullrowId())
9909>>>>>  End_Procedure
9910>>>>>
9910>>>>>  //************************************************************************//
9910>>>>>  // Procedure Set Field_Value_Table                                        //
9910>>>>>  // The object keeps track of a validation table object. This table object //
9910>>>>>  // can be any type of object must at a minimum understand a small message //
9910>>>>>  // protocol (see xvaltbl.pkg for info)                                    //
9910>>>>>  //************************************************************************//
9910>>>>>
9910>>>>>  Procedure Set Field_Value_Table Integer iField Integer iObj
9912>>>>>    Integer iBase
9912>>>>>    Move (iField * FA_COUNT) to iBase
9913>>>>>    Set Value (iBase + FA_TABLE_OBJECT) to iObj
9914>>>>>    //Set Value iBase to FA_VALIDATION_TYPE_TABLE
9914>>>>>    Set Field_Validation_Type iField to FA_VALIDATION_TYPE_TABLE
9915>>>>>  End_Procedure
9916>>>>>
9916>>>>>  //************************************************************************//
9916>>>>>  // Validate_Field_Table                                                   //
9916>>>>>  // This valdates against a validation table if appropriate (if a table    //
9916>>>>>  // exists and the table's validate_State is T). It validates by passing   //
9916>>>>>  // the message validate_value to the validation table object              //
9916>>>>>  //************************************************************************//
9916>>>>>
9916>>>>>  Function Validate_Field_Table Integer iField Returns Integer
9918>>>>>    integer iBase
9918>>>>>    integer iTableObj
9918>>>>>    String  sValue
9918>>>>>    Integer iResult
9918>>>>>    Move (iField * FA_COUNT) to iBase
9919>>>>>    Get Value (iBase + FA_TABLE_OBJECT) to iTableObj
9920>>>>>    If (iTableObj AND Validate_State(iTableObj) ) Begin
9922>>>>>       Delegate Get Field_Current_Value iField to sValue
9924>>>>>       Get Validate_Value of iTableOBj sValue to iResult
9925>>>>>       If iResult ;          Delegate Send Field_Error iField DD_INVALID_VALUE_TABLE
9929>>>>>    End
9929>>>>>>
9929>>>>>    Function_Return iResult
9930>>>>>  End_Function
9931>>>>>
9931>>>>>
9931>>>>>  //************************************************************************//
9931>>>>>  // Procedure Field_fill_list_Field_table                                  //
9931>>>>>  // Callback to provide all valid value for this validation.               //
9931>>>>>  // Pass the request on to the validation table. This is the most common   //
9931>>>>>  // use of this.                                                           //
9931>>>>>  //************************************************************************//
9931>>>>>
9931>>>>>  Procedure Field_Fill_List_Field_Table Integer iField Integer iObj Integer iMsg
9933>>>>>    integer iBase
9933>>>>>    integer iTableObj
9933>>>>>    Move (iField * FA_COUNT) to iBase
9934>>>>>    Get Value (iBase + FA_TABLE_OBJECT) to iTableObj
9935>>>>>    If iTableObj ;       Send Request_Fill_From_List to iTableObj iObj iMsg
9938>>>>>  End_Procedure
9939>>>>>
9939>>>>>  //************************************************************************//
9939>>>>>  // Procedure Prompt_Object                                                //
9939>>>>>  // Often extended valditation types can provide automatic prompt          //
9939>>>>>  // objects. If the extended type supports a prompt object and there is    //
9939>>>>>  // a global validation_list object, we will use it                        //
9939>>>>>  //************************************************************************//
9939>>>>>
9939>>>>>  Function Prompt_Object Integer iField Returns Integer
9941>>>>>    Integer iType
9941>>>>>    Integer iObj
9941>>>>>    //Get Integer_Value ((iField * FA_COUNT) + FA_VALIDATION_TYPE) to iType
9941>>>>>    Get Field_Validation_Type iField to iType
9942>>>>>    If Not (iType=FA_VALIDATION_TYPE_NONE OR iType=FA_VALIDATION_TYPE_RANGE) ;       Move DD_Global_Validation_Prompt_Object to iObj
9945>>>>>    Function_Return iObj
9946>>>>>  End_Function
9947>>>>>
9947>>>>>
9947>>>>>End_Class
9948>>>>>
9948>>>>>
9948>>>>>
9948>>>>>// use to keep track of file field pairs such as system file file/field
9948>>>>>Struct tDDFileField
9948>>>>>    Integer iFile
9948>>>>>    Integer iField
9948>>>>>End_Struct
9948>>>>>
9948>>>>>Class Field_Mask_Array is an Array
9949>>>>>
9949>>>>>  //************************************************************************//
9949>>>>>  // Get Array_Name: returns string value (and checks for 0)                //
9949>>>>>  //************************************************************************//
9949>>>>>
9949>>>>>  Function Array_Name integer iField integer iType Returns String
9951>>>>>     String sName
9951>>>>>     Move (iField*FMA_COUNT+iType) to iField
9952>>>>>     if (Item_Count(self)>iField) ;        Get value iField to sName
9955>>>>>     // sometimes an array value that is undefined returns a 0, we must change this to ''
9955>>>>>     If sName eq '0' Move '' to sName
9958>>>>>     function_return sName
9959>>>>>  End_Function
9960>>>>>
9960>>>>>
9960>>>>>  //************************************************************************//
9960>>>>>  // Get/Set Field_Mask_Type                                                //
9960>>>>>  //************************************************************************//
9960>>>>>
9960>>>>>  Procedure Set Field_Mask_Type Integer iField integer iType
9962>>>>>     Set Value (iField*FMA_COUNT+FMA_MASK_TYPE) to iType
9963>>>>>  End_procedure
9964>>>>>
9964>>>>>  Function Field_Mask_Type integer iField returns integer
9966>>>>>     integer iType
9966>>>>>     Move (iField*FMA_COUNT+FMA_MASK_TYPE) to iField
9967>>>>>     if (Item_Count(self)>iField) ;        Get value iField to iType
9970>>>>>     function_return iType
9971>>>>>  End_Function
9972>>>>>
9972>>>>>  //************************************************************************//
9972>>>>>  // Get/Set Field_Mask_Value_state                                         //
9972>>>>>  //************************************************************************//
9972>>>>>
9972>>>>>  Procedure Set Field_Mask_Value_State Integer iField integer iState
9974>>>>>     Set Value (iField*FMA_COUNT+FMA_MASK_VALUE_STATE) to iState
9975>>>>>  End_procedure
9976>>>>>
9976>>>>>  Function Field_Mask_Value_State integer iField returns integer
9978>>>>>     integer iState
9978>>>>>     Move (iField*FMA_COUNT+FMA_MASK_VALUE_STATE) to iField
9979>>>>>     if (Item_Count(self)>iField) ;        Get value iField to iState
9982>>>>>     function_return iState
9983>>>>>  End_Function
9984>>>>>
9984>>>>>  //************************************************************************//
9984>>>>>  // Get/Set Field_Mask                                                     //
9984>>>>>  //************************************************************************//
9984>>>>>
9984>>>>>  Procedure Set Field_Mask Integer iField string sMask
9986>>>>>     Set Value (iField*FMA_COUNT+FMA_MASK) to sMask
9987>>>>>  End_procedure
9988>>>>>
9988>>>>>  Function Field_Mask integer iField returns string
9990>>>>>     Function_Return (Array_Name(self,iField,FMA_MASK))
9991>>>>>  End_Function
9992>>>>>
9992>>>>>  //************************************************************************//
9992>>>>>  // Get/Set Field_Label_Short                                               //
9992>>>>>  //************************************************************************//
9992>>>>>
9992>>>>>  Procedure Set Field_Label_Short Integer iField string sName
9994>>>>>     Set Value (iField*FMA_COUNT+FMA_SHORT_NAME) to sName
9995>>>>>  End_procedure
9996>>>>>
9996>>>>>  Function Field_Label_Short integer iField returns string
9998>>>>>     Function_Return (Array_Name(self,iField,FMA_SHORT_NAME))
9999>>>>>  End_Function
10000>>>>>
10000>>>>>  //************************************************************************//
10000>>>>>  // Get/Set Field_Label_Long                                                //
10000>>>>>  //************************************************************************//
10000>>>>>
10000>>>>>  Procedure Set Field_Label_Long Integer iField string sName
10002>>>>>     Set Value (iField*FMA_COUNT+FMA_LONG_NAME) to sName
10003>>>>>  End_procedure
10004>>>>>
10004>>>>>  Function Field_Label_Long integer iField returns string
10006>>>>>     Function_Return (Array_Name(self,iField,FMA_LONG_NAME))
10007>>>>>  End_Function
10008>>>>>
10008>>>>>  //************************************************************************//
10008>>>>>  // Get/Set Field_Class_Name                                               //
10008>>>>>  //************************************************************************//
10008>>>>>
10008>>>>>  Procedure Set Field_Class_Name Integer iField string sName
10010>>>>>     Set Value (iField*FMA_COUNT+FMA_CLASS_NAME) to sName
10011>>>>>  End_procedure
10012>>>>>
10012>>>>>  Function Field_Class_Name integer iField returns string
10014>>>>>     Function_Return (Array_Name(self,iField,FMA_CLASS_NAME))
10015>>>>>  End_Function
10016>>>>>
10016>>>>>
10016>>>>>  //************************************************************************//
10016>>>>>  // Get/Set Field_WebPrompt_Object
10016>>>>>  //************************************************************************//
10016>>>>>
10016>>>>>  Procedure Set Field_WebPrompt_Object Integer iField Handle hoPrompt   
10018>>>>>     Set Value (iField*FMA_COUNT+FMA_WEBPROMPTOBJECT) to hoPrompt
10019>>>>>  End_Procedure
10020>>>>>
10020>>>>>  Function Field_WebPrompt_Object Integer iField Returns Handle
10022>>>>>     Function_Return (Array_Name(Self,iField,FMA_WEBPROMPTOBJECT))
10023>>>>>  End_Function
10024>>>>>
10024>>>>>End_Class
10025>>>>>
10025>>>>>//************************************************************************//
10025>>>>>// This image is used when creating the Record_Buffer object.             //
10025>>>>>// Because the Record_Buffer is based on an Entrylist, it needs to have   //
10025>>>>>// an image.                                                              //
10025>>>>>//************************************************************************//
10025>>>>>
/RECORD_BUFFER
Image 1, RECORD_BUFFER
__
/*
10025>>>>>
10025>>>>>
10025>>>>>//**************************************************************************//
10025>>>>>//                                                                          //
10025>>>>>// EXTENDED_DATA_SET                                                        //
10025>>>>>//                                                                          //
10025>>>>>// This is the extended version of the Data_Set class.                      //
10025>>>>>//                                                                          //
10025>>>>>// It provides the following extra's to the standard Data_Set class:        //
10025>>>>>//                                                                          //
10025>>>>>// - SETTING ITEM-OPTIONS PER FIELD                                         //
10025>>>>>//   These item-options will be used automatically when an DEO is used      //
10025>>>>>//   which recognizes the Extended_Data_Set. You can specify two types of   //
10025>>>>>//   item-options.                                                          //
10025>>>>>//   1. The ones that will be used when the Server of the DEO is the same   //
10025>>>>>//      as the Data_File of the item. We call those the stadard-item-       //
10025>>>>>//      options.                                                            //
10025>>>>>//   2. The ones that will be used when the Server of the DEO is different  //
10025>>>>>//      from the Data_File of the item. We call those options Foreign-      //
10025>>>>>//      item-options.                                                       //
10025>>>>>//                                                                          //
10025>>>>>// - PROTECTING KEY FIELDS                                                  //
10025>>>>>//   You can set the Key_Field_State of a field to true to identify Key-    //
10025>>>>>//   fields. When the property Protect_Key_State is TRUE (Default) then     //
10025>>>>>//   a user will not be able to change the value of a field which has been  //
10025>>>>>//   marked as Key-field from an existing record.                           //
10025>>>>>//                                                                          //
10025>>>>>// - VALIDATING FIELDS                                                      //
10025>>>>>//   A validation message can be set per field. This message will be        //
10025>>>>>//   executed when the Data_Set needs to validate all fields. The message   //
10025>>>>>//   will also be send when a DEO need to validate an item.                 //
10025>>>>>//                                                                          //
10025>>>>>// - FIELD ENTRY AND EXITS MESSAGES                                         //
10025>>>>>//   One can specify a message which has to be send to the Data_Set when    //
10025>>>>>//   a item of a DEO is being entered or exited.                            //
10025>>>>>//                                                                          //
10025>>>>>// Currently the fieldtypes Overlap, Text and Binary are *not* supported.   //
10025>>>>>//                                                                          //
10025>>>>>// PROPERTIES                                                               //
10025>>>>>//                                                                          //
10025>>>>>//   EXISTING_KEY_VALUE                                                     //
10025>>>>>//   This property will hold the complete value of all the fields which     //
10025>>>>>//   have been flagged to be a key-field. It is used to check if a user     //
10025>>>>>//   has changed one of the fields which make up the key for a record.      //
10025>>>>>//                                                                          //
10025>>>>>//   PROTECT_KEY_STATE                                                      //
10025>>>>>//   When this property is TRUE, is will force a key to be read-only. A     //
10025>>>>>//   transaction will be aborted when this Data_Set detects that a key      //
10025>>>>>//   value for an existing record has been changed.                         //
10025>>>>>//                                                                          //
10025>>>>>//   KEY_FIELDS                                                             //
10025>>>>>//   This property contains a comma separated list of all fieldnumbers      //
10025>>>>>//   which have been marked to be part of a key. This list is not sorted    //
10025>>>>>//   and should be considered read-only.                                    //
10025>>>>>//                                                                          //
10025>>>>>//   FOREIGN_FIELD_OPTIONS PRIVATE                                          //
10025>>>>>//   This property hold the fields' item-options which are copied to a      //
10025>>>>>//   DEO item when this field is used as a foreign (related) field.         //
10025>>>>>//   These options will be applied for fields which are not part of an      //
10025>>>>>//   index.                                                                 //
10025>>>>>//                                                                          //
10025>>>>>//   FOREIGN_KEY_FIELD_OPTIONS PRIVATE                                      //
10025>>>>>//   See Foreign_Field_Options.                                             //
10025>>>>>//   These options will be applied for fields which are part of the key.    //
10025>>>>>//                                                                          //
10025>>>>>//   FOREIGN_INDEX_FIELD_OPTIONS PRIVATE                                    //
10025>>>>>//   See Foreign_Field_Options.                                             //
10025>>>>>//   These options will be applied for fields which are part of an index,   //
10025>>>>>//   but not of a key.                                                      //
10025>>>>>//                                                                          //
10025>>>>>//**************************************************************************//
10025>>>>>
10025>>>>>Class DataDictionary is a DataSet
10026>>>>>
10026>>>>>  //************************************************************************//
10026>>>>>  // Construct_Object.                                                      //
10026>>>>>  // Augmented to set the Focus_Mode to NO_ACTIVATE. If we don't do this,   //
10026>>>>>  // the object might try to take the focus.                                //
10026>>>>>  //************************************************************************//
10026>>>>>
10026>>>>>  Procedure Construct_Object Integer iImage
10028>>>>>    Forward Send Construct_Object No_Image //iImage
10030>>>>>
10030>>>>>    Property String  Existing_Key_Value                           ""
10031>>>>>    Property Integer Protect_Key_State                            True
10032>>>>>
10032>>>>>    Property String  Key_Fields                                   ""
10033>>>>>
10033>>>>>    // Used to store default foreign item-options.
10033>>>>>    Property Integer private.Foreign_Field_Options                0
10034>>>>>
10034>>>>>    // Used to store default foreign item-options for key field.
10034>>>>>    Property Integer private.Foreign_Key_Field_Options            0
10035>>>>>
10035>>>>>    // Used to store default foreign item-options for non-key index field.
10035>>>>>    Property Integer private.Foreign_Index_Field_Options          0
10036>>>>>
10036>>>>>    // These are added to support the checking of DSO connections
10036>>>>>    // during deletes and saves. Only the first two properties are Public
10036>>>>>    Property Integer Validate_Save_Structure_Mode   DD_Validate_Structure_Once
10037>>>>>    Property Integer Validate_Delete_Structure_Mode DD_Validate_Structure_Once
10038>>>>>    Property Integer Save_Structure_Validated_State              False
10039>>>>>    Property Integer Cascade_Delete_Structure_Validated_State    False
10040>>>>>    Property Integer No_Cascade_Delete_Structure_Validated_State False
10041>>>>>
10041>>>>>    Property Integer Last_Mark_Sequence_Id                       0
10042>>>>>
10042>>>>>    // These are added for optimized traversal of
10042>>>>>    // entry-update and validation and maybe more
10042>>>>>    Property String  Visited_Fields          ""
10043>>>>>    Property Integer Visited_State           False
10044>>>>>
10044>>>>>    // these are set by the define_auto_increment, which is obsolete and has been replaced
10044>>>>>    // the Set Field_auto_increment method. 
10044>>>>>    Property Integer Auto_Increment_Source_File  0
10045>>>>>    Property Integer Auto_Increment_Source_Field 0
10046>>>>>    Property Integer Auto_Increment_Dest_Field   0
10047>>>>>    
10047>>>>>    // used by the set Field_auto_increment method
10047>>>>>    // these are split into two arrays to make searching for the field easier
10047>>>>>    // the arrays should always be synched.
10047>>>>>    Property Integer[] pAutoIncrementFields
10048>>>>>    Property tDDFileField[] pAutoIncrementSysFileFields
10049>>>>>
10049>>>>>    // Error Reporting Related
10049>>>>>    // If DD_Error_No_Report errors would be supressed (only ERR gets set)
10049>>>>>    Property Integer Error_Report_Mode           DD_Error_Report
10050>>>>>
10050>>>>>    // During validation, this is the field being validated.
10050>>>>>    Property integer Current_Validate_Field      0
10051>>>>>
10051>>>>>    // when errors are redirected locally this maintains the original handler.
10051>>>>>    Property integer Old_Error_Object_Id         0
10052>>>>>
10052>>>>>    // Must be provided if local error handler is to be created
10052>>>>>    Property integer Error_Processing_State      0
10053>>>>>
10053>>>>>    // These should be changed most carefully and possible only and the
10053>>>>>    // DSO level. These allow you to defeat full field validation which
10053>>>>>    // makes it easier to corrupt data! Validate_DEO_Only_State limits
10053>>>>>    // save validation to DEOs (which is what data-sets have always done).
10053>>>>>    // Validate_foreign_File_State will skip validation under the following
10053>>>>>    // conditions: 1) DSO if for a parent (it did not originate the save).
10053>>>>>    //
10053>>>>>    Property Integer Validate_DEOs_Only_State    False
10054>>>>>    Property Integer Validate_Foreign_File_State True
10055>>>>>    // if set true, a field validation requested started with this
10055>>>>>    // DD will check all fields, even in an error is encountered
10055>>>>>    Property Integer Validate_All_Fields_State   False
10056>>>>>
10056>>>>>    // If true, all entry updates will occur through the DD. Else
10056>>>>>    // saves occur through the DD and find occur through the DEOs
10056>>>>>    Property Integer EntryUpdateLocalState True // changed from false to true in 17.0
10057>>>>>
10057>>>>>    // can be used by Refind_records method (remote refind of recs). Obsolete. Use Find_RowId
10057>>>>>    Property integer Find_Record_Id 0
10058>>>>>
10058>>>>>    // can be used by Refind_records method (remote refind of recs)
10058>>>>>    Property RowId Find_RowId (NullRowId())
10059>>>>>
10059>>>>>    // Private: Id of field_objects container. This is not created until needed
10059>>>>>    Property Integer Field_Objects 0
10060>>>>>
10060>>>>>    // Public: If set the DDO will never be foreign, allowing
10060>>>>>    // you to create new parents when a child is saved. This would
10060>>>>>    // normally only be set within the DDO and not the class. This would be
10060>>>>>    // used where a child table wants to save the parent (header) when the
10060>>>>>    // first child is saved. It would disable the foreign key and index
10060>>>>>    // find_Req and required settings (as well as any displayonly).
10060>>>>>    Property Integer Allow_Foreign_New_Save_State False
10061>>>>>
10061>>>>>    // This makes the attach use the DD structure instead of just doing an attach
10061>>>>>    // on all open files. Existing programs should work fine with this. If they don't,
10061>>>>>    // you can reset this in your class (although it would be smarter to find out why it
10061>>>>>    // is not working.
10061>>>>>    Property Integer pbDDAttach True
10062>>>>>
10062>>>>>    // If this is an alias file, this is the master file it is based on
10062>>>>>    Property Handle piMasterTable 0
10063>>>>>
10063>>>>>    Property tDDServerInformation[] pServerInformation
10064>>>>>
10064>>>>>    Property tDDRemembered[] pDDDefaults
10065>>>>>
10065>>>>>    Property Boolean pbInSuperFind False
10066>>>>>
10066>>>>>    // Create the local buffer.
10066>>>>>    Object Record_Buffer is a Record_Buffer
10068>>>>>    End_Object
10069>>>>>
10069>>>>>    // Create the extended field attributes array.
10069>>>>>    Object Field_Attributes is a Field_Attributes
10071>>>>>    End_Object
10072>>>>>
10072>>>>>    // Create an array to maintain Status help values for each field
10072>>>>>    Object Statushelp_Array is an array
10074>>>>>    end_object
10075>>>>>
10075>>>>>    Object FieldMask_Array is an Field_Mask_array
10077>>>>>    end_object
10078>>>>>
10078>>>>>
10078>>>>>    // keep track of all system/unknown files that must be set to
10078>>>>>    // default for smart file mode to work right.
10078>>>>>    Object System_File_obj is an Array
10080>>>>>    End_Object
10081>>>>>    
10081>>>>>    // used during Request_Validate
10081>>>>>    Property Handle[] pDDsWithFindReqErrors
10082>>>>>
10082>>>>>    //Set Focus_Mode to NO_ACTIVATE
10082>>>>>
10082>>>>>    Set Smart_FileMode_State to True  // extended DSOs should default to
10083>>>>>                                      // true
10083>>>>>    Send Define_Fields // Developer Hook - define all field rules
10084>>>>>  End_Procedure
10085>>>>>
10085>>>>>//  // NEW: Returns true if record is active in DD. This is more intuitive than using the current record/rowid
10085>>>>>//  //Doc/ Visibility=Public
10085>>>>>//  Function HasRecord Returns Boolean
10085>>>>>//      Function_Return (Not(IsNullRowId(CurrentRowId(self))))
10085>>>>>//  End_Function
10085>>>>>
10085>>>>>  //************************************************************************//
10085>>>>>  // Extended_DSO_State                                                     //
10085>>>>>  // Returns 1 to indicate that this is a DD class.                         //
10085>>>>>  //************************************************************************//
10085>>>>>
10085>>>>>  Function Extended_DSO_State Returns Integer
10087>>>>>     Function_Return 1
10088>>>>>  End_Function // Extended_DSO_State
10089>>>>>
10089>>>>>
10089>>>>>  //************************************************************************//
10089>>>>>  // Define_Fields                                                          //
10089>>>>>  // Used to set up all XDS functions and rules. Called by construct_object //
10089>>>>>  // and considered a bit more user friendly.                               //
10089>>>>>  //************************************************************************//
10089>>>>>
10089>>>>>  Procedure Define_Fields
10091>>>>>  End_Procedure
10092>>>>>
10092>>>>>
10092>>>>>
10092>>>>>  //************************************************************************//
10092>>>>>  // Set Main_File.                                                         //
10092>>>>>  // This message has been augmented to create a local recordbuffer for a   //
10092>>>>>  // file. We cannot do this earlier because we need the file to count the  //
10092>>>>>  // number of necessary fields.                                            //
10092>>>>>  //************************************************************************//
10092>>>>>
10092>>>>>  Procedure Set Main_File Integer iFile
10094>>>>>    Integer iCurrent_File iMaster
10094>>>>>    Get piMasterTable to iMaster
10095>>>>>    If iMaster Begin
10097>>>>>        // is an alias condition
10097>>>>>        Forward Set Main_File to iFile
10099>>>>>        Send ReDefineAliasItems to (Record_Buffer(Self)) iFile
10100>>>>>    End
10100>>>>>>
10100>>>>>    Else If iFile Begin
10103>>>>>      Get Main_File to iCurrent_File
10104>>>>>      If (iCurrent_File AND iCurrent_File <> iFile) Begin
10106>>>>>        Send Data_Set_Error -1 DFERR_PROGRAM DD_CANNOT_CHANGE_MAIN_FILE
10107>>>>>        Procedure_Return
10108>>>>>      End
10108>>>>>>
10108>>>>>      Forward Set Main_File to iFile
10110>>>>>      Send Create_Items to (Record_Buffer(self)) iFile
10111>>>>>      Send Create_Items to (Field_Attributes(self))
10112>>>>>    End
10112>>>>>>
10112>>>>>  End_Procedure
10113>>>>>
10113>>>>>
10113>>>>>
10113>>>>>  //************************************************************************//
10113>>>>>  // Set Key_Field_State                                                    //
10113>>>>>  // This procedure will update the Key_Fields property to include or       //
10113>>>>>  // excluded the fieldnumber passed in the list of fieldnumbers which make //
10113>>>>>  // up an keyvalue.                                                        //
10113>>>>>  //************************************************************************//
10113>>>>>
10113>>>>>  Procedure Set Key_Field_State Integer iField Integer iState
10115>>>>>    String  sKeys
10115>>>>>    Get Key_Fields to sKeys
10116>>>>>    Set Key_Fields to (Overstrike(If(iState, "X", " "), sKeys, iField))
10117>>>>>  End_Procedure
10118>>>>>
10118>>>>>
10118>>>>>
10118>>>>>  //************************************************************************//
10118>>>>>  // Function Key_Field_State                                               //
10118>>>>>  // Will return TRUE if the field passed has been defined as a key.        //
10118>>>>>  //************************************************************************//
10118>>>>>
10118>>>>>  Function Key_Field_State Integer iField Returns Integer
10120>>>>>    String sKeys
10120>>>>>    Get Key_Fields to sKeys
10121>>>>>    Function_Return (Mid(sKeys, 1, iField) <> " ")
10122>>>>>  End_Function
10123>>>>>
10123>>>>>  //************************************************************************//
10123>>>>>  // Function Key_Value                                                     //
10123>>>>>  // Returns complete key value.                                            //
10123>>>>>  //************************************************************************//
10123>>>>>
10123>>>>>  Function Key_Value Returns String
10125>>>>>    String  sKeys
10125>>>>>    String  sKey_Value
10125>>>>>    String  sValue
10125>>>>>    Integer iField
10125>>>>>    Get Key_Fields to sKeys
10126>>>>>    Move "" to sKey_Value
10127>>>>>    Repeat
10127>>>>>>
10127>>>>>      Pos "X" in sKeys to iField
10129>>>>>>
10129>>>>>      If iField Begin
10131>>>>>        Get Field_Current_Value iField to sValue
10132>>>>>        Append sKey_Value sValue
10133>>>>>        Move (Overstrike(" ", sKeys, iField)) to sKeys
10134>>>>>      End
10134>>>>>>
10134>>>>>    Until Not iField
10136>>>>>    Function_Return sKey_Value
10137>>>>>  End_Function
10138>>>>>
10138>>>>>  //************************************************************************//
10138>>>>>  // New_Current_Record.                                                    //
10138>>>>>  // This procedure will be called whenever the Data_Set changes its        //
10138>>>>>  // Current_Record property, or after a Save, Delete or Clear operation.   //
10138>>>>>  // We send this message to the Record_Buffer object to update its values. //
10138>>>>>  //************************************************************************//
10138>>>>>
10138>>>>>  Procedure New_Current_Record integer iOld integer iNew
10140>>>>>     // does nothing, but exists if developer is using this for some purpose. Is called after
10140>>>>>     // OnNewCurrentRecord (if recnum based table)
10140>>>>>  End_Procedure
10141>>>>>
10141>>>>>  Procedure OnNewCurrentRecord RowId riOld RowId riNew
10143>>>>>    Integer iObj
10143>>>>>    Integer iOldst
10143>>>>>    Integer iFoc
10143>>>>>    Integer iIsExt
10143>>>>>    Forward Send OnNewCurrentRecord riOld riNew
10145>>>>>    Move (Record_Buffer(self)) to iObj
10146>>>>>    If iObj Begin
10148>>>>>       Send OnNewCurrentRecord of iObj riOld riNew
10149>>>>>       // must also refresh all defined extended fields
10149>>>>>       Send ExtendedFieldsRefresh (IsNullRowId(riNew)) // pass bCleared (true if a clear)
10150>>>>>       Get Focus of Desktop to iFoc
10151>>>>>       Get Extended_DEO_State of iFoc to iIsExt     // if focus is deo item
10152>>>>>       If iIsExt Begin                               // disable the state so
10154>>>>>          Get Entry_Refresh_State of iFoc to iOldSt // value will come
10155>>>>>          set Entry_Refresh_State of iFoc to True   // from Local buffer.
10156>>>>>       End
10156>>>>>>
10156>>>>>       Set Existing_Key_Value to (Key_Value(self))
10157>>>>>       If iIsExt ;          Set Entry_Refresh_State of iFoc to iOldSt
10160>>>>>       // Only set defaults when the record is new
10160>>>>>       If (IsNullRowId(riNew)) Send Prepare_Default_Values
10163>>>>>    End
10163>>>>>>
10163>>>>>  End_Procedure
10164>>>>>
10164>>>>>  //************************************************************************//
10164>>>>>  // Procedure Prepare_Default_Values                                       //
10164>>>>>  // Shuts off change mode and sends initialize_default_values which is     //
10164>>>>>  // a user hook routine.                                                   //
10164>>>>>  //************************************************************************//
10164>>>>>
10164>>>>>    Procedure Prepare_Default_Values
10166>>>>>        Integer iOldState
10166>>>>>        Get Change_disabled_State to iOldState
10167>>>>>        Set Change_disabled_State to True
10168>>>>>        Send Private_Field_Defaults
10169>>>>>        // set defaults if this is the main DDO or the DDO is
10169>>>>>        // flagged as supporting saving new records when foreign (a parent)
10169>>>>>        If (Operation_Origin=Self or ;         Allow_Foreign_New_Save_State(Self)) ;           Send Field_Defaults
10172>>>>>        Send AssignDynamicDefaults
10173>>>>>        Set Change_disabled_State to iOldState
10174>>>>>    End_Procedure
10175>>>>>    
10175>>>>>
10175>>>>>  //************************************************************************//
10175>>>>>  // Private_Field_Defaults                                                 //
10175>>>>>  // Set all checkbox fields to default to False data value.                //
10175>>>>>  //************************************************************************//
10175>>>>>
10175>>>>>  Procedure Private_Field_Defaults
10177>>>>>    Integer iField
10177>>>>>    Repeat
10177>>>>>>
10177>>>>>       Get Next_Validation_Type of (Field_Attributes(self)) ;               FA_VALIDATION_TYPE_CHECKBOX iField to iField
10178>>>>>       If iField eq 0 Procedure_Return
10181>>>>>       Set Field_Select_State  iField to False
10182>>>>>       Set Field_Changed_State iField to True
10183>>>>>    Loop
10184>>>>>>
10184>>>>>  End_Procedure
10185>>>>>
10185>>>>>
10185>>>>>  //************************************************************************//
10185>>>>>  // Procedure Field_Defaults                                               //
10185>>>>>  // Will be called after a clear operation to let the application          //
10185>>>>>  // programmer set the default values for the record. This should be done  //
10185>>>>>  // by sending SET Field_Current_Value.                                    //
10185>>>>>  //************************************************************************//
10185>>>>>
10185>>>>>  Procedure Field_Defaults
10187>>>>>  End_Procedure
10188>>>>>
10188>>>>>  //************************************************************************//
10188>>>>>  // Function IsDataInvalid                                                 //
10188>>>>>  // Pass type and string value and see if this is valid data for this      //
10188>>>>>  // type. Currently we check for numbers and dates. Return non-zero        //
10188>>>>>  // if invalid.                                                            //
10188>>>>>  //************************************************************************//
10188>>>>>
10188>>>>>  Function IsDataInvalid integer iType String sValue Returns integer
10190>>>>>    Date    dVal
10190>>>>>    DateTime dtVal
10190>>>>>    Number  nVal
10190>>>>>    integer bOK
10190>>>>>    integer bInvalid
10190>>>>>    integer OldRepMode
10190>>>>>    integer hOldErrorObj
10190>>>>>    Move 0 to bInvalid
10191>>>>>    If (iType=DF_BCD or iType=DF_DATE or iType=DF_DATETIME) Begin
10193>>>>>       // if there is an error we do not want this to be reported. So we
10193>>>>>       // will direct errors locally and turn off error reporting. This fixes
10193>>>>>       // problems where an invalid date returns an error when the view
10193>>>>>       // is being switched (focus loss causes attempt to update DDO).
10193>>>>>       //Get Direct_Error_Local TRUE to bOK
10193>>>>>       move error_object_id to hOldErrorObj
10194>>>>>       Move self to Error_Object_id
10195>>>>>       Get Error_Report_Mode to OldRepMode
10196>>>>>       Set Error_Report_Mode to DD_ERROR_NO_REPORT
10197>>>>>       Indicate Err False              // clear thyself of errors
10198>>>>>       If (iType=DF_DATE) Begin
10200>>>>>          Move (Date(sValue)) to dVal  // this may gen an error.
10201>>>>>          Move (Err) to bInvalid
10202>>>>>       End
10202>>>>>>
10202>>>>>       Else If (iType=DF_DATETIME) Begin
10205>>>>>          Move (Cast(sValue,DateTime)) to dtVal
10206>>>>>//          Move (not(IsDateValid(dtVal))) to bInvalid //jjt-uncomment when working
10206>>>>>       End
10206>>>>>>
10206>>>>>       Else Begin
10207>>>>>         Move (Number(sValue)) to nVal // this may gen an error.
10208>>>>>         Move (Err) to bInvalid
10209>>>>>       End
10209>>>>>>
10209>>>>>//       if bOK Get Direct_Error_Local FALSE to bOK
10209>>>>>       Set Error_Report_Mode to OldRepMode
10210>>>>>       move hOldErrorObj to error_object_id
10211>>>>>       Indicate Err False
10212>>>>>    End
10212>>>>>>
10212>>>>>    Function_Return bInvalid
10213>>>>>  End_Function
10214>>>>>
10214>>>>>  //************************************************************************//
10214>>>>>  // Function IsDeoOwned                                                    //
10214>>>>>  // Return 1 if the passed DEO is part of the DDs list of connected DEOs   //
10214>>>>>  // First check if server of DEO is this DD. If so, we are owned. If not   //
10214>>>>>  // we must check the DD's UI DEO list.                                    //
10214>>>>>  // The passed object MUST be a valid DEO or an error will occur.          //
10214>>>>>  //************************************************************************//
10214>>>>>
10214>>>>>  Function IsDEOOwned integer iDEO Returns integer
10216>>>>>    integer iMax iCount
10216>>>>>    // if DEOs server is same as current DD it is owned. This is the
10216>>>>>    // fast check
10216>>>>>    If (Server(iDEO)=self) Function_return 1
10219>>>>>    // else see if the DEO is in the DD's DEO list
10219>>>>>    Get Data_Set_User_Interface_Count to iMax
10220>>>>>    Decrement iMax
10221>>>>>    For iCount from 0 to iMax
10227>>>>>>
10227>>>>>      If (Data_Set_User_Interface(self,iCount)=iDEO) ;         Function_return 1
10230>>>>>    Loop
10231>>>>>>
10231>>>>>    Function_Return 0
10232>>>>>  End_Function
10233>>>>>
10233>>>>>  //************************************************************************//
10233>>>>>  // Procedure Set Field_Current_Value                                      //
10233>>>>>  // This procedure changes the field value of the given field in the       //
10233>>>>>  // record-buffer object.                                                  //
10233>>>>>  // It also sends Field_Value_Changed to notify every the attached DEOs.   //
10233>>>>>  // This has been optimized so this message is only sent when data is      //
10233>>>>>  // actually changed.                                                      //
10233>>>>>  //************************************************************************//
10233>>>>>
10233>>>>>  Procedure Set Field_Current_Value Integer iField String sValue
10235>>>>>    Integer iObj
10235>>>>>    String sOldVal
10235>>>>>    Integer iChanged
10235>>>>>    Integer iType
10235>>>>>    Integer iFile
10235>>>>>    Integer iFocObj
10235>>>>>    Integer iCrnt
10235>>>>>    Integer bInvalid
10235>>>>>    integer iIdentity
10235>>>>>    Address pData
10235>>>>>    Integer iLen
10235>>>>>
10235>>>>>    Get Main_File to iFile
10236>>>>>    Get_Attribute DF_FIELD_TYPE of iFile iField to iType
10239>>>>>
10239>>>>>    // Overlap fields are not supported directly in DDs. It is expected
10239>>>>>    // that you will use the underlying fields instead
10239>>>>>    If iType EQ DF_OVERLAP Begin
10241>>>>>        Send Data_set_Error iField 0 DD_EXTENDED_OVERLAP_ERROR
10242>>>>>        Procedure_return
10243>>>>>    End
10243>>>>>>
10243>>>>>
10243>>>>>    If (iType=DF_TEXT or iType=DF_BINARY) Begin // if text or binary direct to pointer
10245>>>>>        Move (Length(sValue)) to iLen // length to copy
10246>>>>>        Move (AddressOf(sValue)) to pData   // first byte of string
10247>>>>>        // will gen error if ext. field does not exist
10247>>>>>        Set Field_Current_Pointer_Value iField iLen to pData
10248>>>>>        Procedure_Return
10249>>>>>    end
10249>>>>>>
10249>>>>>
10249>>>>>
10249>>>>>    // If date or number, force conversion so any error is detected before
10249>>>>>    // the buffer is updated. We don't want the record buffer to contain
10249>>>>>    // invalid data
10249>>>>>    Get IsDataInvalid iType sValue to bInvalid
10250>>>>>    If bInvalid ;         // If an error occurred we have        Procedure_return  // a bad number or a bad date. Do no more!
10253>>>>>
10253>>>>>    Move (Record_Buffer(self)) to iObj
10254>>>>>    Get Value of iObj iField to sOldVal
10255>>>>>
10255>>>>>    Set Value of iObj iField to sValue
10256>>>>>
10256>>>>>    // Augmented to handle non DF databases JJT-11/14/2001
10256>>>>>    // Some tables may use some field other then recnum for their record identity.
10256>>>>>    // This will be dfrecnum or some other numeric field. When this happens the DD have
10256>>>>>    // to field buffers for the same value. When an update occurs from the DD to the DB buffer
10256>>>>>    // an update can occur twice. If the values are the same, this does not matter. Else the highest
10256>>>>>    // field value will get the update (not recnum). So if someone changes recnum but not its real field
10256>>>>>    // finding may not work right. The DD is updated when a record is found and the API keeps the two values
10256>>>>>    // the same. If the user changes recnum, the real field does not get changed. That is what we are fixing
10256>>>>>    // here. Note that: 1) this has no effect on Dataflex databases (or any DB that has a 0 field recnum).
10256>>>>>    // 2) this type of update is rarely seen anyway (you have to change just the recnum and perform an entry_update).
10256>>>>>    //
10256>>>>>    // if field is recnum and record identity is not 0, we must also update the other field.
10256>>>>>    If (iField=0) Begin
10258>>>>>        Get_Attribute DF_FILE_RECORD_IDENTITY of iFile to iIdentity
10261>>>>>        If (iIdentity>0) ;            Set Value of iObj iIdentity to sValue
10264>>>>>    End
10264>>>>>>
10264>>>>>
10264>>>>>    //Set Item_Changed_State of iObj iField to TRUE
10264>>>>>    //Set Changed_State of iObj to TRUE
10264>>>>>    // When data-sets are working they should not update the
10264>>>>>    // DEOs.
10264>>>>>
10264>>>>>    // prior to vdf7, we stopped all operation modes of non-zero. We now allow
10264>>>>>    // validates to pass through and we have a new operation mode for this. This
10264>>>>>    // should be ok, since we already allowed navigation validation through - we just
10264>>>>>    // stopped request_validate validations.
10264>>>>>    If (Operation_Mode=0 OR Operation_Mode=MODE_VALIDATING) Begin
10266>>>>>       If (iType=DF_BCD) ;          Move (Number(sValue)<>Number(sOldVal)) to iChanged
10269>>>>>       Else If (iType=DF_DATE) ;          Move (Date(sValue)<>Date(sOldVal)) to iChanged
10273>>>>>       Else If (iType=DF_DATETIME) ;          Move (Cast(sValue,DateTime)<>Cast(sOldVal,DateTime)) to iChanged
10277>>>>>       Else ;          Move (sValue<>sOldVal) to iChanged
10279>>>>>       // if changed, notify all DEOs of this change
10279>>>>>       If iChanged ;          Send Field_Value_Changed iField sValue
10282>>>>>       Else Begin
10283>>>>>          // If here the set value did not change the contents of the DD.
10283>>>>>          // However, it is possible that the current focus DEO may contain
10283>>>>>          // a different value than the one we are setting. In such a case
10283>>>>>          // we must re-synchronize the DEO. Only the one DEO can be affected
10283>>>>>          // because it is the current focus deo/item that can contain a value
10283>>>>>          // that is not yet updated in the DD. This fixes a bug where the
10283>>>>>          // iexit was setting a value which was different from what was in
10283>>>>>          // the DEO but was the same as the old DD value (iExit is called
10283>>>>>          // before the DD is re-synched with the DEO). This could happen
10283>>>>>          // also by sending this message directly with a different value in
10283>>>>>          // the DEO focus item.
10283>>>>>          Get Focus of Desktop to iFocObj
10284>>>>>          // similar logic to Get Field_Current_Value. We check that the DEO
10284>>>>>          // is extended, that entry_refresh is not disabled and that the
10284>>>>>          // DEO's server is this DD.
10284>>>>>          If ( Extended_DEO_State(iFocObj) AND ;               (Entry_Refresh_State(iFocObj)=0)) Begin
10286>>>>>             Get Current_item of iFocObj to iCrnt
10287>>>>>             // If Focus DEO has same file and field and it is not checkbox
10287>>>>>             // we must set its value. Set local value directly sets the value
10287>>>>>             // in the DEO item. If we used value we'd get recursion!
10287>>>>>             If ( Data_File(iFocObj,iCrnt)=iFile AND ;                  Data_Field(iFocObj,iCrnt)=iField AND ;                  IsDEOOwned(self,iFocObj) AND ;                  Checkbox_item_State(iFocObj,iCrnt)=0 ) ;                     Send File_Field_Value_Changed to iFocObj iFile iField sValue TRUE
10290>>>>>                     //Set Local_Value of iFocObj iCrnt to sValue
10290>>>>>          End
10290>>>>>>
10290>>>>>       End
10290>>>>>>
10290>>>>>    End
10290>>>>>>
10290>>>>>  End_Procedure
10291>>>>>
10291>>>>>  //************************************************************************//
10291>>>>>  // Procedure Set Field_Changed_Value                                      //
10291>>>>>  // Sets Field_Current_Value and Sets Field_Changed_State for passed field.//
10291>>>>>  //************************************************************************//
10291>>>>>
10291>>>>>  Procedure Set Field_Changed_Value Integer iField String sValue
10293>>>>>    Set Field_Changed_State iField to TRUE
10294>>>>>    Set Field_Current_Value iField to sValue
10295>>>>>  End_Procedure
10296>>>>>
10296>>>>>  //************************************************************************//
10296>>>>>  // Function Field_Current_Value                                           //
10296>>>>>  // Returns the value from the record buffer for the field of which the    //
10296>>>>>  // fieldnumber has been passed.                                           //
10296>>>>>  // If the file/field requested is the focus file/field the use the DEO's  //
10296>>>>>  // value.                                                                 //
10296>>>>>  //*************************************************************************//
10296>>>>>
10296>>>>>  Function Field_Current_Value Integer iField Returns String
10298>>>>>    Integer iType
10298>>>>>    Integer iFile
10298>>>>>    String  sValue
10298>>>>>    Integer iFoc
10298>>>>>    Integer iCrnt
10298>>>>>    Integer iStrSize
10298>>>>>    Integer iFldSize
10298>>>>>    Address pData
10298>>>>>
10298>>>>>    Get Focus of desktop to iFoc
10299>>>>>    Get Main_File to iFile
10300>>>>>    Get_Attribute DF_FIELD_TYPE of iFile iField to iType
10303>>>>>
10303>>>>>    // Overlap fields are not supported directly in DDs. It is expected
10303>>>>>    // that you will use the underlying fields instead
10303>>>>>    If (iType=DF_OVERLAP) Begin
10305>>>>>        Send Data_set_Error iField DFERR_PROGRAM DD_EXTENDED_OVERLAP_ERROR
10306>>>>>        Function_Return ''
10307>>>>>    End
10307>>>>>>
10307>>>>>
10307>>>>>    If (iType=DF_TEXT or iType=DF_BINARY) Begin // if overlap, text or binary direct to pointer
10309>>>>>       // we assume a string is passed here. If we return to a string the
10309>>>>>       // pointer message will convert this to a string. First check that max string
10309>>>>>       // length is ok for this field. Pointer will check that the extended field
10309>>>>>       // actually exists
10309>>>>>       Get_Argument_Size to iStrSize
10310>>>>>       Get_Attribute DF_FIELD_LENGTH of iFile iField to iFldSize
10313>>>>>       // check that the string size is large enough to hold the value
10313>>>>>       If (iStrSize < iFldSize) Begin
10315>>>>>          Send Data_set_Error iField DFERR_PROGRAM DD_EXTENDED_FIELD_TOO_BIG
10316>>>>>       End
10316>>>>>>
10316>>>>>       Else Begin
10317>>>>>          Get Field_Current_Pointer_Value iField to pData // get pointer to data
10318>>>>>          Move pData to sValue                            // move to a string
10319>>>>>       End
10319>>>>>>
10319>>>>>       Function_Return sValue
10320>>>>>    End
10320>>>>>>
10320>>>>>
10320>>>>>    // This was extended to also make sure that the focus's server
10320>>>>>    // is this DD. This prevent the (very unlikely) case of a focus
10320>>>>>    // file/field being the right file/field but for a different view.
10320>>>>>    // 12.1: Also check operation mode, if within an operation assume that the
10320>>>>>    // ddos have the information they need from the deos. During a refresh we don't
10320>>>>>    // the data to be taken from a DEO - the DD buffer has the information you want. Note that
10320>>>>>    // we also changed all methods that set operation_mode to update the DD with the current
10320>>>>>    // DEO field, so the buffer is always correct.
10320>>>>>    If ( (OPERATION_MODE=MODE_WAITING) and ;         Extended_DEO_State(iFoc) and (Entry_Refresh_State(iFoc)=0) ) Begin
10322>>>>>       Get Current_item of iFoc to iCrnt
10323>>>>>       If ( Data_File(iFoc,iCrnt)=iFile and Data_Field(iFoc,iCrnt)=iField and ;            IsDEOOwned(Self,iFoc) and ;            (Checkbox_item_State(iFoc,iCrnt)=0) ) Begin
10325>>>>>               Get Data_Value of iFoc iCrnt to sValue
10326>>>>>       End
10326>>>>>>
10326>>>>>//       If ( Data_File(iFoc,iCrnt)=iFile and Data_Field(iFoc,iCrnt)=iField and ;
10326>>>>>//            IsDEOOwned(Self,iFoc) and ;
10326>>>>>//            (Checkbox_item_State(iFoc,iCrnt)=0) and ;
10326>>>>>//            (Item_NoPut(iFoc,iCrnt)=0) ) Begin
10326>>>>>//               Get Data_Value of iFoc iCrnt to sValue
10326>>>>>//       End
10326>>>>>       Else Begin
10327>>>>>          Get Value of (Record_Buffer(Self)) iField to sValue
10328>>>>>       End
10328>>>>>>
10328>>>>>    End
10328>>>>>>
10328>>>>>    Else Begin
10329>>>>>       Get Value of (Record_Buffer(Self)) iField to sValue
10330>>>>>    End
10330>>>>>>
10330>>>>>    
10330>>>>>    // cast value to the proper datatype
10330>>>>>    If (iType=DF_BCD) Begin
10332>>>>>       Function_Return (Number(sValue))
10333>>>>>    End
10333>>>>>>
10333>>>>>    Else If (iType=DF_DATE) Begin
10336>>>>>       Function_Return (Date(sValue))
10337>>>>>    End
10337>>>>>>
10337>>>>>    Else If (iType=DF_DATETIME) Begin
10340>>>>>       Function_Return (Cast(sValue,DateTime))
10341>>>>>    End
10341>>>>>>
10341>>>>>    // else return as string
10341>>>>>    Function_Return sValue
10342>>>>>  End_Function
10343>>>>>
10343>>>>>  //************************************************************************//
10343>>>>>  // Procedure Set Field_Default_Value                                      //
10343>>>>>  // Procedure Set File_Field_Default_Value                                 //
10343>>>>>  // This sets a default value without setting the DSO's changed_State      //
10343>>>>>  //************************************************************************//
10343>>>>>
10343>>>>>  Procedure Set Field_Default_Value Integer iField String sValue
10345>>>>>    integer iOldState
10345>>>>>    Get Change_disabled_State to iOldState
10346>>>>>    Set Change_disabled_State to TRUE
10347>>>>>    Set Field_Changed_Value iField to sValue
10348>>>>>    Set Change_disabled_State to iOldState
10349>>>>>  End_Procedure
10350>>>>>
10350>>>>>  procedure Set File_Field_default_Value integer iFile integer iField string sValue
10352>>>>>    integer iDSO
10352>>>>>    Get Data_set iFile to iDSO
10353>>>>>    If iDSO ;       Set Field_default_Value of iDSO iField to sValue
10356>>>>>  End_Procedure
10357>>>>>
10357>>>>>  //************************************************************************//
10357>>>>>  // Get/Set File_Field_Current_Value                                       //
10357>>>>>  // Set     File_Field_Changed_Value                                       //
10357>>>>>  // Methods to set and get the value of a field. When set all DSOs and     //
10357>>>>>  // DEOs are notified.                                                     //
10357>>>>>  //************************************************************************//
10357>>>>>
10357>>>>>  Procedure Set File_Field_Current_Value Integer iFile Integer iField String sValue
10359>>>>>    integer iDSO
10359>>>>>    Get Data_set iFile to iDSO
10360>>>>>    If iDSO ;      Set Field_Current_Value of iDSO iField to sValue
10363>>>>>  End_Procedure
10364>>>>>
10364>>>>>  Procedure Set File_Field_Changed_Value Integer iFile Integer iField String sValue
10366>>>>>    integer iDSO
10366>>>>>    Get Data_set iFile to iDSO
10367>>>>>    If iDSO ;      Set Field_Changed_Value of iDSO iField to sValue
10370>>>>>  End_Procedure
10371>>>>>
10371>>>>>  Function File_Field_Current_Value Integer iFile Integer iField returns string
10373>>>>>    integer iDSO
10373>>>>>    String sValue
10373>>>>>    Get Data_set iFile to iDSO
10374>>>>>    If iDSO ;      Get Field_Current_Value of iDSO iField to sValue
10377>>>>>    Function_Return sValue
10378>>>>>  End_Function
10379>>>>>
10379>>>>>
10379>>>>>  //************************************************************************//
10379>>>>>  // Procedure Field_Value_Changed                                          //
10379>>>>>  // This procedure will notify every attached DEO that the value of a      //
10379>>>>>  // field has been changed. Every DEO needs to update its value to reflect //
10379>>>>>  // the new value.                                                         //
10379>>>>>  //************************************************************************//
10379>>>>>
10379>>>>>  Procedure Field_Value_Changed Integer iField String sValue
10381>>>>>    Integer iMax
10381>>>>>    Integer iCount
10381>>>>>    Integer iDEO
10381>>>>>    Integer iMain_File
10381>>>>>    Integer iNoChange
10381>>>>>    Get Change_Disabled_State to iNoChange
10382>>>>>    Get Main_File to iMain_File
10383>>>>>    Get Data_Set_User_Interface_Count to iMax
10384>>>>>    Decrement iMax
10385>>>>>    For iCount from 0 to iMax
10391>>>>>>
10391>>>>>      Get Data_Set_User_Interface iCount to iDEO
10392>>>>>      If (Extended_DEO_State(iDEO) ) Begin
10394>>>>>         Send File_Field_Value_Changed to iDEO iMain_File iField sValue iNoChange
10395>>>>>      End
10395>>>>>>
10395>>>>>    Loop
10396>>>>>>
10396>>>>>  End_Procedure
10397>>>>>
10397>>>>>
10397>>>>>  //************************************************************************//
10397>>>>>  // Get/Set Field_Changed_State                                            //
10397>>>>>  // Gets/Sets Field_Changed_State of the passed field. Will Set Changed_   //
10397>>>>>  // state if appropriate (if change_disabled_state is false)               //
10397>>>>>  //************************************************************************//
10397>>>>>
10397>>>>>
10397>>>>>  Function Field_Changed_State Integer iField Returns Integer
10399>>>>>    Function_Return ;        (Item_Changed_State(Record_Buffer(self), iField))
10400>>>>>  End_Function
10401>>>>>
10401>>>>>
10401>>>>>  // Handle NoPut here. If the field is noput set the field_changed_State but do not set the
10401>>>>>  // DD's changed_state. As of 17.0, we changed the rule so that noput DEOs always update the DD.
10401>>>>>  // They set the field_Current_value and they set the field_changed_state. If noput they will
10401>>>>>  // not set changed_state. This now makes windows and web consistent.
10401>>>>>
10401>>>>>  Procedure Set Field_Changed_State Integer iField Integer iState
10403>>>>>    Boolean bNoPut bOldSt bIsCommitted
10403>>>>>    
10403>>>>>    Get Field_Option iField DD_NOPUT to bNoPut
10404>>>>>    If not bNoPut Begin // if not noput, see if this is a committed and therefore noput
10406>>>>>        Get IsCommitted iField to bIsCommitted
10407>>>>>        If bIsCommitted Begin
10409>>>>>           Get IsFieldCommitted iField to bNoPut
10410>>>>>        End
10410>>>>>>
10410>>>>>    End
10410>>>>>>
10410>>>>>
10410>>>>>    If bNoPut Begin
10412>>>>>         Get Change_disabled_State to bOldSt
10413>>>>>         Set Change_disabled_State to True
10414>>>>>    End
10414>>>>>>
10414>>>>>    
10414>>>>>    Set Item_Changed_State of (Record_Buffer(Self)) iField to iState
10415>>>>>    
10415>>>>>    If bNoPut Begin
10417>>>>>         Set Change_disabled_State to bOldSt
10418>>>>>    End
10418>>>>>>
10418>>>>>
10418>>>>>  End_Function
10419>>>>>
10419>>>>>
10419>>>>>  //************************************************************************//
10419>>>>>  // Get/Set File_Field_Changed_State                                       //
10419>>>>>  // As above, but passes both file and field                               //
10419>>>>>  //************************************************************************//
10419>>>>>
10419>>>>>  Function File_Field_Changed_State Integer iFile Integer iField Returns Integer
10421>>>>>    Integer iDSO
10421>>>>>    Get Data_Set iFile to iDSO
10422>>>>>    If iDSO ;      Function_Return (Field_Changed_State(iDSO, iField))
10425>>>>>  End_Function
10426>>>>>
10426>>>>>  Procedure Set File_Field_Changed_State Integer iFile Integer iField Integer iState
10428>>>>>    Integer iDSO
10428>>>>>    Get Data_Set iFile to iDSO
10429>>>>>    If iDSO ;       Set Field_Changed_State of iDSO iField to iState
10432>>>>>  End_Function
10433>>>>>
10433>>>>>  //************************************************************************//
10433>>>>>  // This simulates entering a value into a field from a keyboard. Pass the //
10433>>>>>  // Field and DD Options and the value. It is up to you to pass the proper //
10433>>>>>  // DD options. This is normally sent by File_Field_Entry and you are      //
10433>>>>>  // advised to use that message and not this one.                          //
10433>>>>>  //************************************************************************//
10433>>>>>
10433>>>>>  Procedure set Field_Entry integer iField integer iOpts integer bShowErr String sValue
10435>>>>>      integer iFile
10435>>>>>      Integer iType
10435>>>>>      Integer bChanged
10435>>>>>      Integer bInvalid
10435>>>>>      Integer hObj
10435>>>>>      String sOldVal
10435>>>>>      Address pData
10435>>>>>      Integer iLen
10435>>>>>
10435>>>>>      Get Main_File to iFile
10436>>>>>
10436>>>>>      // if No-enter or Displayonly, this shouldn't be changed. We will
10436>>>>>      // let NoPut through, since a user might need it for finding.
10436>>>>>      If (iOpts IAND DD_NOENTER) Procedure_Return
10439>>>>>
10439>>>>>      // Force a caplsock if required
10439>>>>>      If (iOpts IAND DD_CAPSLOCK) Move (Uppercase(sValue)) to sValue
10442>>>>>
10442>>>>>      // If date or number, force conversion so any error is detected before
10442>>>>>      // the buffer is updated. We don't want the record buffer to contain
10442>>>>>      // invalid data
10442>>>>>      Get_Attribute DF_FIELD_TYPE of iFile iField to iType
10445>>>>>
10445>>>>>      // Overlap fields are not supported directly in DDs. It is expected
10445>>>>>      // that you will use the underlying fields instead
10445>>>>>      If iType EQ DF_OVERLAP Begin
10447>>>>>          Send Data_set_Error iField 0 DD_EXTENDED_OVERLAP_ERROR
10448>>>>>          Procedure_return
10449>>>>>      End
10449>>>>>>
10449>>>>>
10449>>>>>      If (iType=DF_TEXT or iType=DF_BINARY) Begin // if text or binary direct to pointer
10451>>>>>          Move (Length(sValue)) to iLen // length to copy
10452>>>>>          Move (AddressOf(sValue)) to pData   // first byte of string
10453>>>>>          // will gen error if ext. field does not exist
10453>>>>>          Set Field_Pointer_Entry iField iOpts iLen bShowErr to pData
10454>>>>>          Procedure_Return
10455>>>>>      end
10455>>>>>>
10455>>>>>
10455>>>>>      Get IsDataInvalid iType sValue to bInvalid
10456>>>>>      If bInvalid begin     // If an error occurred we have
10458>>>>>         If bShowErr ;            Send Data_set_error iField (If(iType=DF_DATE or iType=DF_DATETIME, DFERR_ENTER_VALID_DATE, DFERR_BAD_ENTRY)) ;                   (" ("-sValue-")")
10461>>>>>         Procedure_return  // a bad number or a bad date. Do no more!
10462>>>>>      end
10462>>>>>>
10462>>>>>      // update the value only if the value is changed.
10462>>>>>      Move (Record_Buffer(self)) to hObj
10463>>>>>      Get Value of hObj iField to sOldVal
10464>>>>>      If (iType=DF_BCD) ;         Move (Number(sValue)<>Number(sOldVal)) to bChanged
10467>>>>>      Else If (iType=DF_DATE) ;         Move (Date(sValue)<>Date(sOldVal)) to bChanged
10471>>>>>      Else If (iType=DF_DATETIME) ;         Move (Cast(sValue,DateTime)<>Cast(sOldVal,DateTime)) to bChanged
10475>>>>>      Else ;         Move (sValue<>sOldVal) to bChanged
10477>>>>>
10477>>>>>      // if changed or force put, update the value.
10477>>>>>      If ( bChanged or (iOpts IAND DD_FORCEPUT) ) ;         Set Field_Current_Value iField to sValue
10480>>>>>
10480>>>>>      // Set changed state if changed. This is an improvement on DEOs which would set changed-state for
10480>>>>>      // a no-put. Set Field_Changed_State will not set Changed_state if it is noput
10480>>>>>      If ( bChanged) Begin
10482>>>>>         Set Field_Changed_State iField to True
10483>>>>>         // if this is noput we will set the NoPutOverride flag to true which will tell
10483>>>>>         // the DD to not update this value during a save.
10483>>>>>         If ( iOpts iand DD_NOPUT ) Begin
10485>>>>>             Send SetNoPutOverride iField
10486>>>>>         End
10486>>>>>>
10486>>>>>      End
10486>>>>>>
10486>>>>>
10486>>>>>      // perform autofinds if needed. Note that required checking will occur as
10486>>>>>      // part of validation.
10486>>>>>      // We will only autofind if the field value is changed. This is consistent with
10486>>>>>      // DEOs which do not autofind on unchanged values. This provides optimizations
10486>>>>>      // when a parent record is already loaded.
10486>>>>>      If (bChanged OR Field_Changed_state(self,iField)) Begin
10488>>>>>         // note that autofind is 1 and _ge is 100000001 (8th bit set). So order of
10488>>>>>         // testing is important and make sure we test for exact bit match. Must first
10488>>>>>         // test _GE and the EQ (because EQ bit is part of GE)
10488>>>>>         If ((iOpts IAND DD_AUTOFIND_GE)=DD_AUTOFIND_GE) Send File_Field_AutoFind iFile iField GE
10491>>>>>         else If ((iOpts IAND DD_AUTOFIND)=DD_AUTOFIND)  Send File_Field_AutoFind iFile iField EQ
10495>>>>>      End
10495>>>>>>
10495>>>>>
10495>>>>>  End_Procedure
10496>>>>>
10496>>>>>  // **********************************************************************
10496>>>>>  // Private: This returns file-field options for a Field_Entry type of environment.
10496>>>>>  // It will strip autofind from main-file DDs but leave foreign field alone.
10496>>>>>  // This is needed for Field_entry. Otherwise adding a field value to an autofind
10496>>>>>  // for save or find causes an autofind to trigger first which either causes the
10496>>>>>  // wrong rec to save or for a double find.
10496>>>>>  // **********************************************************************
10496>>>>>
10496>>>>>  Function File_Field_Entry_Options integer iFile integer iField returns integer
10498>>>>>       integer iOpts
10498>>>>>       // this will get the appropriate field and foreign field opts
10498>>>>>       Get File_Field_Options iFile iField to iOpts
10499>>>>>       // If the main file (not foreign) we will strip autofind. Autofind should not
10499>>>>>       // be an automatic part of main file entry while it should with foreign fields.
10499>>>>>       If (iFile=Main_File(Self)) Begin
10501>>>>>          // note that autofind is 1 and _ge is 100000001 (8th bit set). So order of
10501>>>>>          // testing is important and make sure we test for exact bit match. Must first
10501>>>>>          // test _GE and the EQ (because EQ bit is part of GE)
10501>>>>>          If ((iOpts IAND DD_AUTOFIND_GE)=DD_AUTOFIND_GE) Move (iOpts - DD_AUTOFIND_GE) to iOpts
10504>>>>>          else If ((iOpts IAND DD_AUTOFIND)=DD_AUTOFIND)  Move (iOpts - DD_AUTOFIND)    to iOpts
10508>>>>>       end
10508>>>>>>
10508>>>>>       Function_Return iOpts
10509>>>>>   End_Function
10510>>>>>
10510>>>>>
10510>>>>>
10510>>>>>  //************************************************************************//
10510>>>>>  // This simulates entering a value into a field from a keyboard. The DD   //
10510>>>>>  // receiving this message determines if it is Main or Foreign (just like  //
10510>>>>>  // server). It will do an uppercase, will respect No_Enter and DisplayOnly//
10510>>>>>  // and will do a autofind if required. It does not do a field validation. //
10510>>>>>  //************************************************************************//
10510>>>>>
10510>>>>>  Procedure set File_Field_Entry integer iFile integer iField integer bShowErr string sValue
10512>>>>>      integer iOpts
10512>>>>>      integer hDD
10512>>>>>      Get Data_Set iFile to hDD
10513>>>>>      If hDD Begin
10515>>>>>         // this will get the appropriate field and foreign field opts
10515>>>>>         Get File_Field_Entry_Options iFile iField to iOpts
10516>>>>>         Set Field_Entry of hDD iField iOpts bShowErr to sValue
10517>>>>>      End
10517>>>>>>
10517>>>>>  End_Procedure
10518>>>>>
10518>>>>>
10518>>>>>
10518>>>>>  //************************************************************************//
10518>>>>>  // return object ID of extended field, 0 if none                          //
10518>>>>>  //************************************************************************//
10518>>>>>
10518>>>>>  Function Field_Object integer iField Returns integer
10520>>>>>      Integer hoFlds hoField
10520>>>>>      Boolean bAutoAssign
10520>>>>>      Get Field_Objects to hoFlds
10521>>>>>      If hoFlds Begin
10523>>>>>          Get Field_Object of hoFlds iField to hoField
10524>>>>>      End
10524>>>>>>
10524>>>>>      If not hoField Begin
10526>>>>>         Send DefineExtendedField iField // will create field_objects and Field_Object as needed
10527>>>>>         Get Field_Objects to hoFlds
10528>>>>>         Get Field_Object of hoFlds iField to hoField
10529>>>>>      End
10529>>>>>>
10529>>>>>      Function_Return hoField
10530>>>>>  End_Function
10531>>>>>
10531>>>>>  //************************************************************************//
10531>>>>>  // This is the same as Field_entry except the value is passed via a       //
10531>>>>>  // pointer. If data-type is extended (text/binary) it will use and an     //
10531>>>>>  // extended field object to handle this. If date/number/string we will    //
10531>>>>>  // convert this to a string and use Field_Entry. It is the caller's       //
10531>>>>>  // responsibility to pass a valid pointer to valid data...else !@#$%^&^   //
10531>>>>>  // If an extended Field object is needed and not defined, an error is     //
10531>>>>>  // returned. If pointer is null, assume empty string passed (this is a    //
10531>>>>>  // change as of 8.3 - it used to ignore null pointers)                    //
10531>>>>>  //************************************************************************//
10531>>>>>
10531>>>>>  Procedure Set Field_Pointer_Entry integer iField integer iOpts integer iLen integer bShowErr Address pData
10533>>>>>      integer hFld
10533>>>>>      string  sValue
10533>>>>>      integer iFile
10533>>>>>      integer iType
10533>>>>>
10533>>>>>      Get Main_file to iFile
10534>>>>>      Get_Attribute DF_FIELD_TYPE of iFile iField to iType
10537>>>>>
10537>>>>>      // Overlap fields are not supported directly in DDs. It is expected
10537>>>>>      // that you will use the underlying fields instead
10537>>>>>      If iType EQ DF_OVERLAP ;         Send Data_set_Error iField 0 DD_EXTENDED_OVERLAP_ERROR
10540>>>>>      Else If (iType=DF_TEXT or iType=DF_BINARY) Begin
10543>>>>>         Get Field_Object iField to hFld // the object that handles this large text
10544>>>>>         If hFld ;            Set Field_pEntry of hFld iOpts iLen bShowErr to pData
10547>>>>>         Else ;            Send Data_set_Error iField 0 DD_EXTENDED_FIELD_NOT_DEFINED
10549>>>>>      end
10549>>>>>>
10549>>>>>      Else Begin
10550>>>>>         // if number,date or string convert the pointer data to
10550>>>>>         // string data and do a normal entry with it.
10550>>>>>         Move pData to sValue // create string from pointer data
10551>>>>>         Set Field_Entry iField iOpts bShowErr to sValue
10552>>>>>      End
10552>>>>>>
10552>>>>>  End_procedure
10553>>>>>
10553>>>>>  //************************************************************************//
10553>>>>>  // This is the same as File_Field_entry except the value is passed via a  //
10553>>>>>  // pointer. See Field_Pointer_Entry for more on this                      //
10553>>>>>  //************************************************************************//
10553>>>>>
10553>>>>>  Procedure Set File_Field_Pointer_Entry integer iFile integer iField integer iLen integer bShowErr Address pData
10555>>>>>      integer iOpts
10555>>>>>      integer hDD
10555>>>>>      Get Data_Set iFile to hDD
10556>>>>>      If hDD Begin
10558>>>>>         // this will get the appropriate field and foreign field opts
10558>>>>>         Get File_Field_Entry_Options iFile iField to iOpts
10559>>>>>         Set Field_Pointer_Entry of hDD iField iOpts iLen bShowErr to pData
10560>>>>>      End
10560>>>>>>
10560>>>>>  End_procedure
10561>>>>>
10561>>>>>  //************************************************************************//
10561>>>>>  // This is the same as Field_Current_Value except the value is passed via //
10561>>>>>  // a pointer. If data-type is extended (text/binary) it will use and an   //
10561>>>>>  // extended field object to handle this. If date/number/string we will    //
10561>>>>>  // convert this to a string and use Field_Entry. It is the caller's       //
10561>>>>>  // responsibility to pass a valid pointer to valid data...else !@#$%^&^   //
10561>>>>>  // If an extended Field object is needed and not defined, an error is     //
10561>>>>>  // returned. If pointer is null, assume empty string passed (this is a    //
10561>>>>>  // change as of 8.3 - it used to ignore null pointers)                    //
10561>>>>>  //************************************************************************//
10561>>>>>
10561>>>>>  Procedure Set Field_Current_Pointer_Value integer iField integer iLen Address pData
10563>>>>>      integer hFld
10563>>>>>      string  sValue
10563>>>>>      Integer iFile iType iCrnt
10563>>>>>      Handle iFocObj
10563>>>>>      Boolean bChanged
10563>>>>>
10563>>>>>      Get Main_file to iFile
10564>>>>>      Get_Attribute DF_FIELD_TYPE of iFile iField to iType
10567>>>>>
10567>>>>>      // Overlap fields are not supported directly in DDs. It is expected
10567>>>>>      // that you will use the underlying fields instead
10567>>>>>      If iType EQ DF_OVERLAP Begin
10569>>>>>         Send Data_set_Error iField DFERR_PROGRAM DD_EXTENDED_OVERLAP_ERROR
10570>>>>>         Procedure_Return
10571>>>>>      End
10571>>>>>>
10571>>>>>
10571>>>>>      If (iType<>DF_TEXT and iType<>DF_BINARY) Begin
10573>>>>>         // if number,date or string convert the pointer data to
10573>>>>>         // string data and do a normal entry with it.
10573>>>>>         Move pData to sValue // create string from pointer data
10574>>>>>         Set Field_Current_Value iField to sValue
10575>>>>>         Procedure_Return
10576>>>>>      End
10576>>>>>>
10576>>>>>
10576>>>>>     Get Field_Object iField to hFld // the object that handles this large text
10577>>>>>     If not hFld Begin
10579>>>>>        Send Data_set_Error iField DFERR_PROGRAM DD_EXTENDED_FIELD_NOT_DEFINED
10580>>>>>        Procedure_Return
10581>>>>>     End
10581>>>>>>
10581>>>>>
10581>>>>>        Get Is_pValueChanged of hFld iLen pData to bChanged
10582>>>>>        If bChanged Begin
10584>>>>>          Set Field_pValue of hFld iLen to pData
10585>>>>>          Send Field_Pointer_Value_Changed iField pData
10586>>>>>        End
10586>>>>>>
10586>>>>>       Else Begin
10587>>>>>          // If here the set value did not change the contents of the DD.
10587>>>>>          // However, it is possible that the current focus DEO may contain
10587>>>>>          // a different value than the one we are setting. In such a case
10587>>>>>          // we must re-synchronize the DEO. Only the one DEO can be affected
10587>>>>>          // because it is the current focus deo/item that can contain a value
10587>>>>>          // that is not yet updated in the DD. This fixes a bug where the
10587>>>>>          // iexit was setting a value which was different from what was in
10587>>>>>          // the DEO but was the same as the old DD value (iExit is called
10587>>>>>          // before the DD is re-synched with the DEO). This could happen
10587>>>>>          // also by sending this message directly with a different value in
10587>>>>>          // the DEO focus item.
10587>>>>>          Get Focus of Desktop to iFocObj
10588>>>>>          // similar logic to Get Field_Pointer_Current_Value. We check that the DEO
10588>>>>>          // is extended, that entry_refresh is not disabled and that the
10588>>>>>          // DEO's server is this DD.
10588>>>>>          If ( Extended_DEO_State(iFocObj) and (Entry_Refresh_State(iFocObj)=0)) Begin
10590>>>>>             // If Focus DEO has same file and field and it is not checkbox
10590>>>>>             // we must set its value. Set local value directly sets the value
10590>>>>>             // in the DEO item. If we used value we'd get recursion!
10590>>>>>             Get Current_item of iFocObj to iCrnt
10591>>>>>             If ( Data_File(iFocObj,iCrnt)=iFile and ;                  Data_Field(iFocObj,iCrnt)=iField and ;                  IsDEOOwned(Self,iFocObj) ) Begin
10593>>>>>                     Send File_Field_Pointer_Value_Changed to iFocObj iFile iField pData True
10594>>>>>                  End
10594>>>>>>
10594>>>>>          End
10594>>>>>>
10594>>>>>       End
10594>>>>>>
10594>>>>>  End_Procedure
10595>>>>>  
10595>>>>>  // This is never called but it needed for the compiler. Required for apps DDs that don't compile in a DEO interface
10595>>>>>  Procedure File_Field_Pointer_Value_Changed Integer iFile Integer iField Address pValue Integer iChangeDisabled
10597>>>>>  End_Procedure
10598>>>>>
10598>>>>>  Procedure Field_Pointer_Value_Changed Integer iField Address pValue
10600>>>>>    Integer iMax
10600>>>>>    Integer iCount
10600>>>>>    Integer iDEO
10600>>>>>    Integer iMain_File
10600>>>>>    Integer iNoChange
10600>>>>>    Get Change_Disabled_State to iNoChange
10601>>>>>    Get Main_File to iMain_File
10602>>>>>    Get Data_Set_User_Interface_Count to iMax
10603>>>>>    Decrement iMax
10604>>>>>    For iCount from 0 to iMax
10610>>>>>>
10610>>>>>      Get Data_Set_User_Interface iCount to iDEO
10611>>>>>      If (Extended_DEO_State(iDEO) ) Begin
10613>>>>>         Send File_Field_Pointer_Value_Changed to iDEO iMain_File iField pValue iNoChange
10614>>>>>      End
10614>>>>>>
10614>>>>>    Loop
10615>>>>>>
10615>>>>>  End_Procedure
10616>>>>>
10616>>>>>
10616>>>>>  //************************************************************************//
10616>>>>>  // This is the same as File_Field_Current_Value except the value is passed//
10616>>>>>  // via a pointer. See Field_current_Pointer_Value for more on this        //
10616>>>>>  //************************************************************************//
10616>>>>>
10616>>>>>  Procedure Set File_Field_Current_Pointer_Value integer iFile integer iField integer iLen Address pData
10618>>>>>      integer hDD
10618>>>>>      Get Data_Set iFile to hDD
10619>>>>>      If hDD ;         Set Field_Current_Pointer_Value of hDD iField iLen to pData
10622>>>>>  End_procedure
10623>>>>>
10623>>>>>
10623>>>>>  //************************************************************************//
10623>>>>>  // Field_Current_Pointer_Value                                            //
10623>>>>>  // File_Field_Current_Pointer_Value                                       //
10623>>>>>  // This returns the data pointer to the extended field. At this point     //
10623>>>>>  // this is the data. Be careful if you change the data, be even more      //
10623>>>>>  // careful if you change the pointer (don't do it!!!!)                    //
10623>>>>>  //************************************************************************//
10623>>>>>
10623>>>>>  Function Field_Current_Pointer_Value integer iField returns Address
10625>>>>>      Integer hFld
10625>>>>>      Handle iFoc
10625>>>>>
10625>>>>>      Get Field_Object iField to hFld // the object that handles this large text
10626>>>>>      If not hFld Begin
10628>>>>>          Send Data_set_Error iField DFERR_PROGRAM DD_EXTENDED_FIELD_NOT_DEFINED
10629>>>>>          Function_Return 0
10630>>>>>      End
10630>>>>>>
10630>>>>>
10630>>>>>
10630>>>>>    // This was extended to also make sure that the focus's server
10630>>>>>    // is this DD. This prevent the (very unlikely) case of a focus
10630>>>>>    // file/field being the right file/field but for a different view.
10630>>>>>    // 12.1: Also check operation mode, if within an operation assume that the
10630>>>>>    // ddos have the information they need from the deos. During a refresh we don't
10630>>>>>    // the data to be taken from a DEO - the DD buffer has the information you want. Note that
10630>>>>>    // we also changed all methods that set operation_mode to update the DD with the current
10630>>>>>    // DEO field, so the buffer is always correct.
10630>>>>>    Get Focus of Desktop to iFoc
10631>>>>>    If ( (OPERATION_MODE=MODE_WAITING) and ;         Extended_DEO_State(iFoc) and (Entry_Refresh_State(iFoc)=0) ) Begin
10633>>>>>       If ( Data_File(iFoc,0)=Main_File(Self) and Data_Field(iFoc,0)=iField and ;            IsDEOOwned(Self,iFoc) ) Begin
10635>>>>>               Send Update_Focus_Field
10636>>>>>            End
10636>>>>>>
10636>>>>>    End
10636>>>>>>
10636>>>>>            
10636>>>>>    Function_Return (FieldPointer(hFld))
10637>>>>>  End_function
10638>>>>>
10638>>>>>
10638>>>>>  Function File_Field_Current_Pointer_Value integer iFile integer iField Returns Address
10640>>>>>      Address pValue
10640>>>>>      integer hDD
10640>>>>>      Get Data_Set iFile to hDD
10641>>>>>      If hDD Begin
10643>>>>>         Get Field_Current_Pointer_Value of hDD iField to pValue // return pointer to first byte of
10644>>>>>         Function_Return pValue                                  // data
10645>>>>>      End
10645>>>>>>
10645>>>>>  End_Function
10646>>>>>
10646>>>>>  //************************************************************************//
10646>>>>>  // Create an extended field object for the passed field. .                //
10646>>>>>  // If field already exists, do nothing. This should only be used with     //
10646>>>>>  // text and binary fields.                                                //
10646>>>>>  //************************************************************************//
10646>>>>>
10646>>>>>  Procedure DefineExtendedField integer iField
10648>>>>>      integer hFlds
10648>>>>>      Get Field_Objects to hFlds // this may not be created yet.
10649>>>>>      If not hFlds Begin         // if not created, create extended-fields wrapper
10651>>>>>          Object ExtendedFieldObjects Is A FieldObjects
10653>>>>>              Move self to hFlds
10654>>>>>          End_Object
10655>>>>>          Set Field_Objects to hFlds
10656>>>>>      End
10656>>>>>>
10656>>>>>      Send DefineFieldObject to hFlds iField
10657>>>>>  End_Procedure
10658>>>>>
10658>>>>>  //************************************************************************//
10658>>>>>  // create extended DD fields for all text and binary files                //
10658>>>>>  //************************************************************************//
10658>>>>>
10658>>>>>  Procedure DefineAllExtendedFields
10660>>>>>    Integer iCount iType iField iFile
10660>>>>>    get Main_file to iFile
10661>>>>>    Get_Attribute DF_FILE_NUMBER_FIELDS of iFile to iCount
10664>>>>>    For iField from 1 to iCount
10670>>>>>>
10670>>>>>      Get_Attribute DF_FIELD_TYPE of iFile iField to iType
10673>>>>>      If (iType=DF_TEXT or iType=DF_BINARY) ; // if text or binary         Send DefineExtendedField iField
10676>>>>>    Loop
10677>>>>>>
10677>>>>>  End_Procedure
10678>>>>>
10678>>>>>  //************************************************************************//
10678>>>>>  // Update Extended fields to FileBuffer.  DD-Fields ---> FileBuffer       //
10678>>>>>  // Private                                                                //
10678>>>>>  //************************************************************************//
10678>>>>>
10678>>>>>  Procedure ExtendedFieldsUpdate integer bSave
10680>>>>>      integer hFlds
10680>>>>>      Get Field_Objects to hFlds
10681>>>>>      If hFlds ;          Send ExtendedFieldsUpdate to hFlds bSave
10684>>>>>  End_procedure
10685>>>>>
10685>>>>>  //************************************************************************//
10685>>>>>  // Refresh Extended field from FileBuffer.  DD-Fields <--- FileBuffer     //
10685>>>>>  // Private                                                                //
10685>>>>>  //************************************************************************//
10685>>>>>
10685>>>>>  Procedure ExtendedFieldsRefresh Boolean bCleared
10687>>>>>      integer hFlds
10687>>>>>      Get Field_Objects to hFlds
10688>>>>>      If hFlds ;          Send ExtendedFieldsRefresh to hFlds bCleared
10691>>>>>  End_procedure
10692>>>>>
10692>>>>>  //************************************************************************//
10692>>>>>  // Procedure Set Field_Options                                            //
10692>>>>>  // This procedure can be used to set the Item_Options of a field. This can//
10692>>>>>  // be passed any number of arguments.                                     //
10692>>>>>  // Support the following special first parameters:                        //
10692>>>>>  //      DD_CLEAR_FIELD_OPTIONS     - clear all following passed otpions   //
10692>>>>>  //      DD_CLEAR_ALL_FIELD_OPTIONS - clear all options                    //
10692>>>>>  //************************************************************************//
10692>>>>>
10692>>>>>  Procedure Set Field_Options Integer iField Integer iArg1 // plus unknown arguments
10694>>>>>    Integer iObj
10694>>>>>    Integer iOptions
10694>>>>>    Integer iOption
10694>>>>>    Integer iArg
10694>>>>>    Integer iClear
10694>>>>>    integer iType
10694>>>>>    Move (Record_Buffer(self)) to iObj
10695>>>>>    Get Item_Options of iObj iField to iOptions
10696>>>>>    //
10696>>>>>    For iArg from 2 to Num_Arguments
10702>>>>>>
10702>>>>>        MoveStr iArg& to iOption // tricky way to parse passed arguments
10703>>>>>>
10703>>>>>        if iOption eq DD_CLEAR_ALL_FIELD_OPTIONS ;           Move 0 to iOptions
10706>>>>>        Else if iOption eq DD_CLEAR_FIELD_OPTIONS ;           Move 1 to iClear
10710>>>>>        Else if Not iClear ;           Move (iOptions IOR iOption) to iOptions
10714>>>>>        Else ; // only unset bits already set! Note multiple bits can be passed           Move (iOptions - (iOptions IAND iOption)) to iOptions
10716>>>>>    Loop
10717>>>>>>
10717>>>>>    //
10717>>>>>    //Get_Attribute DF_FIELD_TYPE of (Main_File(self)) iField to iType
10717>>>>>    //If (iType=DF_TEXT or iType=DF_BINARY) ;            // if text of binary
10717>>>>>    //    Move (iOptions iOR DD_DISPLAYONLY) to iOptions // make sure DO is set
10717>>>>>
10717>>>>>    Set Item_Options of iObj iField to iOptions
10718>>>>>  End_Procedure
10719>>>>>
10719>>>>>  //************************************************************************//
10719>>>>>  // Function Field_Options                                                  //
10719>>>>>  // This function returns all the item_options which have been set for     //
10719>>>>>  // a field. The value from the Record_Buffer object will be binary or'ed  //
10719>>>>>  // with constand Default_Item_Options and the DD_AUTOCLEAR constants when //
10719>>>>>  // the Autoclear_State of the field has been set.                         //
10719>>>>>  // Keep in mind that Autoclear is *not* kept in the Item_Options          //
10719>>>>>  // property.                                                              //
10719>>>>>  //************************************************************************//
10719>>>>>
10719>>>>>  Function Field_Options Integer iField Returns Integer
10721>>>>>    Function_Return (Item_Options(Record_Buffer(self), iField))
10722>>>>>  End_Function
10723>>>>>
10723>>>>>  Function Field_Option Integer iField Integer iOption returns integer
10725>>>>>    Integer iOptions
10725>>>>>    Integer iState
10725>>>>>    Get Item_Options of (Record_Buffer(Self)) iField to iOptions
10726>>>>>    // All bits must match for it to be True (e.g., displayonly requires noput & noenter)
10726>>>>>    Move ((iOptions iand iOption)=iOption) to iState
10727>>>>>    Function_Return iState
10728>>>>>  End_Function
10729>>>>>
10729>>>>>  Procedure Set Foreign_Field_Options Integer iField Integer iArg1 // Integer iOption
10731>>>>>    Integer iObj
10731>>>>>    Integer iOptions
10731>>>>>    Integer iOption
10731>>>>>    Integer iArg
10731>>>>>    Integer iClear
10731>>>>>    //
10731>>>>>    If iField GE 0 Begin
10733>>>>>       Move (Record_Buffer(self)) to iObj
10734>>>>>       Get Aux_Value of iObj iField to iOptions
10735>>>>>    End
10735>>>>>>
10735>>>>>    Else If iField EQ DD_DEFAULT ;       Get private.Foreign_Field_Options to iOptions
10739>>>>>    Else If iField EQ DD_INDEXFIELD ;       Get private.Foreign_Index_Field_Options to iOptions
10743>>>>>    Else ;       Get private.Foreign_Key_Field_Options to iOptions
10745>>>>>    //
10745>>>>>    For iArg from 2 to Num_Arguments
10751>>>>>>
10751>>>>>        MoveStr iArg& to iOption // tricky way to parse passed arguments
10752>>>>>>
10752>>>>>        if iOption eq DD_CLEAR_ALL_FIELD_OPTIONS ;           Move 0 to iOptions
10755>>>>>        Else if iOption eq DD_CLEAR_FIELD_OPTIONS ;           Move 1 to iClear
10759>>>>>        Else if Not iClear ;           Move (iOptions IOR iOption) to iOptions
10763>>>>>        Else ; // only unset bits already set! Note multiple bits can be passed           Move (iOptions - (iOptions IAND iOption)) to iOptions
10765>>>>>    Loop
10766>>>>>>
10766>>>>>    //
10766>>>>>    If iField GE 0 ;       Set Aux_Value of iObj iField to iOptions
10769>>>>>    Else If iField EQ DD_DEFAULT ;       Set private.Foreign_Field_Options to iOptions
10773>>>>>    Else If iField EQ DD_INDEXFIELD ;       Set private.Foreign_Index_Field_Options to iOptions
10777>>>>>    Else ;       Set private.Foreign_Key_Field_Options to iOptions
10779>>>>>  End_Procedure
10780>>>>>
10780>>>>>  Function Foreign_Field_Options Integer iField Returns Integer
10782>>>>>    Integer iOpts
10782>>>>>    Integer iAux
10782>>>>>    Integer iFile
10782>>>>>    Integer iIndex
10782>>>>>    
10782>>>>>    // if one of the special field types, we return the value of the type
10782>>>>>    If (iField=DD_KEYFIELD) Begin
10784>>>>>        Get private.Foreign_Key_Field_Options to iOpts
10785>>>>>    End
10785>>>>>>
10785>>>>>    Else If (iField=DD_INDEXFIELD) Begin
10788>>>>>        Get private.Foreign_Index_Field_Options to iOpts
10789>>>>>    End
10789>>>>>>
10789>>>>>    Else If (iField=DD_DEFAULT) Begin
10792>>>>>        Get private.Foreign_Field_Options to iOpts
10793>>>>>    End
10793>>>>>>
10793>>>>>    Else Begin
10794>>>>>        // if a field number is passed we return the calculated value based on
10794>>>>>        // the type of field this actually is plus anything applied to this field. 
10794>>>>>        If (Key_Field_State(Self, iField)) ;          Get private.Foreign_Key_Field_Options to iOpts
10797>>>>>        Else Begin
10798>>>>>          Get Main_File to iFile
10799>>>>>          Get_Attribute DF_FIELD_INDEX of iFile iField to iIndex
10802>>>>>          If iIndex ;            Get private.Foreign_Index_Field_Options to iOpts
10805>>>>>          Else ;            Get private.Foreign_Field_Options to iOpts
10807>>>>>        End
10807>>>>>>
10807>>>>>        Get Aux_Value of (Record_Buffer(Self)) iField to iAux
10808>>>>>        Move (iAux ior iOpts) to iOpts
10809>>>>>    End
10809>>>>>>
10809>>>>>    Function_Return iOpts
10810>>>>>  End_Function
10811>>>>>  
10811>>>>>  Procedure Set Foreign_Field_Option Integer iField Integer iOption Integer bSet
10813>>>>>      If bSet Begin
10815>>>>>          Set Foreign_Field_Options iField to iOption
10816>>>>>      End
10816>>>>>>
10816>>>>>      Else Begin
10817>>>>>          Set Foreign_Field_Options iField to DD_CLEAR_FIELD_OPTIONS iOption
10818>>>>>      End
10818>>>>>>
10818>>>>>  End_Procedure
10819>>>>>
10819>>>>>  Function Foreign_Field_Option Integer iField Integer iOption Returns Integer
10821>>>>>    Integer iOptions
10821>>>>>    Integer iState
10821>>>>>    Get Foreign_Field_Options iField to iOptions
10822>>>>>    Move ((iOptions iand iOption)=iOption) to iState
10823>>>>>    Function_Return iState
10824>>>>>  End_Function
10825>>>>>
10825>>>>>  //************************************************************************//
10825>>>>>  // Function File_Field_Options                                            //
10825>>>>>  // This procedure is being used by DEOs when they need to copy the item-  //
10825>>>>>  // options from the Data_Set. When the filenumber being passed is not     //
10825>>>>>  // equal to the Main_File of this Data_Set, then the Foreign_Field_Options//
10825>>>>>  // will be applied.                                                       //
10825>>>>>  //************************************************************************//
10825>>>>>  
10825>>>>>  Function File_Field_Options Integer iFile Integer iField Returns Integer
10827>>>>>    Integer iDSO
10827>>>>>    Integer iMain_File
10827>>>>>    Integer iOpts
10827>>>>>    Integer iRB
10827>>>>>    integer iType
10827>>>>>    Get Main_File to iMain_File
10828>>>>>    If iFile NE iMain_File ;      Get Data_Set iFile to iDSO
10831>>>>>    Else ;      Move self to iDSO
10833>>>>>    If iDSO Begin
10835>>>>>      Get Field_Options of iDSO iField to iOpts
10836>>>>>      // if data-type is Text or Binary we must remove the DisplayOnly
10836>>>>>      // attributes since these have to be set in the entrylist. This is
10836>>>>>      // a compromise that means that text/binary cannot be primarily
10836>>>>>      // no-enter or no-put. Foreign settings can still be applied
10836>>>>>      //Get_Attribute DF_FIELD_TYPE of iFile iField to iType
10836>>>>>      // this assumes that text and binary are set to displayonly which is what
10836>>>>>      // the DD does.
10836>>>>>      //If (iType=DF_TEXT OR iType=DF_BINARY) Subtract DD_DISPLAYONLY from iOpts
10836>>>>>      // we consider the item to be foreign if the DDO main file is different than the one
10836>>>>>      // passed and we do not allow foreign (parent) new records to be saved.
10836>>>>>      If (iFile<>iMain_File and Allow_Foreign_New_Save_State(iDSO)=0) ; // Add Foreign_Field_Options        Move (iOpts ior Foreign_Field_Options(iDSO, iField)) to iOpts
10839>>>>>      Function_Return iOpts
10840>>>>>    End
10840>>>>>>
10840>>>>>  End_Function
10841>>>>>
10841>>>>>
10841>>>>>  //************************************************************************//
10841>>>>>  // Procedure to set the message to be send on item entry.                 //
10841>>>>>  //************************************************************************//
10841>>>>>
10841>>>>>  Procedure Set Field_Entry_msg Integer iField Integer iMsg
10843>>>>>    Set Item_Entry_MSG of (Record_Buffer(Self)) iField to iMsg
10844>>>>>  End_Procedure
10845>>>>>
10845>>>>>  //************************************************************************//
10845>>>>>  // Function to return the message to be send on item entry.               //
10845>>>>>  //************************************************************************//
10845>>>>>
10845>>>>>  Function Field_Entry_msg Integer iField returns integer
10847>>>>>    Function_Return (Item_Entry_MSG(Record_Buffer(self), iField))
10848>>>>>  End_Function
10849>>>>>
10849>>>>>
10849>>>>>
10849>>>>>  //************************************************************************//
10849>>>>>  // Procedure to sent the message to be send on item exit.                 //
10849>>>>>  //************************************************************************//
10849>>>>>
10849>>>>>  Procedure Set Field_Exit_msg Integer iField Integer iMsg
10851>>>>>    Set Item_Exit_MSG of (Record_Buffer(Self)) iField to iMsg
10852>>>>>  End_Procedure
10853>>>>>
10853>>>>>  //************************************************************************//
10853>>>>>  // Function to return the message to be send on item exit.                //
10853>>>>>  //************************************************************************//
10853>>>>>
10853>>>>>  Function Field_Exit_msg Integer iField Returns Integer
10855>>>>>    Function_Return (Item_Exit_MSG(Record_Buffer(self), iField))
10856>>>>>  End_Function
10857>>>>>
10857>>>>>
10857>>>>>
10857>>>>>  //************************************************************************//
10857>>>>>  // Procedure to set the message to be send on item validation.            //
10857>>>>>  //************************************************************************//
10857>>>>>
10857>>>>>  Procedure Set Field_Validate_msg Integer iField Integer iMsg
10859>>>>>    Set Item_Validate_MSG of (Record_Buffer(Self)) iField to iMsg
10860>>>>>  End_Procedure
10861>>>>>
10861>>>>>  //************************************************************************//
10861>>>>>  // Function to return the message to be send on item validation.          //
10861>>>>>  //************************************************************************//
10861>>>>>
10861>>>>>  Function Field_Validate_msg Integer iField Returns Integer
10863>>>>>    Function_Return (Item_Validate_MSG(Record_Buffer(self), iField))
10864>>>>>  End_Function
10865>>>>>
10865>>>>>
10865>>>>>
10865>>>>>  //************************************************************************//
10865>>>>>  // Set/Get Field_Prompt_Object                                            //
10865>>>>>  // Set/Get Field_Zoom_Object                                              //
10865>>>>>  // Used to Get/Set the Prompt_Object for a Field.                         //
10865>>>>>  //************************************************************************//
10865>>>>>
10865>>>>>  Procedure Set Field_Prompt_Object Integer iField Integer iObj
10867>>>>>    Set Prompt_Object of (Record_Buffer(self)) iField to iObj
10868>>>>>  End_Procedure
10869>>>>>
10869>>>>>  Function Field_Prompt_Object Integer iField Returns Integer
10871>>>>>    integer iObj
10871>>>>>    Get Prompt_Object of (Record_Buffer(self)) iField to iObj
10872>>>>>    If iObj eq 0 ;       Get Prompt_Object of (Field_Attributes(Self)) iField to iObj
10875>>>>>    Function_Return iObj
10876>>>>>  End_Function
10877>>>>>
10877>>>>>  Procedure Set Field_Zoom_Object Integer iField Integer iObj
10879>>>>>    Set Zoom_Object of (Record_Buffer(Self)) iField to iObj
10880>>>>>  End_Procedure
10881>>>>>
10881>>>>>  Function Field_Zoom_Object Integer iField Returns Integer
10883>>>>>    Function_Return (Zoom_Object(Record_Buffer(self), iField))
10884>>>>>  End_Function
10885>>>>>
10885>>>>>
10885>>>>>  Procedure Set Field_WebPrompt_Object Integer iField Handle hoObj
10887>>>>>      Set Field_WebPrompt_Object of FieldMask_Array iField to hoObj
10888>>>>>  End_Procedure
10889>>>>>
10889>>>>>  Function Field_WebPrompt_Object Integer iField Returns Handle
10891>>>>>    Handle hoPrompt
10891>>>>>    Get Field_WebPrompt_Object of FieldMask_Array iField to hoPrompt
10892>>>>>    Function_Return hoPrompt
10893>>>>>  End_Function
10894>>>>>
10894>>>>>
10894>>>>>  //************************************************************************//
10894>>>>>  // Set/Get File_Field_Prompt_Object                                       //
10894>>>>>  // Set/Get File_Field_Zoom_Object                                         //
10894>>>>>  // Used to Get/Set the Prompt_Object for a Field.                         //
10894>>>>>  //************************************************************************//
10894>>>>>
10894>>>>>  Function File_Field_Prompt_Object Integer iFile Integer iField Returns Integer
10896>>>>>    Integer iObj
10896>>>>>    Get File_Field_Property iFile iField GET_Field_Prompt_Object to iObj
10897>>>>>    Function_Return iObj
10898>>>>>  End_Function
10899>>>>>
10899>>>>>  Function File_Field_Zoom_Object Integer iFile Integer iField Returns Integer
10901>>>>>    Integer iObj
10901>>>>>    Get File_Field_Property iFile iField GET_Field_Zoom_Object to iObj
10902>>>>>    Function_Return iObj
10903>>>>>  End_Function
10904>>>>>
10904>>>>>  Function File_Field_WebPrompt_Object Integer iFile Integer iField Returns Handle
10906>>>>>    Handle hoPrompt
10906>>>>>    Get File_Field_Property iFile iField GET_Field_WebPrompt_Object to hoPrompt
10907>>>>>    Function_Return hoPrompt
10908>>>>>  End_Function
10909>>>>>
10909>>>>>  //************************************************************************//
10909>>>>>  // Get Field_Validation_Type                                              //
10909>>>>>  // Return the extended validation type for this field.                    //
10909>>>>>  //************************************************************************//
10909>>>>>
10909>>>>>  Function Field_Validation_Type Integer iField Returns Integer
10911>>>>>    Integer iType
10911>>>>>    Get Field_Validation_Type of (Field_Attributes(self)) iField ;        to iType
10912>>>>>    Function_Return iType
10913>>>>>  End_Function
10914>>>>>
10914>>>>>  //************************************************************************//
10914>>>>>  // Procedure Set Field_Value_Range                                        //
10914>>>>>  // Procedure to define a valid value range for a field.                   //
10914>>>>>  //************************************************************************//
10914>>>>>
10914>>>>>  Procedure Set Field_Value_Range Integer iField String sMin String sMax
10916>>>>>    Set Field_Value_Range of (Field_Attributes(self)) iField ;        to sMin sMax
10917>>>>>  End_Procedure
10918>>>>>
10918>>>>>
10918>>>>>  //************************************************************************//
10918>>>>>  // Required Messaging to Support Validation Tables                        //
10918>>>>>  //************************************************************************//
10918>>>>>
10918>>>>>  //************************************************************************//
10918>>>>>  // Procedure Set Field_Value_Table                                        //
10918>>>>>  // Procedure to define a validate table for a field.                      //
10918>>>>>  //************************************************************************//
10918>>>>>
10918>>>>>  Procedure Set Field_Value_Table Integer iField integer iObj
10920>>>>>    Set Field_Value_Table of (Field_Attributes(self)) iField ;        to iObj
10921>>>>>  End_Procedure
10922>>>>>
10922>>>>>  //************************************************************************//
10922>>>>>  // File_Field_Fill_List                                                   //
10922>>>>>  // Field_Fill_List                                                        //
10922>>>>>  // This provides a callback to the calling object (iObj) by passing this  //
10922>>>>>  // object the message iMsg for each item in the table. Note this works for//
10922>>>>>  // all extended validation types (range, check, etc.)                     //
10922>>>>>  //************************************************************************//
10922>>>>>
10922>>>>>  Procedure Field_Fill_List integer iField integer iObj integer iMsg
10924>>>>>    Send Field_Fill_list to (Field_Attributes(self)) ;                               iField iObj iMsg
10925>>>>>  End_Procedure
10926>>>>>
10926>>>>>  Procedure File_Field_Fill_List integer iFile integer iField ;                                 integer iObj integer iMsg
10928>>>>>    integer iDSO
10928>>>>>    Get Data_set iFile to iDSO
10929>>>>>    If iDSO ;      Send Field_Fill_list to iDSO iField iObj iMsg
10932>>>>>  End_Procedure
10933>>>>>
10933>>>>>  //************************************************************************//
10933>>>>>  // Get Field_table_Object                                                 //
10933>>>>>  // Get File_Field_table_object                                            //
10933>>>>>  // Returns the ID if any of the validation table for this object.         //
10933>>>>>  //************************************************************************//
10933>>>>>
10933>>>>>  Function Field_Table_Object integer iField Returns integer
10935>>>>>      integer iRval
10935>>>>>      Get Field_Table_Object of (Field_Attributes(self)) iField to iRVal
10936>>>>>      Function_Return iRVal
10937>>>>>  End_Function
10938>>>>>
10938>>>>>  Function File_Field_Table_Object integer iFile integer iField Returns integer
10940>>>>>    integer iDSO
10940>>>>>    Get Data_set iFile to iDSO
10941>>>>>    If iDSO ;      Function_Return (Field_Table_Object(iDSO,iField))
10944>>>>>  End_Function
10945>>>>>
10945>>>>>  //************************************************************************//
10945>>>>>  // Get Field_table_Descripton                                             //
10945>>>>>  // Returns code description value for the passed string for the           //
10945>>>>>  // passed validation table object. Normally use field_value_description   //
10945>>>>>  //************************************************************************//
10945>>>>>
10945>>>>>  Function Validation_Table_Description integer iObj String sVal Returns string
10947>>>>>    string sDesc
10947>>>>>    If iObj get Find_Code_Description of iObj sVal to sDesc
10950>>>>>    Function_Return sDesc
10951>>>>>  End_Function
10952>>>>>
10952>>>>>  //************************************************************************//
10952>>>>>  // Get Field_Current_description                                          //
10952>>>>>  // Get File_Field_Current_description                                     //
10952>>>>>  // Returns the description value for the field's code value. This only    //
10952>>>>>  // works if you have a validation table - else it returns the field value //
10952>>>>>  //************************************************************************//
10952>>>>>
10952>>>>>  Function Field_Current_Description integer iField Returns string
10954>>>>>    string sDesc
10954>>>>>    string sVal
10954>>>>>    integer iObj
10954>>>>>    Get Field_Current_Value iField to sVal
10955>>>>>    Get Field_Table_Object iField to iObj
10956>>>>>    If iObj Begin
10958>>>>>       get Validation_Table_Description iObj sVal to sDesc
10959>>>>>       if (sDesc="") Move sVal to sDesc // if desc is blank, use value
10962>>>>>    End
10962>>>>>>
10962>>>>>    Else ;       Move sVal to sDesc
10964>>>>>    Function_Return sDesc
10965>>>>>  End_Function
10966>>>>>
10966>>>>>  Function File_Field_Current_Description integer iFile integer iField Returns string
10968>>>>>    integer iDSO
10968>>>>>    Get Data_set iFile to iDSO
10969>>>>>    If iDSO ;      Function_Return (Field_Current_Description(iDSO,iField))
10972>>>>>  End_Function
10973>>>>>
10973>>>>>
10973>>>>>  //************************************************************************//
10973>>>>>  // Required Messaging to Support Checkbox items in DEOs                   //
10973>>>>>  //************************************************************************//
10973>>>>>
10973>>>>>  //************************************************************************//
10973>>>>>  // Procedure Set Field_Checkbox_Values                                    //
10973>>>>>  //  Defines a field as a two item field and defines True and False values //
10973>>>>>  //************************************************************************//
10973>>>>>
10973>>>>>  Procedure Set Field_CheckBox_Values Integer iField String sTrue String sFalse
10975>>>>>    Set Field_CheckBox_Values of (Field_Attributes(self)) iField ;        to sTrue sFalse
10976>>>>>  End_Procedure
10977>>>>>
10977>>>>>  //************************************************************************//
10977>>>>>  // Function Field_Value_select_State                                      //
10977>>>>>  //    Returns a field's select_State based on the pased value             //
10977>>>>>  // Function Field_select_State                                            //
10977>>>>>  //    Returns a field's select_State based on the DD buffer contents      //
10977>>>>>  //************************************************************************//
10977>>>>>
10977>>>>>  Function Field_Value_Select_State Integer iField String sValue returns integer
10979>>>>>    Function_Return (Field_Value_Select_State(Field_Attributes(self),iField,sValue))
10980>>>>>  End_Function // File_Value_Field_Select_State
10981>>>>>
10981>>>>>  Function Field_Select_State Integer iField returns integer
10983>>>>>    String sValue
10983>>>>>    Get Field_Current_Value iField to sValue
10984>>>>>    Function_Return (Field_Value_Select_State(self,iField,sValue))
10985>>>>>  End_Function // File_Field_Select_State
10986>>>>>
10986>>>>>  //************************************************************************//
10986>>>>>  // Function File_Field_select_State                                       //
10986>>>>>  //   Returns a file/field' select_State based on contents of DD buffer    //
10986>>>>>  // Function File_Field_Value_select_State                                 //
10986>>>>>  //   Returns a file/field' select_State based on passed value             //
10986>>>>>  //************************************************************************//
10986>>>>>
10986>>>>>  Function File_Field_Select_State Integer iFile integer iField returns integer
10988>>>>>    integer iDSO
10988>>>>>    Get Data_set iFile to iDSO
10989>>>>>    If iDSO ;       Function_Return (Field_Select_State(iDSO,iField))
10992>>>>>  End_Function // File_Field_Select_State
10993>>>>>
10993>>>>>  Function File_Field_Value_Select_State Integer iFile integer iField ;                                         String sValue returns integer
10995>>>>>    integer iDSO
10995>>>>>    Get Data_set iFile to iDSO
10996>>>>>    If iDSO ;       Function_Return (Field_Value_Select_State(iDSO,iField,sValue))
10999>>>>>  End_Function // File_Field_Select_State
11000>>>>>
11000>>>>>  //************************************************************************//
11000>>>>>  // Function Field_Checkbox_Value                                          //
11000>>>>>  // Function File_Field_Checkbox_Value                                     //
11000>>>>>  // get the actual database value that corresponds to the boolean value    //
11000>>>>>  // passed.                                                                //
11000>>>>>  //************************************************************************//
11000>>>>>
11000>>>>>  Function Field_CheckBox_Value Integer iField Integer iState returns String
11002>>>>>    Function_Return (Field_Checkbox_Value(Field_Attributes(self),iField,iState))
11003>>>>>  End_Function
11004>>>>>
11004>>>>>  Function File_Field_CheckBox_Value Integer iFile Integer iField Integer iState returns String
11006>>>>>    integer iDSO
11006>>>>>    Get Data_set iFile to iDSO
11007>>>>>    If iDSO ;       Function_Return (Field_Checkbox_Value(iDSO,iField,iState))
11010>>>>>  End_Function
11011>>>>>
11011>>>>>  //************************************************************************//
11011>>>>>  // Procedure Set Field_select_State                                       //
11011>>>>>  // Set the buffer's value based on the state passed. This notifies DEOs   //
11011>>>>>  // if needed (set Field_Current_Value does this)                          //
11011>>>>>  //************************************************************************//
11011>>>>>
11011>>>>>  Procedure Set Field_Select_State integer iField integer iState
11013>>>>>    string sValue
11013>>>>>    Get Field_Checkbox_Value iField iState to sValue
11014>>>>>    Set Field_Current_Value iField to sValue
11015>>>>>  End_Procedure // Set Field_Select_State
11016>>>>>
11016>>>>>  //************************************************************************//
11016>>>>>  // Procedure Set File_Field_select_State                                  //
11016>>>>>  // Set the buffer's value based on the state passed. This notifies DEOs   //
11016>>>>>  // if needed (set Field_Current_Value does this). First finds proper file //
11016>>>>>  // DSO                                                                    //
11016>>>>>  //************************************************************************//
11016>>>>>
11016>>>>>  Procedure Set File_Field_Select_State Integer iFile Integer iField Integer iState
11018>>>>>    integer iDSO
11018>>>>>    Get Data_set iFile to iDSO
11019>>>>>    If iDSO ;      Set Field_Select_State of iDSO iField to iState
11022>>>>>  End_Procedure // Set File_Field_Select_State
11023>>>>>
11023>>>>>
11023>>>>>  //************************************************************************//
11023>>>>>  // Procedure Set Field_Value_Check                                        //
11023>>>>>  // Procedure to define a check string for a field.                        //
11023>>>>>  //************************************************************************//
11023>>>>>
11023>>>>>  Procedure Set Field_Value_Check Integer iField String sCheck
11025>>>>>    Set Field_Value_Check of (Field_Attributes(self)) iField ;        to sCheck
11026>>>>>  End_Procedure
11027>>>>>
11027>>>>>
11027>>>>>
11027>>>>>  //************************************************************************//
11027>>>>>  // Function Exec_Field_Message                                            //
11027>>>>>  // This function will be called indirectly by DEOs when an item is being  //
11027>>>>>  // entered, exited or needs validation. The first argument holds the      //
11027>>>>>  // fieldnumber for the field and the second holds the id of the message   //
11027>>>>>  // which can be send to retrieve the message which needs to be send for   //
11027>>>>>  // this Field/Event combination. The value of the second argument can be  //
11027>>>>>  // GET_Field_Entry_MSG, GET_Field_Exit_MSG or GET_Field_Validate_MSG.     //
11027>>>>>  //************************************************************************//
11027>>>>>
11027>>>>>  Function Exec_Field_Message Integer iField Integer iMsg_ID returns integer
11029>>>>>    Integer iMsg
11029>>>>>    Integer iResult
11029>>>>>    String  sValue
11029>>>>>    Get iMsg_ID iField to iMsg
11030>>>>>    If iMsg Begin
11032>>>>>      Get Field_Current_Value iField to sValue
11033>>>>>      Get iMsg iField sValue to iResult
11034>>>>>    End
11034>>>>>>
11034>>>>>    Function_Return iResult
11035>>>>>  End_Function
11036>>>>>
11036>>>>>
11036>>>>>
11036>>>>>  //************************************************************************//
11036>>>>>  // Function Exec_File_Field_Message                                       //
11036>>>>>  // This function will be called from within DEOs when an item is being    //
11036>>>>>  // entered, exited or needs validation. The first argument holds the      //
11036>>>>>  // file number, the second argument holds the field and the third         //
11036>>>>>  // holds the id of the message  which can be send to retrieve the message //
11036>>>>>  // which needs to be send for this File/Field/Event combination.          //
11036>>>>>  // The value of the second argument can be  GET_Field_Entry_MSG,          //
11036>>>>>  // GET_Field_Exit_MSG or GET_Field_Validate_MSG.                          //
11036>>>>>  // This will redirect to the proper data-set object.                      //
11036>>>>>  //************************************************************************//
11036>>>>>
11036>>>>>  Function Exec_File_Field_Message Integer iFile Integer iField Integer iMsg_ID returns integer
11038>>>>>    Integer iDSO
11038>>>>>    Integer iResult
11038>>>>>    Get Data_set iFile to iDSO
11039>>>>>    If iDSO ;      Get Exec_Field_Message of iDSO iField iMsg_ID to iResult
11042>>>>>    Function_Return iResult
11043>>>>>  End_Function
11044>>>>>
11044>>>>>
11044>>>>>
11044>>>>>  //************************************************************************//
11044>>>>>  // Function Data_Set                                                      //
11044>>>>>  // Find the data-set whose main_file is the same as File#. The message    //
11044>>>>>  // Which_data_set includes updating parent files, we will throw those out.//
11044>>>>>  // This has been augmented to search down the DDO tree if we do not find  //
11044>>>>>  // the DD with our quick C Which_Data_set search                          //
11044>>>>>  //************************************************************************//
11044>>>>>
11044>>>>>  Function Data_Set Integer iFile Returns Integer
11046>>>>>     Integer iTmp
11046>>>>>     Integer iDSO
11046>>>>>     Get Main_File to iTmp
11047>>>>>     If iTmp EQ iFile ;         Function_Return self
11050>>>>>     Get Which_Data_Set iFile to iDSO
11051>>>>>     If iDSO Begin
11053>>>>>         // check that DS's main-file is the File (and not a parent file)
11053>>>>>         Get Main_File of iDSO to iTmp
11054>>>>>         If iTmp EQ iFile ;            Function_Return iDSO
11057>>>>>     End
11057>>>>>>
11057>>>>>
11057>>>>>     // This really should have succeeded by now. If not we need to do a
11057>>>>>     // downward sweep looking for DD. This will be a slower process since it
11057>>>>>     // involves flex level DDO structure traversal. We should very rarely ever
11057>>>>>     // get to this point. If we do, it takes longer!
11057>>>>>
11057>>>>>     // Unlike other traversals we will mark and check in a single
11057>>>>>     // step.
11057>>>>>     // This Mark_Id creates a sequence Id for this clear. This way
11057>>>>>     // DSOs only get cleared one time during this process.
11057>>>>>     If DD_Current_Mark_ID ge 65536 Move 0 to DD_Current_Mark_id
11060>>>>>     Increment DD_Current_Mark_id
11061>>>>>     Get Private.Data_set iFile to iDSO // this does the recursive downward search
11062>>>>>     Function_Return iDSO
11063>>>>>  End_Function
11064>>>>>
11064>>>>>  Function Private.Data_Set integer iFile Returns Integer
11066>>>>>     Integer iMax
11066>>>>>     Integer iDSO hDD
11066>>>>>     Integer iCount
11066>>>>>
11066>>>>>     If (iFile=Main_file(self)) Function_return self
11069>>>>>
11069>>>>>     // We are only looking at sequence ID.
11069>>>>>     Set Last_Mark_Sequence_id to DD_Current_mark_id
11070>>>>>
11070>>>>>     // recurse Down first, since we already tried upward direction.
11070>>>>>     Get Data_Set_Client_Count to iMax
11071>>>>>     Decrement iMax
11072>>>>>     For iCount from 0 to iMax
11078>>>>>>
11078>>>>>          Get Data_Set_Client iCount to iDSO
11079>>>>>          // If already cleared during this sequence...do nothing
11079>>>>>          If (Last_Mark_Sequence_id(iDSO)<>DD_Current_mark_id) Begin
11081>>>>>              Get Private.Data_Set of iDSO iFile to hDD
11082>>>>>              If hDD Function_return hDD // when found...get out
11085>>>>>          End
11085>>>>>>
11085>>>>>     Loop
11086>>>>>>
11086>>>>>     // recurse up server list next. We do this 2nd because it is
11086>>>>>     // the less likely path for success.
11086>>>>>     Get Data_Set_Server_Count to iMax
11087>>>>>     Decrement iMax
11088>>>>>     For iCount from 0 to iMax
11094>>>>>>
11094>>>>>          Get Data_Set_Server iCount to iDSO
11095>>>>>          // If already cleared during this sequence...do nothing
11095>>>>>          If (Last_Mark_Sequence_id(iDSO)<>DD_Current_mark_id) Begin
11097>>>>>              Get Private.Data_Set of iDSO iFile to hDD
11098>>>>>              If hDD Function_return hDD // when found...get out
11101>>>>>          End
11101>>>>>>
11101>>>>>     Loop
11102>>>>>>
11102>>>>>     Function_Return 0 // if here, our traversal has failed.
11103>>>>>  End_Function // Private.Data_set
11104>>>>>
11104>>>>>  //************************************************************************//
11104>>>>>  // Function File_Field_Property                                           //
11104>>>>>  // Procedure Set File_Field_Property                                      //
11104>>>>>  // These methods can be used to set/get a field property in a flexible    //
11104>>>>>  // way. The first two argument are the file- and fieldnumber followed by  //
11104>>>>>  // the ID of the message that should be send. The last argument should    //
11104>>>>>  // be the value to set or the variable to store the value in.             //
11104>>>>>  //************************************************************************//
11104>>>>>
11104>>>>>  Procedure Set File_Field_Property Integer iFile Integer iField Integer iMsg String sValue
11106>>>>>    Integer iDSO
11106>>>>>    Get Data_Set iFile to iDSO
11107>>>>>    If iDSO Begin
11109>>>>>      Set iMsg of iDSO iField to sValue
11110>>>>>      Function_Return sValue
11111>>>>>    End
11111>>>>>>
11111>>>>>  End_Procedure
11112>>>>>
11112>>>>>  Function File_Field_Property Integer iFile Integer iField Integer iMsg returns integer
11114>>>>>    Integer iDSO
11114>>>>>    String  sValue
11114>>>>>    Get Data_Set iFile to iDSO
11115>>>>>    If iDSO Begin
11117>>>>>      Get iMsg of iDSO iField to sValue
11118>>>>>      Function_Return sValue
11119>>>>>    End
11119>>>>>>
11119>>>>>  End_Function
11120>>>>>
11120>>>>>
11120>>>>>
11120>>>>>  //************************************************************************//
11120>>>>>  // This procedure will return the number of fields in the object          //
11120>>>>>  //************************************************************************//
11120>>>>>
11120>>>>>  Function Field_Count Returns Integer
11122>>>>>     Function_Return (Item_Count(Record_Buffer(self)) - 1)
11123>>>>>  End_Function // Field_Count
11124>>>>>
11124>>>>>  //************************************************************************//
11124>>>>>  // This procedure will clear all flags in the visited_fields string so    //
11124>>>>>  // that all field will be validated on the next requests.                 //
11124>>>>>  //************************************************************************//
11124>>>>>
11124>>>>>  Procedure Clear_Visited_Fields
11126>>>>>    // this clears field visitation marks
11126>>>>>    Set Visited_Fields To (Repeat(" ", Field_Count(self)))
11127>>>>>  End_Procedure // Clear_Viisted_Fields
11128>>>>>
11128>>>>>
11128>>>>>  //************************************************************************//
11128>>>>>  // Private.Initialize_Visited                                             //
11128>>>>>  // This procedure will be called when validations (and perhaps other      //
11128>>>>>  // events) is requested. It clears the visited marks and then proceeds    //
11128>>>>>  // to clear the marks up the server tree.                                 //
11128>>>>>  // This is passed two parameters: Up_and_down, If true upward and downward//
11128>>>>>  // initialize. If Clear_Fields also clear the field string                //
11128>>>>>  //************************************************************************//
11128>>>>>
11128>>>>>  Procedure Private.Initialize_Visited integer Up_and_Down integer Clear_Fields
11130>>>>>    Integer iMax
11130>>>>>    Integer iDSO
11130>>>>>    Integer iCount
11130>>>>>
11130>>>>>    // recurse up server list first. Only recurse up
11130>>>>>    Get Data_Set_Server_Count to iMax
11131>>>>>    Decrement iMax
11132>>>>>    For iCount from 0 to iMax
11138>>>>>>
11138>>>>>        Get Data_Set_Server iCount to iDSO
11139>>>>>        // If already cleared during this sequence...do nothing
11139>>>>>        If (Last_Mark_Sequence_id(iDSO)<>DD_Current_mark_id) ;           Send Private.Initialize_Visited to iDSO FALSE Clear_Fields
11142>>>>>    Loop
11143>>>>>>
11143>>>>>
11143>>>>>    If Clear_Fields Send Clear_Visited_Fields // clear all markers in this object
11146>>>>>    // this clears the visited mark for the entire object
11146>>>>>    Set Visited_State to False
11147>>>>>    Set Last_Mark_Sequence_id to DD_Current_mark_id
11148>>>>>
11148>>>>>    // If Up_and_Down recurse Down server list
11148>>>>>    If Up_and_Down Begin
11150>>>>>       Get Data_Set_Client_Count to iMax
11151>>>>>       Decrement iMax // **EK** This line was missing
11152>>>>>       For iCount from 0 to iMax
11158>>>>>>
11158>>>>>           Get Data_Set_Client iCount to iDSO
11159>>>>>           // If already cleared during this sequence...do nothing
11159>>>>>           If (Last_Mark_Sequence_id(iDSO)<>DD_Current_mark_id) ;              Send Private.Initialize_Visited to iDSO TRUE Clear_Fields
11162>>>>>       Loop
11163>>>>>>
11163>>>>>    End
11163>>>>>>
11163>>>>>  End_Procedure // Private.Initialize_Visited
11164>>>>>
11164>>>>>  //************************************************************************//
11164>>>>>  // Initialize_Visted                                                      //
11164>>>>>  // Clears Visited marks and (maybe) field visited marks in all required   //
11164>>>>>  // DSOs. If Up_and_Down is TRUE DSOs are marked up and Down (delete style)//
11164>>>>>  // propagation. If False, DSOs are marked up (save style). This does not  //
11164>>>>>  // have a mode to mark ALL DSOs in a structure. (Not needed so far).      //
11164>>>>>  // If Clear_Fields is T the field string marker is also cleared.          //
11164>>>>>  // The method of using the global integer DD_Current_Mark_ID is an opt-   //
11164>>>>>  // imizer. This is private - do not tamper with it!                       //
11164>>>>>  //************************************************************************//
11164>>>>>
11164>>>>>  Procedure Initialize_Visited integer Up_and_Down integer Clear_Fields
11166>>>>>     // This Mark_Id creates a sequence Id for this clear. This way
11166>>>>>     // DSOs only get cleared one time during this process.
11166>>>>>     If DD_Current_Mark_ID ge 65536 Move 0 to DD_Current_Mark_id
11169>>>>>     Increment DD_Current_Mark_id
11170>>>>>     Send Private.Initialize_Visited Up_and_Down Clear_Fields
11171>>>>>  End_Procedure // Initialize_Visited
11172>>>>>
11172>>>>>
11172>>>>>  //************************************************************************//
11172>>>>>  // Private.Valid_Structure                                                //
11172>>>>>  // Internal recursive message to check file connections. Called from      //
11172>>>>>  // Valid_connections only. Private message                                //
11172>>>>>  //************************************************************************//
11172>>>>>
11172>>>>>  Function Private.Valid_Structure Integer Up_And_Down Returns Integer
11174>>>>>      integer iRval
11174>>>>>      integer iCount
11174>>>>>      integer iMax
11174>>>>>      integer iDSO
11174>>>>>
11174>>>>>      // Check Current Connections
11174>>>>>      Get Valid_Servers to iRval           // always check servers
11175>>>>>      If (iRval=0 and Up_and_Down) ;       // check Clients if required         Get Valid_Clients to iRval
11178>>>>>      Set Visited_State to TRUE
11179>>>>>
11179>>>>>      // Ask Server data-sets to check their server connections
11179>>>>>      If Not iRval Begin // check up
11181>>>>>         Get Data_Set_Server_Count to iMax
11182>>>>>         Decrement iMax
11183>>>>>         For iCount from 0 to iMax
11189>>>>>>
11189>>>>>             Get Data_Set_Server iCount to iDSO
11190>>>>>             If Not (Visited_state(iDSO)) ;                Get Private.Valid_Structure of iDSO False to iRVal
11193>>>>>         Until iRval
11195>>>>>      End
11195>>>>>>
11195>>>>>
11195>>>>>      // If required, Ask Clients to check their server and client connections
11195>>>>>      If (iRval=0 AND Up_and_Down) Begin // check down
11197>>>>>         Get Data_Set_Client_Count to iMax
11198>>>>>         Decrement iMax
11199>>>>>         For iCount from 0 to iMax
11205>>>>>>
11205>>>>>             Get Data_Set_Client iCount to iDSO
11206>>>>>             If Not (Visited_state(iDSO)) ;                Get Private.Valid_Structure of iDSO True to iRVal
11209>>>>>         Until iRval
11211>>>>>      End
11211>>>>>>
11211>>>>>
11211>>>>>      Function_return iRVal
11212>>>>>
11212>>>>>  End_Function
11213>>>>>
11213>>>>>
11213>>>>>  //************************************************************************//
11213>>>>>  // Valid_Structure                                                        //
11213>>>>>  // Validate data-set updating connections against required connections    //
11213>>>>>  // Pass: Up_and_down=T if we should check Server and Client connections   //
11213>>>>>  //                  =F is we only check servers                           //
11213>>>>>  // Ret: 0 if ok, Missing File# if not ok.                                 //
11213>>>>>  //************************************************************************//
11213>>>>>
11213>>>>>  Function Valid_Structure Integer Up_And_Down Returns Integer
11215>>>>>    Send Initialize_Visited Up_and_Down False // False=don't clear field marks
11216>>>>>    Function_Return (Private.Valid_Structure(self,Up_and_Down))
11217>>>>>  End_Function
11218>>>>>
11218>>>>>
11218>>>>>
11218>>>>>  //************************************************************************//
11218>>>>>  // Validate_Fields                                                        //
11218>>>>>  // This function will execute the validation message for each field within//
11218>>>>>  // this object. If DoAllFG is true all items are validated. If false      //
11218>>>>>  // only unvisited items are checked.                                      //
11218>>>>>  // Added bNoStop, If true, all items are validated. It is up to you to    //
11218>>>>>  // do something with the possible cascade of errors                       //
11218>>>>>  // if the err returns DFERR_ENTER_VALID_REC_ID we will not continue       //
11218>>>>>  // the validation (the other fields will be bad). This works best if the  //
11218>>>>>  // findreq appears as one of the first fields in the file (which is almost//
11218>>>>>  // always the case                                                        //
11218>>>>>  //************************************************************************//
11218>>>>>
11218>>>>>  Function Validate_Fields integer DoAllFg integer bNoStop Returns Integer
11220>>>>>    Integer iRetval
11220>>>>>    Integer iMax
11220>>>>>    Integer iCount
11220>>>>>    Integer iFile
11220>>>>>    integer iErr
11220>>>>>    String  sVS
11220>>>>>    Get Visited_Fields To sVS
11221>>>>>    Get Field_Count To iMax
11222>>>>>    Get Main_File to iFile
11223>>>>>    For iCount From 1 To iMax
11229>>>>>>
11229>>>>>      If (DoAllFG OR Mid(sVS, 1, iCount)=" ") Begin
11231>>>>>        Get Validate_Field iCount to iErr
11232>>>>>        If iErr Begin
11234>>>>>           Move iErr to iRetVal
11235>>>>>           // error occured. If not no-stop or the error is
11235>>>>>           // a findreq error - we are done.
11235>>>>>           If (not(bNoStop) OR iRetVal=DFERR_ENTER_VALID_REC_ID) ;               Function_return iRetVal
11238>>>>>        end
11238>>>>>>
11238>>>>>      end
11238>>>>>>
11238>>>>>    Loop
11239>>>>>>
11239>>>>>    Function_Return iRetval
11240>>>>>  End_Function
11241>>>>>
11241>>>>>  //************************************************************************//
11241>>>>>  // Function Validate_Required                                             //
11241>>>>>  //************************************************************************//
11241>>>>>
11241>>>>>  // 17.0 - added support for null-parents. If null parents allowed, req lets it through
11241>>>>>  Function Validate_Required Integer iField Returns Integer
11243>>>>>    Boolean bNull bErr
11243>>>>>//    Handle[] hoDDs
11243>>>>>//    Integer iMain
11243>>>>>    
11243>>>>>    Move (trim(Field_Current_Value(Self,iField))='') to bErr
11244>>>>>    
11244>>>>>//    // if blank we must check if an exception is made for a null parent.
11244>>>>>//    If (bErr  and OPERATION_ORIGIN<>Self and not(HasRecord(Self)) and not(field_changed_state(Self,iField))) Begin
11244>>>>>//        // we must find the child that points to this DD, starting with operation_origin. If a child
11244>>>>>//        // is found, it will be in array position 1 (0 is self, 1 is child)
11244>>>>>//        Send DDOServerPath of operation_origin Self (&hoDDs) 
11244>>>>>//        If (SizeOfArray(hoDDs)) Begin
11244>>>>>//           Get Main_File to iMain
11244>>>>>//           Get IsNullParentAllowed of hoDDs[1] iMain to bNull
11244>>>>>//           Move (not(bNull)) to bErr
11244>>>>>//        End
11244>>>>>//    End
11244>>>>>
11244>>>>>    If bErr ;        Send Data_set_Error iField DFERR_ENTRY_REQUIRED ""
11247>>>>>    Function_Return bErr
11248>>>>>  End_Function
11249>>>>>
11249>>>>>  //************************************************************************//
11249>>>>>  // Function Validate_FindReq                                              //
11249>>>>>  //************************************************************************//
11249>>>>>
11249>>>>>    
11249>>>>>     // return true if we should skip validation for this field. This can happen with Null allowed parents.
11249>>>>>     // if this is foreign, new and has no changes and is null allowed we will skip. 
11249>>>>>    Function SkipValidate Integer iField Returns Boolean
11251>>>>>        Boolean bSkip bFieldChanged bEmpty
11251>>>>>        String sValue
11251>>>>>
11251>>>>>        If (OPERATION_ORIGIN<>Self and not(HasRecord(Self)) and not(changed_state(Self))) Begin
11253>>>>>            // We must also check field_changed_state and only skip if this is not changed.
11253>>>>>            Get Field_Changed_State iField to bFieldChanged
11254>>>>>            // Retain and remember may set field_changed_state to true even when empty. If this field is changed
11254>>>>>            // but its value is empty we assume it is a candidate for Null checking, so we will set field-changed to false
11254>>>>>            If bFieldChanged Begin
11256>>>>>                Get Field_Current_Value iField to sValue
11257>>>>>                Get IsEmptyField iField sValue to bEmpty
11258>>>>>                If bEmpty Begin
11260>>>>>                    Move False to bFieldChanged
11261>>>>>                End
11261>>>>>>
11261>>>>>            End
11261>>>>>>
11261>>>>>            If (not(bFieldChanged)) Begin    
11263>>>>>                // we must find the child that points to this DD, starting with operation_origin. If a child
11263>>>>>                // is found, it will be in array position 1 (0 is self, 1 is child)
11263>>>>>                Get IsNullParentOrAncestor to bSkip
11264>>>>>            End
11264>>>>>>
11264>>>>>        End
11264>>>>>>
11264>>>>>        Function_Return bSkip
11265>>>>>    End_Function
11266>>>>>    
11266>>>>>    
11266>>>>>    // This will tell us if this DD can be treated as either a null parent
11266>>>>>    // or an ancestor of a null parent. This should only be called for a DD
11266>>>>>    // that is a candidate for this meaning that it does not have a change. 
11266>>>>>    // We will test if its child allows this parent to be null or if this
11266>>>>>    // is in the path of an allowed null parent. We assume that parents of
11266>>>>>    // null parents will also be null. This is used to test if validations are
11266>>>>>    // needed.
11266>>>>>    Function IsNullParentOrAncestor Returns Boolean 
11268>>>>>        Handle[] hoDDs
11269>>>>>        Integer i iSize iMain
11269>>>>>        Boolean bNullAllowed
11269>>>>>        // gets an array where 0 is self, 1 is parent, 2 is grandparent, and the
11269>>>>>        // last item is the operation_origin.
11269>>>>>        Send DDOServerPath of operation_origin Self (&hoDDs) 
11270>>>>>        Move (SizeOfArray(hoDDs)) to iSize
11271>>>>>        If (iSize) Begin
11273>>>>>           // see if the immediate child allows this to be null. 
11273>>>>>           Get Main_File to iMain
11274>>>>>           Get IsNullParentAllowed of hoDDs[1] iMain to bNullAllowed
11275>>>>>           
11275>>>>>           // if null not allowed, see if this is an ancestor to a null allowed
11275>>>>>           // parent where all DDs in this path are unchanged. For example:
11275>>>>>           // G.DD <- P.DD <- C.DD where we C.DD allows P.DD to be null and we
11275>>>>>           // want to test if G.DD needs validation
11275>>>>>           Move 1 to i
11276>>>>>           While (not(bNullAllowed) and (i+1<iSize) and not(changed_state(hoDDs[i])) )
11280>>>>>               Get Main_File of hoDDs[i] to iMain
11281>>>>>               Get IsNullParentAllowed of hoDDs[i+1] iMain to bNullAllowed
11282>>>>>               Increment i
11283>>>>>           Loop
11284>>>>>>
11284>>>>>           
11284>>>>>        End
11284>>>>>>
11284>>>>>        Function_Return bNullAllowed
11285>>>>>    End_Function
11286>>>>>    
11286>>>>>
11286>>>>>  Function Validate_FindReq Integer iField Returns Integer
11288>>>>>    Integer bErr iOpts
11288>>>>>    // if no current record, we have not found the required record.
11288>>>>>    Move (not(HasRecord(Self))) to bErr
11289>>>>>    // We also need to check if the field is changed. If the field is changed and this
11289>>>>>    // is an autofind field, this indicates that an autofind was attempted and failed. We
11289>>>>>    // can't jut rely on current_record because a failed autofind restores the old current
11289>>>>>    // record. For this to work, DEOs must set the DD field's changed_state to true on
11289>>>>>    // no-put fields (dd_deomx.pkg was changed to do this).
11289>>>>>    If (not(bErr) and field_changed_state(Self,iField)) Begin
11291>>>>>       Get Field_Options iField to iOpts
11292>>>>>       Move ( ((iOpts iand DD_AUTOFIND)=DD_AUTOFIND) or ;              ((iOpts iand DD_AUTOFIND_GE)=DD_AUTOFIND_GE) ) ;                to bErr
11293>>>>>    End
11293>>>>>>
11293>>>>>    If bErr ;        Send Data_set_Error iField DFERR_ENTER_VALID_REC_ID ""
11296>>>>>    Function_Return bErr
11297>>>>>  End_Function
11298>>>>>
11298>>>>>  //************************************************************************//
11298>>>>>  // Function Validate_Field                                                //
11298>>>>>  // This function will be called to validate a field.                      //
11298>>>>>  // mark field currently being validated                                   //
11298>>>>>  // Altered to Check DD options (required, findreq)                        //
11298>>>>>  //************************************************************************//
11298>>>>>  
11298>>>>>  Function Validate_Field Integer iField Returns Integer
11300>>>>>    Integer iResult
11300>>>>>    Integer iMsg
11300>>>>>    Integer iObj
11300>>>>>    String  sValue
11300>>>>>    integer iFile
11300>>>>>    Integer iOpts iMain
11300>>>>>    Boolean bSkipValidate
11300>>>>>    Handle[] hoDDs
11301>>>>>
11301>>>>>    Set Current_Validate_Field to iField
11302>>>>>
11302>>>>>    // test if we should skip validation on this field
11302>>>>>    Get SkipValidate iField to bSkipValidate
11303>>>>>    
11303>>>>>    If (not(bSkipValidate)) Begin
11305>>>>>        
11305>>>>>        Move (Record_Buffer(Self)) to iObj
11306>>>>>        Get Main_File to iFile
11307>>>>>    
11307>>>>>        // Check for DD option failures: required, find_required
11307>>>>>        // "File_field" gets regular and foreign fields as needed
11307>>>>>        //Get File_Field_Options iFile iField to iOpts
11307>>>>>        Get Field_Options iField to iOpts  // get reg options
11308>>>>>        // if this is not the DDO that started the validation, we will assume that
11308>>>>>        // this is foreign. Operation_origin is set in Request_Validate
11308>>>>>        // If foreign (as defined above) and we do not allow new saves when
11308>>>>>        // foreign, we will consider this to be foreign and add foreign options
11308>>>>>        If (Operation_Origin<>Self and ;            Allow_Foreign_New_Save_State(Self)=0)  ;            Move (iOpts ior Foreign_Field_Options(Self, iField)) to iOpts
11311>>>>>
11311>>>>>
11311>>>>>        // Check for FindReq first. If it fails, set iResult to DFERR_ENTER_VALID_REC_ID so
11311>>>>>        // the calling function knows that a findreq failed. Always do this validation first
11311>>>>>        If (iOpts iand DD_FINDREQ)  Get Validate_FindReq  iField to iResult
11314>>>>>        If iResult Begin
11316>>>>>            Send AddDDHasFindReqError
11317>>>>>            Move DFERR_ENTER_VALID_REC_ID to iResult
11318>>>>>        End
11318>>>>>>
11318>>>>>        Else Begin
11319>>>>>            
11319>>>>>            If (iOpts iand DD_REQUIRED) Get Validate_Required iField to iResult
11322>>>>>        
11322>>>>>            If (iResult=0) Begin
11324>>>>>              // First execute the user defined validation message
11324>>>>>              Get Item_Validate_MSG of iObj iField to iMsg
11325>>>>>              If iMsg Begin
11327>>>>>                Get Field_Current_Value iField to sValue
11328>>>>>                Get iMsg iField sValue to iResult
11329>>>>>              End
11329>>>>>>
11329>>>>>            End
11329>>>>>>
11329>>>>>        
11329>>>>>            // Check for keys
11329>>>>>            If (iResult=0 and Key_Field_State(Self, iField)) ;              Get Validate_Key_Field iField to iResult
11332>>>>>        
11332>>>>>            // Do extended validations
11332>>>>>            If (iResult=0) ;               Get Validate_Field of (Field_Attributes(Self)) iField to iResult
11335>>>>>        End
11335>>>>>>
11335>>>>>    End
11335>>>>>>
11335>>>>>
11335>>>>>    Set Current_Validate_Field to 0
11336>>>>>    // Mark this field being validated
11336>>>>>    Get Visited_Fields to sValue
11337>>>>>    Set Visited_Fields to (Overstrike("X", sValue, iField))
11338>>>>>
11338>>>>>    Function_Return iResult
11339>>>>>
11339>>>>>  End_Function
11340>>>>>
11340>>>>>
11340>>>>>
11340>>>>>  //************************************************************************//
11340>>>>>  // Function File_Field_Validate_Field                                     //
11340>>>>>  // This function will be called to validate a field.                      //
11340>>>>>  //************************************************************************//
11340>>>>>
11340>>>>>  Function File_Field_Validate_Field Integer iFile Integer iField Returns Integer
11342>>>>>    Integer iDSO
11342>>>>>    Integer iResult
11342>>>>>    integer hOldOrigin
11342>>>>>    Get Data_Set iFile to iDSO
11343>>>>>    If Not iDSO ;      Function_Return 0
11346>>>>>
11346>>>>>    // This function is only called by the DEOs.
11346>>>>>    // It is possible for validate_item when called as part of
11346>>>>>    // request_validate to get called more than once
11346>>>>>    // when a field is foreign (it is attached to both its DDO and the
11346>>>>>    // child-main ddo). This makes sure the validation is only called once.
11346>>>>>    // (vdf7 change: previously we set OpMode to Mode_Saving and checked that, now we have
11346>>>>>    // a mode just for request_validate).
11346>>>>>    If (Operation_Mode=MODE_VALIDATING AND ;         // if from request_validate        Mid(Visited_Fields(iDSO), 1, iField)="X" ) ; // and already marked           Function_return 0                         // skip it
11349>>>>>
11349>>>>>    Move Operation_origin to hOldOrigin
11350>>>>>
11350>>>>>    // if from request_validate operation_origin will be set and should not 
11350>>>>>    // be reset here.
11350>>>>>    If (OPERATION_ORIGIN=0) Begin
11352>>>>>        Move Self to Operation_Origin
11353>>>>>    End
11353>>>>>>
11353>>>>>
11353>>>>>    Get Validate_Field of iDSO iField to iResult
11354>>>>>    Move hOldOrigin to Operation_Origin
11355>>>>>    Function_Return iResult
11356>>>>>  End_Function
11357>>>>>
11357>>>>>
11357>>>>>
11357>>>>>  //************************************************************************//
11357>>>>>  // Function Validate_Key_Field                                            //
11357>>>>>  // This function will be called to check if a key has been changed.       //
11357>>>>>  //************************************************************************//
11357>>>>>
11357>>>>>  Function Validate_Key_Field Integer iField Returns Integer
11359>>>>>    String  sOld_Value
11359>>>>>    String  sNew_Value
11359>>>>>    String  sKeys
11359>>>>>    Integer iState
11359>>>>>    Boolean bMultiKeys
11359>>>>>    Get Protect_Key_State to iState
11360>>>>>    If iState Begin
11362>>>>>      Get Key_Value to sNew_Value
11363>>>>>      // Only check existing records.
11363>>>>>      If (HasRecord(self)) begin
11365>>>>>        Get Existing_Key_Value to sOld_Value
11366>>>>>        If sNew_Value NE sOld_Value Begin
11368>>>>>            // we have an error. If there is only one key field we know
11368>>>>>            // where the field is and we can report that field. If we have
11368>>>>>            // multiple key fields, we don't really know where the offending key change
11368>>>>>            // is, so we will not report a field.
11368>>>>>            Get Key_Fields to sKeys
11369>>>>>            Move (Pos("X",sKeys)<>RightPos("X",sKeys)) to bMultiKeys
11370>>>>>            Send Data_set_Error (If(bMultiKeys, -1, iField)) 0 DD_TEXT_NO_KEY_CHANGE_ALLOWED
11371>>>>>            Function_Return 1
11372>>>>>        End
11372>>>>>>
11372>>>>>      End
11372>>>>>>
11372>>>>>    End
11372>>>>>>
11372>>>>>  End_Function
11373>>>>>
11373>>>>>
11373>>>>>    // During request_validate process tell us if this DD has had a find_request error. This
11373>>>>>    // is handled by the DD that originated the request_validate. Very private
11373>>>>>    Function DDHasFindReqError Returns Boolean
11375>>>>>        Handle[] DDsWithFindReqErrors
11376>>>>>        Integer iIndex
11376>>>>>        If (OPERATION_ORIGIN) Begin
11378>>>>>            Get pDDsWithFindReqErrors of OPERATION_ORIGIN to DDsWithFindReqErrors
11379>>>>>            Move (SearchArray(Self,DDsWithFindReqErrors)) to iIndex
11380>>>>>            Function_Return (iIndex<>-1)
11381>>>>>        End
11381>>>>>>
11381>>>>>    End_Function
11382>>>>>    
11382>>>>>    // During a request_validate a find_request error has occurred. Add this DD
11382>>>>>    // to list of DDs that have this error. This is handled by the DD that
11382>>>>>    // originated the request_validate.  Very private
11382>>>>>    Procedure AddDDHasFindReqError
11384>>>>>        Handle[] DDsWithFindReqErrors
11385>>>>>        If (OPERATION_ORIGIN) Begin
11387>>>>>            Get pDDsWithFindReqErrors of OPERATION_ORIGIN to DDsWithFindReqErrors
11388>>>>>            Move Self to DDsWithFindReqErrors[SizeOfArray(DDsWithFindReqErrors)]
11389>>>>>            Set pDDsWithFindReqErrors of OPERATION_ORIGIN to DDsWithFindReqErrors
11390>>>>>        End
11390>>>>>>
11390>>>>>    End_Procedure
11391>>>>>
11391>>>>>
11391>>>>>  //************************************************************************//
11391>>>>>  // Validate_Data_Sets                                                     //
11391>>>>>  // This function will execute the validation message for each field of the//
11391>>>>>  // data set and all of its parents in parent first order.                 //
11391>>>>>  // Pass: DoALLFg bNoStop                                                  //
11391>>>>>  // Added bNoStop, If true, all items are validated. It is up to you to    //
11391>>>>>  // do something with the possible cascade of errors                       //
11391>>>>>  //************************************************************************//
11391>>>>>  
11391>>>>>  Function Validate_Data_Sets integer DoAllFg integer bNoStop Returns Integer
11393>>>>>    Integer iDSO
11393>>>>>    Integer iRetval
11393>>>>>    Integer iCount
11393>>>>>    Integer iMax
11393>>>>>    Integer bErr
11393>>>>>    Boolean bDDHasFindReqError
11393>>>>>    // ShowLn "Validate_Data_Sets in Data_Set in " (Name(self))
11393>>>>>    // Validate if not foreign, or foreign new saves allowed, or
11393>>>>>    // foreign validation is supported (it normally is)
11393>>>>>    If (Operation_Origin=self OR ;        Allow_Foreign_New_Save_State(self) OR ;        Validate_Foreign_File_State(Self)) Begin
11395>>>>>            
11395>>>>>      If (bNoStop) Begin
11397>>>>>          // if do all, it is possible that this DD as a find-req error. If so there is no
11397>>>>>          // need to look for more errors in this DD or its parents. This makes the do all checking
11397>>>>>          // a little more intelligent and doesn't return a bunch of errors when it is not needed
11397>>>>>          Get DDHasFindReqError to bDDHasFindReqError
11398>>>>>      End
11398>>>>>>
11398>>>>>      
11398>>>>>      If (not(bDDHasFindReqError)) Begin
11400>>>>>          Get Data_Set_Server_Count to iMax
11401>>>>>          Decrement iMax
11402>>>>>          For iCount from 0 to iMax
11408>>>>>>
11408>>>>>            Get Data_Set_Server iCount to iDSO
11409>>>>>            If not (Visited_state(iDSO)) Begin
11411>>>>>               Get Validate_Data_Sets of iDSO DoAllFg bNoStop to bErr
11412>>>>>               If bErr Begin
11414>>>>>                   Move bErr to iRetVal
11415>>>>>                   If bNoStop Move 0 to bErr
11418>>>>>               End
11418>>>>>>
11418>>>>>            End
11418>>>>>>
11418>>>>>          Until bErr
11420>>>>>          If not bErr Begin
11422>>>>>             Get Validate_Fields DoAllFg bNoStop to bErr
11423>>>>>             If bErr Move bErr to iRetVal
11426>>>>>          End
11426>>>>>>
11426>>>>>      End
11426>>>>>>
11426>>>>>    End
11426>>>>>>
11426>>>>>    Set Visited_State to TRUE
11427>>>>>    Function_Return iRetval
11428>>>>>  End_Function // Validate_Data_Sets
11429>>>>>  
11429>>>>>  // special validate-save check for changed committed parent. If the record is committed
11429>>>>>  // and it has a switched parent and this is not allowed, we have an error. This should rarely happen because the
11429>>>>>  // DEOs should guard aginst this. This is a recursive routine that requires special attention the first time through.
11429>>>>>  // When called from the we must refind the original record and all original parents. This way we can compare these parent
11429>>>>>  // rowids to the DD row id (if different, they've changed). At the end we must restore the DD records. Because this takes time
11429>>>>>  // we only even do this if this is committed and there is a chance that there are changed parents
11429>>>>>  
11429>>>>>  Function ValidateSwitchedCommittedParents Boolean bTop Returns Boolean
11431>>>>>        Integer iServers iSrvr iMain iParent
11431>>>>>        Handle hoSrvr
11431>>>>>        RowID riCrnt riParent
11431>>>>>        Boolean bChanged bCommitted bAllowed bErr bParentChanged 
11431>>>>>
11431>>>>>        Get IsCommitted to bCommitted
11432>>>>>        If (bCommitted) Begin
11434>>>>>             
11434>>>>>
11434>>>>>            Get Data_Set_Server_Count to iServers
11435>>>>>
11435>>>>>            // optimization. We only test committed parents if one parent does not allow changing committed recods. This
11435>>>>>            // avoids extra finds and relates when not needed
11435>>>>>            Move 0 to iSrvr
11436>>>>>            Move True to bAllowed
11437>>>>>            While (iSrvr<iServers and bAllowed) 
11441>>>>>                Get Data_Set_Server iSrvr to hoSrvr
11442>>>>>                Get Main_File of hoSrvr to iParent
11443>>>>>                Get IsCommittedParentChangeAllowed iParent to bAllowed
11444>>>>>                Increment iSrvr
11445>>>>>            Loop
11446>>>>>>
11446>>>>>            If bAllowed Begin
11448>>>>>                Function_Return False // if all are allowed, we have nothing to test - its ok
11449>>>>>            End
11449>>>>>>
11449>>>>>            
11449>>>>>            Get Main_File to iMain
11450>>>>>            Get CurrentRowId to riCrnt
11451>>>>>            
11451>>>>>            If (bTop or not(IsSameRowID(GetRowID(iMain),riCrnt))) Begin
11453>>>>>                // this refinds the main record and, most importantly, relates all original parents on up
11453>>>>>                // We now have the original parents which we can test to see if they are changed.
11453>>>>>                Send ReadByRowId iMain riCrnt 
11454>>>>>            End
11454>>>>>>
11454>>>>>            
11454>>>>>            
11454>>>>>            // Parent_Changed_State tells us a parent is changed but not which one. Look at each child to see if it is changed.
11454>>>>>            Get Parent_Changed_State to bChanged
11455>>>>>            // First see any any of the parents are changed.
11455>>>>>            If bChanged Begin
11457>>>>>                // Parent_Changed_State tells us a parent is changed but not which one. Look at each child to see if it is changed.
11457>>>>>                Move 0 to iSrvr
11458>>>>>                While (iSrvr<iServers and not(bErr))
11462>>>>>                    Get Data_Set_Server iSrvr to hoSrvr
11463>>>>>                    Get Main_File of hoSrvr to iParent
11464>>>>>                    Get CurrentRowId of hoSrvr to riParent
11465>>>>>                    Move (not(IsSameRowID(GetRowID(iParent),riParent))) to bParentChanged // is parent changed?
11466>>>>>                    If bParentChanged Begin
11468>>>>>                        Get IsCommittedParentChangeAllowed iParent to bAllowed // is changing committed parent allowed?
11469>>>>>                        If not bAllowed Begin
11471>>>>>                            Move True to bErr
11472>>>>>                            If bErr Begin
11474>>>>>                                Send Data_Set_Error -1 0 ("Cannot switch parent record for file" + String(iParent)) 
11475>>>>>                            End
11475>>>>>>
11475>>>>>                        End
11475>>>>>>
11475>>>>>                    End
11475>>>>>>
11475>>>>>                    Increment iSrvr
11476>>>>>                Loop
11477>>>>>>
11477>>>>>            End
11477>>>>>>
11477>>>>>            
11477>>>>>            // no error in immediate we must continue this check up the parent tree.
11477>>>>>            Move 0 to iSrvr
11478>>>>>            While (iSrvr<iServers and not(bErr))
11482>>>>>                Get Data_Set_Server iSrvr to hoSrvr
11483>>>>>                Get ValidateSwitchedCommittedParents of hoSrvr False to bErr // call recursively up the parent tree
11484>>>>>                Increment iSrvr
11485>>>>>            Loop
11486>>>>>>
11486>>>>>            
11486>>>>>            If bTop Begin // if back to the top, make sure our buffers are correct.
11488>>>>>                Send Refind_Records
11489>>>>>            End
11489>>>>>>
11489>>>>>            
11489>>>>>            Function_Return bErr
11490>>>>>        End
11490>>>>>>
11490>>>>>
11490>>>>>  End_Function
11491>>>>>
11491>>>>>
11491>>>>>
11491>>>>>  //************************************************************************//
11491>>>>>  // Entry_Update_Data_Sets                                                 //
11491>>>>>  // This sends entry_update to all server data-sets and itself             //
11491>>>>>  //************************************************************************//
11491>>>>>
11491>>>>>    Procedure Entry_Update_Data_Sets Integer iFile Integer iAll
11493>>>>>        Handle hoBuff hoDSO
11493>>>>>        Boolean bCommit bNoPut bVisited bIsForeign
11493>>>>>        Integer iMax iCount iItems iOpts iChanges 
11493>>>>>        Integer[] NoPutFields
11494>>>>>        Boolean[] FieldNoPutOverrides
11495>>>>>
11495>>>>>        Move record_buffer to hoBuff
11496>>>>>        
11496>>>>>        // first recurse to all parent ddos
11496>>>>>        Get Data_Set_Server_Count to iMax
11497>>>>>        Decrement iMax
11498>>>>>        For iCount from 0 to iMax
11504>>>>>>
11504>>>>>            Get Data_Set_Server iCount to hoDSO
11505>>>>>            Get Visited_State of hoDSO to bVisited
11506>>>>>            If not (bVisited) Begin
11508>>>>>               Send Entry_Update_Data_Sets to hoDSO iFile iAll
11509>>>>>            End
11509>>>>>>
11509>>>>>        Loop
11510>>>>>>
11510>>>>>
11510>>>>>        // if a save, see if we have any foreign field noput values or committed fields and make sure they are temporarily
11510>>>>>        // Set to noput for the entry_update. Afterwards we will reset them to their original value.
11510>>>>>        If (OPERATION_MODE=MODE_SAVING) Begin
11512>>>>>            Get IsCommitted to bCommit
11513>>>>>            Move (OPERATION_ORIGIN<>Self and Allow_Foreign_New_Save_State(Self)=0) to bIsForeign
11514>>>>>            If (bCommit or bIsForeign) Begin
11516>>>>>                Get pFieldNoPutOverrides of hoBuff to FieldNoPutOverrides
11517>>>>>                Get Item_Count of hoBuff to iItems
11518>>>>>                For iCount from 0 to (iItems-1)
11524>>>>>>
11524>>>>>                    Move False to bNoPut
11525>>>>>                    // technically we should check for this with any field but checking only foreign fields makes for
11525>>>>>                    // the smallest behavior change possible.
11525>>>>>                    If (bIsForeign and FieldNoPutOverrides[iCount]) Begin
11527>>>>>                        Move True to  bNoPut
11528>>>>>                    End
11528>>>>>>
11528>>>>>                    If (not(bNoPut) and bCommit) Begin
11530>>>>>                        Get IsFieldCommitted iCount to bNoPut
11531>>>>>                    End
11531>>>>>>
11531>>>>>                    If bNoPut Begin
11533>>>>>                        Get Item_Options of hoBuff iCount to iOpts
11534>>>>>                        If (not(iOpts iand DD_NOPUT)) Begin
11536>>>>>                            Set Item_Option of hoBuff iCount NOPUT to True
11537>>>>>                            Move iCount to NoPutFields[iChanges] // array of changes, which we will change back
11538>>>>>                            Increment iChanges
11539>>>>>                        End
11539>>>>>>
11539>>>>>                    End
11539>>>>>>
11539>>>>>                Loop
11540>>>>>>
11540>>>>>            End
11540>>>>>>
11540>>>>>            
11540>>>>>        End
11540>>>>>>
11540>>>>>
11540>>>>>        // We need to distinguish between updates for finds and saves. A find update
11540>>>>>        // should update everything, a save should only update changed, non-noput values.
11540>>>>>        // Passing 0 is save and will update if field is not dislayonly and not Noput AND (changed or forceput)
11540>>>>>        // passing 1 is find and will update if field.
11540>>>>>        If (OPERATION_MODE=MODE_SAVING) Begin
11542>>>>>            Send Entry_Update to hoBuff (Main_File(Self)) (Operation_Mode<>MODE_SAVING)
11543>>>>>        End
11543>>>>>>
11543>>>>>        Else Begin
11544>>>>>            // when Entry_Update is used for finding you want to know the file being used for finding and only update
11544>>>>>            // that file. This statement should work for all cases, but this is a bug fix so I am leaving
11544>>>>>            // the above entry_update unchanged since it has been that way for years.
11544>>>>>            Send Entry_Update to hoBuff iFile (Operation_Mode<>MODE_SAVING)
11545>>>>>        End
11545>>>>>>
11545>>>>>    
11545>>>>>    
11545>>>>>        // also move data from extended dd fields to buffer
11545>>>>>        Send ExtendedFieldsUpdate (Operation_Mode=MODE_SAVING)
11546>>>>>    
11546>>>>>        // restore the noput fields back to what they were
11546>>>>>        For iCount from 0 to (iChanges-1)
11552>>>>>>
11552>>>>>            Set Item_Option of hoBuff NoPutFields[iCount] NOPUT to False
11553>>>>>        Loop
11554>>>>>>
11554>>>>>
11554>>>>>        Set Visited_State to True
11555>>>>>        
11555>>>>>    End_Procedure
11556>>>>>//  Procedure Entry_Update_Data_Sets Integer iFile Integer iAll
11556>>>>>//    Integer iDSO
11556>>>>>//    integer iMax
11556>>>>>//    integer iCount
11556>>>>>//    Get Data_Set_Server_Count to iMax
11556>>>>>//    Decrement iMax
11556>>>>>//    For iCount from 0 to iMax
11556>>>>>//        Get Data_Set_Server iCount to iDSO
11556>>>>>//        If Not (Visited_state(iDSO)) ;
11556>>>>>//           Send Entry_Update_Data_Sets to iDSO iFile iAll
11556>>>>>//    Loop
11556>>>>>//    //Send Entry_Update to (Record_Buffer(self)) iFile iAll
11556>>>>>//    //Send Entry_Update to (Record_Buffer(self)) ;
11556>>>>>//    //     (main_file(self)) (Current_Record(self)=0)
11556>>>>>//
11556>>>>>//    // We need to distinguish between updates for finds and saves. A find update
11556>>>>>//    // should update everything, a save should only update changed, non-noput values.
11556>>>>>//    // Passing 0 is save and will update if field is not dislayonly and not Noput AND (changed or forceput)
11556>>>>>//    // passing 1 is find and will update if field is not displayonly (noput AND noenter).
11556>>>>>//    Send Entry_Update to (Record_Buffer(self)) ;
11556>>>>>//         (main_file(self)) (Operation_Mode<>MODE_SAVING)
11556>>>>>//
11556>>>>>//    // also move data from extended dd fields to buffer
11556>>>>>//    Send ExtendedFieldsUpdate (Operation_Mode=MODE_SAVING)
11556>>>>>//
11556>>>>>//    Set Visited_State to TRUE
11556>>>>>//  End_Procedure
11556>>>>>
11556>>>>>
11556>>>>>  //************************************************************************//
11556>>>>>  // Valid_Servers                                                          //
11556>>>>>  // Check that Server data-sets exist for all required server file numbers //
11556>>>>>  //************************************************************************//
11556>>>>>
11556>>>>>  Function Valid_Servers returns integer
11558>>>>>      integer iRval
11558>>>>>      integer iCount
11558>>>>>      integer iMax
11558>>>>>      integer iDSO
11558>>>>>      integer iPos
11558>>>>>      integer iFile
11558>>>>>      String  sFiles
11558>>>>>
11558>>>>>      // First assemble a string of all server file#s in ','##',' format
11558>>>>>      Move ',' to sFiles
11559>>>>>      Get Data_Set_Server_Count to iMax
11560>>>>>      Decrement iMax
11561>>>>>      For iCount from 0 to iMax
11567>>>>>>
11567>>>>>          Get Data_Set_Server iCount to iDSO
11568>>>>>          Move ( sFiles + string(Main_file(iDSO)) + ",") to sFiles
11569>>>>>      Loop
11570>>>>>>
11570>>>>>
11570>>>>>      // Make sure each required File exists
11570>>>>>      Get Server_File_Count to iMax
11571>>>>>      Decrement iMax
11572>>>>>      For iCount from 0 to iMax
11578>>>>>>
11578>>>>>          Get Server_File iCount to iFile
11579>>>>>          Pos (','+string(iFile)+',') in sFiles to iPos
11581>>>>>>
11581>>>>>          If iPos eq 0 Move iFile to iRVal
11584>>>>>      Until iRval
11586>>>>>      Function_Return iRVal
11587>>>>>  End_Function
11588>>>>>
11588>>>>>
11588>>>>>  //************************************************************************//
11588>>>>>  // Valid_Clients                                                          //
11588>>>>>  // Check that Client data-sets exist for all required Client file numbers //
11588>>>>>  //************************************************************************//
11588>>>>>
11588>>>>>  Function Valid_Clients returns integer
11590>>>>>      integer iRval
11590>>>>>      integer iCount
11590>>>>>      integer iMax
11590>>>>>      integer iDSO
11590>>>>>      integer iPos
11590>>>>>      integer iFile
11590>>>>>      String  sFiles
11590>>>>>
11590>>>>>      // First assemble a string of all Client file#s in ','##',' format
11590>>>>>      Move ',' to sFiles
11591>>>>>      Get Data_Set_Client_Count to iMax
11592>>>>>      Decrement iMax
11593>>>>>      For iCount from 0 to iMax
11599>>>>>>
11599>>>>>          Get Data_Set_Client iCount to iDSO
11600>>>>>          Move ( sFiles + string(Main_file(iDSO))+",") to sFiles
11601>>>>>      Loop
11602>>>>>>
11602>>>>>
11602>>>>>      // Make sure each required File exists
11602>>>>>      Get Client_File_Count to iMax
11603>>>>>      Decrement iMax
11604>>>>>      For iCount from 0 to iMax
11610>>>>>>
11610>>>>>          Get Client_File iCount to iFile
11611>>>>>          Pos (','+string(iFile)+',') in sFiles to iPos
11613>>>>>>
11613>>>>>          If iPos eq 0 Move iFile to iRVal
11616>>>>>      Until iRval
11618>>>>>      Function_Return iRVal
11619>>>>>  End_Function
11620>>>>>
11620>>>>>
11620>>>>>  //************************************************************************//
11620>>>>>  // Function Validate_Save_Structure                                       //
11620>>>>>  // Validates save updating connections. If error returns file# that is    //
11620>>>>>  // expected and missing. If no error Set Validated_Save_connectio_State   //
11620>>>>>  // indicating that the connection validation has occurred and is ok       //
11620>>>>>  //************************************************************************//
11620>>>>>
11620>>>>>  Function Validate_Save_Structure Integer ForceFg returns Integer
11622>>>>>    Integer iRval
11622>>>>>    Integer iMode
11622>>>>>    If Not ForceFg Begin
11624>>>>>       Get Validate_Save_Structure_Mode to iMode
11625>>>>>       Move ( iMode=DD_VALIDATE_STRUCTURE_ALWAYS OR ;              (iMode=DD_VALIDATE_STRUCTURE_ONCE AND ;                Save_Structure_Validated_state(self)=0 ) ) ;                  to ForceFg
11626>>>>>    End
11626>>>>>>
11626>>>>>    If ForceFg Begin
11628>>>>>       Get Valid_Structure False to iRval
11629>>>>>       if iRVal eq 0 ;          Set Save_Structure_Validated_State to TRUE
11632>>>>>    End
11632>>>>>>
11632>>>>>    Function_Return iRVal
11633>>>>>  End_Function
11634>>>>>
11634>>>>>
11634>>>>>  //************************************************************************//
11634>>>>>  // Function Validate_delete_Structure                                     //
11634>>>>>  // Validates Delete Structure. If cascade_state is true this must check   //
11634>>>>>  // up and down the tree. If no cascade_state just check up the tree.  If  //
11634>>>>>  // Ok, set Validated_Delete_no_Cascade_Connection_State and and or        //
11634>>>>>  // Validated_Delete_Cascade_Connection_State                              //
11634>>>>>  // Pass: ForceFg - if TRUE force the validation.                          //
11634>>>>>  //************************************************************************//
11634>>>>>
11634>>>>>  Function Validate_Delete_Structure Integer ForceFg Returns Integer
11636>>>>>     Integer iCascade
11636>>>>>     Integer iMode
11636>>>>>     Integer iSt
11636>>>>>     Integer iRval
11636>>>>>     Get Cascade_delete_State to iCascade
11637>>>>>     If Not ForceFg Begin
11639>>>>>        Get Validate_Delete_Structure_Mode to iMode
11640>>>>>        If (iMode=DD_VALIDATE_STRUCTURE_ONCE AND iCascade );           Get Cascade_Delete_Structure_Validated_state to iSt
11643>>>>>        Else ;           Get No_Cascade_Delete_Structure_Validated_state to iSt
11645>>>>>        Move ( iMode=DD_VALIDATE_STRUCTURE_ALWAYS OR ;               (iMode=DD_VALIDATE_STRUCTURE_ONCE AND iSt=0) ) to ForceFg
11646>>>>>     End
11646>>>>>>
11646>>>>>
11646>>>>>     If ForceFg Begin
11648>>>>>        Get Valid_Structure iCascade to iRval
11649>>>>>        If iRval eq 0 Begin
11651>>>>>           Set No_Cascade_Delete_Structure_Validated_State to TRUE
11652>>>>>           If iCascade ;              Set Cascade_Delete_Structure_Validated_State to TRUE
11655>>>>>        End
11655>>>>>>
11655>>>>>     End
11655>>>>>>
11655>>>>>     Function_return iRval
11656>>>>>  End_Function
11657>>>>>
11657>>>>>
11657>>>>>  //************************************************************************//
11657>>>>>  // Request_Entry_Update.                                                  //
11657>>>>>  // This procedure will be called whenever the Data_Set wants its DEOs to  //
11657>>>>>  // write their values to the record buffer. The value of OPERATION_MODE   //
11657>>>>>  // determines if this is for finding an record or before saving a record. //
11657>>>>>  // We use this event to tell our Record_Buffer to update the              //
11657>>>>>  // global record buffer.                                                  //
11657>>>>>  // Modified to visit all server DSOs                                      //
11657>>>>>  // Note that this is only sent to the DSO starting the operation.         //
11657>>>>>  // We must manually send this to all server data-sets ourselves           //
11657>>>>>  // Note that during a DSO save this will get passed iFile=0 and iAll=3    //
11657>>>>>  // Changed to Support EntryUpdateLocalState (private)                     //
11657>>>>>  //************************************************************************//
11657>>>>>  // as of 17.0, EntryUpdateLocalState is True which means that entry_updates
11657>>>>>  // for finds now through the DD Buffer (saves always did).
11657>>>>>
11657>>>>>  Procedure Request_Entry_Update Integer iFile Integer iAll
11659>>>>>    If ((Operation_Mode=MODE_SAVING and iAll=3) or (EntryUpdateLocalState(Self)) ) Begin //3=dso save
11661>>>>>      If (OPERATION_MODE=MODE_WAITING) Begin
11663>>>>>          // we will only not be in an operation if we are doing a find with EntryUpdateLocalState
11663>>>>>          // set to true. In such a case make this a finding. I am not this is actually needed
11663>>>>>          Send Update_Focus_Field_For_Operation MODE_FINDING
11664>>>>>      End
11664>>>>>>
11664>>>>>      Else Begin
11665>>>>>          // if here we already have an operation_mode so there is no need to do anything special       
11665>>>>>          Send Update_Focus_Field // Make sure buffer has latest focus item changes
11666>>>>>      End
11666>>>>>>
11666>>>>>      Send Initialize_Visited False False // Clear up, do not clear fields
11667>>>>>      Send Entry_Update_Data_Sets iFile iAll
11668>>>>>    End
11668>>>>>>
11668>>>>>    Forward Send Request_Entry_Update iFile iAll
11670>>>>>  End_Procedure
11671>>>>>
11671>>>>>
11671>>>>>
11671>>>>>  //************************************************************************//
11671>>>>>  // Update_Focus_Field                                                     //
11671>>>>>  // Forces the focus field to get update its value with the data-set.      //
11671>>>>>  // This insures that the DSO and DEO contain the same values.             //
11671>>>>>  //************************************************************************//
11671>>>>>
11671>>>>>  Procedure Update_Focus_Field
11673>>>>>    Integer iFocObj
11673>>>>>    Get Focus of desktop to iFocObj
11674>>>>>    If (Extended_DEO_State(iFocObj)) ;        Send Update_Focus_Field to iFocObj
11677>>>>>  End_Procedure
11678>>>>>  
11678>>>>>  // very internal. Used to set Operation_mode and Operation_origin before the
11678>>>>>  // update. A developer can use this in the DEO to know what state the update is in.
11678>>>>>  // This was created because a DEO value change will trigger an OnChange event and you 
11678>>>>>  //can look at this and know that this is part of a DD operation.
11678>>>>>  // This is *only* called by the DD operations in this class and the change is made for as
11678>>>>>  // small of a period as possible.
11678>>>>>  Procedure Update_Focus_Field_For_Operation Integer iOperationMode
11680>>>>>    Integer iOldMode iOldOrigin
11680>>>>>    
11680>>>>>    Move OPERATION_MODE to iOldMode
11681>>>>>    Move OPERATION_ORIGIN to iOldOrigin
11682>>>>>    Move iOperationMode to OPERATION_MODE
11683>>>>>    Move Self to OPERATION_ORIGIN
11684>>>>>    Send Update_Focus_Field
11685>>>>>    Move iOldMode to OPERATION_MODE
11686>>>>>    Move iOldOrigin to OPERATION_ORIGIN
11687>>>>>  End_Procedure
11688>>>>>  
11688>>>>>
11688>>>>>  //************************************************************************//
11688>>>>>  // Request_validate                                                       //
11688>>>>>  // Augment to validate all field values that do not get                   //
11688>>>>>  // validated as part of the item validation process. The advantage        //
11688>>>>>  // of item validation (over only field validation) is that an error       //
11688>>>>>  // returns you to the offending item.                                     //
11688>>>>>  //************************************************************************//
11688>>>>>
11688>>>>>  Function Request_Validate Returns Integer
11690>>>>>    Integer iRetval iOldOrigin iOldMode iRetVal2
11690>>>>>    Handle[] DDsWithFindReqErrors
11691>>>>>    
11691>>>>>    If (OPERATION_MODE=MODE_WAITING) Begin
11693>>>>>        Send Update_Focus_Field_For_Operation MODE_VALIDATING // added 12.1/15.1
11694>>>>>    End
11694>>>>>>
11694>>>>>    Move Operation_Origin to iOldOrigin
11695>>>>>    Move self to Operation_Origin
11696>>>>>    Move Operation_Mode to iOldMode
11697>>>>>    // clear all find req DD markers at the origin of the validate request. When request validates occur
11697>>>>>    // they will get added to this array and can be tested to see of such an error has occurred.
11697>>>>>    Set pDDsWithFindReqErrors to DDsWithFindReqErrors
11698>>>>>    // Prior to VDF7, we set this to Mode_Saving. We now have a special mode just for request_validate.
11698>>>>>    // We do this because:
11698>>>>>    //   1) because it is useful (more detail never hurts) and
11698>>>>>    //   2) we will allow set_field_current_value to update when mode_validation is set
11698>>>>>    Move MODE_VALIDATING to Operation_Mode
11699>>>>>    Send Initialize_Visited FALSE TRUE //false=up only, true=clear fields
11700>>>>>    Forward Get Request_Validate to iRetval // normal deo validate
11702>>>>>    // If DEO validation failed, do not validate other fields unless Validate_All_Fields is set
11702>>>>>    If ( (iRetval=0 or (Validate_All_Fields_State(Self))) and Validate_DEOs_Only_State(Self)=0) Begin
11704>>>>>       Get Validate_Data_Sets False (Validate_All_Fields_State(Self)) to iRetval2
11705>>>>>       Move (iRetval or iRetVal2) to iRetval         
11706>>>>>    End
11706>>>>>>
11706>>>>>       
11706>>>>>    If (iRetval=0) Begin
11708>>>>>         Get ValidateSwitchedCommittedParents True to iRetval
11709>>>>>    End
11709>>>>>>
11709>>>>>    
11709>>>>>    Move iOldMode   to Operation_Mode
11710>>>>>    Move iOldOrigin to Operation_Origin
11711>>>>>    Function_Return iRetval
11712>>>>>  End_Function // Request_Validate
11713>>>>>
11713>>>>>  Function Request_Validate_All Returns Integer
11715>>>>>    Integer bOld iRetVal
11715>>>>>    Get Validate_All_Fields_State to bOld
11716>>>>>    Set Validate_All_Fields_State to True
11717>>>>>    Get request_validate to iretVal
11718>>>>>    Set Validate_All_Fields_State to bOld
11719>>>>>    Function_Return iRetval
11720>>>>>  End_Function // Request_Validate_All
11721>>>>>
11721>>>>>
11721>>>>>
11721>>>>>  //************************************************************************//
11721>>>>>  // File_Field_Find                                                        //
11721>>>>>  // Like Item_find except entry-update is forced through the DD, not DEO   //
11721>>>>>  //************************************************************************//
11721>>>>>
11721>>>>>  procedure File_Field_Find integer iFindMode integer iFile integer iField ;                            integer bEntUpdt  integer bShowErr integer bDfrd
11723>>>>>     Integer bOld
11723>>>>>     Get EntryUpdateLocalState to bOld
11724>>>>>     Set EntryUpdateLocalState to True
11725>>>>>     Send Item_Find iFindMode iFile iField bEntUpdt bShowErr bDfrd
11726>>>>>     Set EntryUpdateLocalState to bOld
11727>>>>>  End_Procedure
11728>>>>>
11728>>>>>  //************************************************************************//
11728>>>>>  // File_Field_AutoFind                                                    //
11728>>>>>  // Autofind for requestd file, field and mode.                            //
11728>>>>>  //    If mode not passed, EQ is assummed                                  //
11728>>>>>  //************************************************************************//
11728>>>>>
11728>>>>>  Procedure File_Field_AutoFind integer iFile integer iField integer iFindMode
11730>>>>>     integer eMode
11730>>>>>     if iFile  Begin
11732>>>>>        // if no 3rd argument, default to autofind
11732>>>>>        Move (If(Num_Arguments<3,EQ,iFindMode)) to eMode
11733>>>>>        send File_Field_Find eMode iFile iField True False False
11734>>>>>     end
11734>>>>>>
11734>>>>>  End_Procedure
11735>>>>>
11735>>>>>  //************************************************************************//
11735>>>>>  // File_Field_Default_AutoFind                                            //
11735>>>>>  // Autofind in default mode (does not set changed states). Can be used    //
11735>>>>>  // within Clear and Clear_all to autofind parents. Parent values can be   //
11735>>>>>  // maintained using retainAll option                                      //
11735>>>>>  //************************************************************************//
11735>>>>>
11735>>>>>  Procedure File_Field_Default_AutoFind integer iFile integer iField
11737>>>>>     integer iOldState
11737>>>>>     Handle  hoDD
11737>>>>>     Get Data_set iFile to hoDD
11738>>>>>     if hoDD Begin
11740>>>>>         Get Change_disabled_State of hoDD to iOldState
11741>>>>>         Set Change_disabled_State of hoDD to TRUE
11742>>>>>         Send File_Field_AutoFind  of hoDD iFile iField EQ
11743>>>>>         Set Change_disabled_State of hoDD to iOldState
11744>>>>>         set changed_state to false
11745>>>>>     end
11745>>>>>>
11745>>>>>  End_Procedure
11746>>>>>
11746>>>>>  //************************************************************************//
11746>>>>>  // File_Index_find                                                        //
11746>>>>>  // Like item_find except you pass the index you want to find with and     //
11746>>>>>  // ent-update occurs through DDO buffers not deo buffers.                 //
11746>>>>>  // This is currently private and is only used by web-applications         //
11746>>>>>  //************************************************************************//
11746>>>>>  procedure File_Index_Find integer iFindMode integer iFile integer iIndex ;                            integer bEntUpdt  integer bShowErr integer bDfrd
11748>>>>>      Integer bOld
11748>>>>>      rowId riRec
11748>>>>>      integer wasChanged hDD iOldStat
11748>>>>>      Boolean bOk
11748>>>>>
11748>>>>>      Get Data_Set iFile to hDD
11749>>>>>      if (hDD=0) Begin
11751>>>>>          error DFERR_PROGRAM C_$CannotFindDD
11752>>>>>>
11752>>>>>          Procedure_return
11753>>>>>      end
11753>>>>>>
11753>>>>>
11753>>>>>      Get EntryUpdateLocalState to bOld
11754>>>>>      Set EntryUpdateLocalState to True
11755>>>>>
11755>>>>>      //  'hold' buffer to prepare for entry_update
11755>>>>>      Move (getRowId(iFile)) to riRec
11756>>>>>      Get_Attribute DF_FILE_STATUS of iFile to iOldStat
11759>>>>>      Set_Attribute DF_FILE_STATUS of iFile to DF_FILE_INACTIVE
11762>>>>>
11762>>>>>      if bEntUpdt begin
11764>>>>>          send Request_Entry_Update to hDD iFile 1  //entUpdt all DEOs as required
11765>>>>>
11765>>>>>          //
11765>>>>>          // we really only need to know if any segment of the index changed
11765>>>>>          // but since we don't have field-changed flags, we look at the
11765>>>>>          // whole recbuf - this is consistent with 2.3b and 3.0 non-dataset
11765>>>>>          // behavior.
11765>>>>>          //
11765>>>>>          move (iOldStat<>DF_FILE_INACTIVE) to wasChanged
11766>>>>>          if not wasChanged ;              Get_Attribute DF_FILE_CHANGED of iFile to wasChanged
11771>>>>>          if not wasChanged ;              constrained_clear iFindMode iFile by iIndex
11776>>>>>
11776>>>>>          //send Attach_Main_File to hDD // not needed, gets called by the find
11776>>>>>      end
11776>>>>>>
11776>>>>>      indicate err false
11777>>>>>      if bDfrd ;          send Request_Read iFindMode iFile iIndex
11780>>>>>      else ;          send Request_Find iFindMode iFile iIndex
11782>>>>>      If (not(found) and  not(err)) begin
11784>>>>>          // refind original record (or leave it cleared if not record)
11784>>>>>          Move (FindByRowId(iFile,riRec)) to bOk
11785>>>>>
11785>>>>>          if bShowErr ;             error (if(iFindMode<2, DFERR_FIND_PRIOR_BEG_OF_FILE, DFERR_FIND_PAST_END_OF_FILE))
11788>>>>>          indicate Found False
11789>>>>>      end
11789>>>>>>
11789>>>>>      Set EntryUpdateLocalState to bOld
11790>>>>>  End_Procedure
11791>>>>>
11791>>>>>
11791>>>>>  //************************************************************************//
11791>>>>>  // Find_Records                                                           //
11791>>>>>  // This does a refind of all records based on the contents of the         //
11791>>>>>  // refine_record_id property.                                             //
11791>>>>>  // This would be used after clearing the DDs and loading the local rencum //
11791>>>>>  // buffer with recnums. This can be used by remote DEOs (BPOs).           //
11791>>>>>  //                                                                        //
11791>>>>>  // Find all existing records. This must be done in bottom-up, breadth     //
11791>>>>>  // first order. i.e., Start with the passed DD, find it and then find for //
11791>>>>>  // parents. Only find if the record is non-zero and it is different than  //
11791>>>>>  // the current_record.                                                    //
11791>>>>>  // This order will allow us to support changed parents.                   //
11791>>>>>  // Don't use this if you do not understand what it does.                  //
11791>>>>>  // Private.Find_Records is a helper. We will keep this private because    //
11791>>>>>  // it is rather specialized and only used by WebApp.                      //
11791>>>>>  //************************************************************************//
11791>>>>>
11791>>>>>  Procedure Find_Records
11793>>>>>     Send Initialize_Visited False False // Clear up, do not clear fields
11794>>>>>     Send Private.Find_Records           // refind all records in upward sweep
11795>>>>>  End_Procedure
11796>>>>>
11796>>>>>
11796>>>>>  Procedure Private.Find_Records
11798>>>>>     Integer hPrnt
11798>>>>>     integer iMax
11798>>>>>     integer iCount
11798>>>>>     RowId riRec
11798>>>>>     Integer iRec iMain
11798>>>>>     // works with both recId and rowId. Only one should ever be set.
11798>>>>>     // find(clear) record, if needed
11798>>>>>     Get Main_File to iMain
11799>>>>>     // assume that either Find_rowId or Find_record_id has a value - never both
11799>>>>>     // also assume Find_record_id only has values when you are using a recnum table
11799>>>>>     Get Find_RowId to riRec
11800>>>>>     If not (IsNullRowId(riRec)) begin
11802>>>>>         If not (IsSameRowId(riRec, CurrentRowId(self) ) ) begin
11804>>>>>             Send FindByRowId iMain riRec // find an Relate all parents
11805>>>>>         end
11805>>>>>>
11805>>>>>         Set Find_rowid to (NullRowId())  // reset refind rec back to zero.
11806>>>>>     end
11806>>>>>>
11806>>>>>     else begin
11807>>>>>         // if this has a recnum, it better be a recnum table or an error will occur.
11807>>>>>         // This is not being tested for a recnum table on purpose. If someone is setting Find_record_id
11807>>>>>         // on a non-recnum table, they doing something wrong. An Error will be a good thing.
11807>>>>>         Get Find_Record_Id to iRec
11808>>>>>         If iRec begin
11810>>>>>            If (iRec<>Current_record(self)) begin
11812>>>>>                Send Find_By_Recnum iMain iRec // find an Relate all parents
11813>>>>>            end
11813>>>>>>
11813>>>>>            Set Find_record_id to 0 // reset refind rec back to zero.
11814>>>>>         end
11814>>>>>>
11814>>>>>     end
11814>>>>>>
11814>>>>>     Set Visited_State to True
11815>>>>>
11815>>>>>     // recurse and do the same to all parent files
11815>>>>>     // in almost all cases, there will be no new finding here since the relate has
11815>>>>>     // found the records. If the record is different than the relate, we have
11815>>>>>     // a switched parent state (should_save will be set appropriately).
11815>>>>>     Get Data_Set_Server_Count to iMax
11816>>>>>     Decrement iMax
11817>>>>>     For iCount from 0 to iMax
11823>>>>>>
11823>>>>>        Get Data_Set_Server iCount to hPrnt
11824>>>>>        If Not (Visited_state(hPrnt)) ;           Send Private.Find_Records to hPrnt
11827>>>>>     Loop
11828>>>>>>
11828>>>>>  End_Procedure
11829>>>>>
11829>>>>>
11829>>>>>  //************************************************************************//
11829>>>>>  // Request_Save                                                           //
11829>>>>>  // Augmented to test updating connections.                                //
11829>>>>>  // If error report it.                                                    //
11829>>>>>  //************************************************************************//
11829>>>>>
11829>>>>>  Procedure Request_Save
11831>>>>>     Integer iRval
11831>>>>>     If (OPERATION_MODE=MODE_WAITING) Begin
11833>>>>>         Send Update_Focus_Field_For_Operation MODE_SAVING // added in 12.1/15.1
11834>>>>>         Get Validate_Save_Structure False to iRval
11835>>>>>         If iRval Begin
11837>>>>>            Send Data_Set_Error -1 0 DD_INVALID_SAVE_STRUCTURE iRval
11838>>>>>            Procedure_Return
11839>>>>>         End
11839>>>>>>
11839>>>>>     End
11839>>>>>>
11839>>>>>     Forward Send Request_Save
11841>>>>>  End_Procedure // Request_Save
11842>>>>>
11842>>>>>  //************************************************************************//
11842>>>>>  // Request_Delete                                                         //
11842>>>>>  // Augmented to test updating connections.                                //
11842>>>>>  // If error report it.                                                    //
11842>>>>>  //************************************************************************//
11842>>>>>
11842>>>>>  Procedure Request_Delete
11844>>>>>     Integer iRval
11844>>>>>     If (OPERATION_MODE=MODE_WAITING) Begin
11846>>>>>         Send Update_Focus_Field_For_Operation MODE_DELETING // added to 12.1/15.1
11847>>>>>         Get Validate_Delete_Structure False to iRval
11848>>>>>         If iRval Begin
11850>>>>>            Send data_Set_Error -1 0 DD_INVALID_DELETE_STRUCTURE iRval
11851>>>>>            Procedure_Return
11852>>>>>         End
11852>>>>>>
11852>>>>>     End            
11852>>>>>>
11852>>>>>     Forward Send Request_Delete
11854>>>>>  End_Procedure // Request_Delete
11855>>>>>
11855>>>>>  //************************************************************************//
11855>>>>>  //                    Status Help Support                                 //
11855>>>>>  //************************************************************************//
11855>>>>>
11855>>>>>  //************************************************************************//
11855>>>>>  // Set Status_Help                                                        //
11855>>>>>  // Set status-line help for the passed field. This could have been named  //
11855>>>>>  // Set Field_Status_Help but this keeps this message interface consistent //
11855>>>>>  // with the rest of DF for windows.                                       //
11855>>>>>  //************************************************************************//
11855>>>>>
11855>>>>>  Procedure Set Status_Help Integer iField string sVal
11857>>>>>     Set Value of (StatusHelp_Array(self)) iField to sVal
11858>>>>>  End_procedure
11859>>>>>
11859>>>>>  //************************************************************************//
11859>>>>>  // Get Status_Help                                                        //
11859>>>>>  // Get status-line help for the passed field. This could have been named  //
11859>>>>>  // Get Field_Status_Help but this keeps this message interface consistent //
11859>>>>>  // with the rest of DF for windows.                                       //
11859>>>>>  //************************************************************************//
11859>>>>>
11859>>>>>  Function Status_Help integer iField returns string
11861>>>>>     string sHelp
11861>>>>>     Integer iObj
11861>>>>>     Move (StatusHelp_Array(self)) to iObj
11862>>>>>     if (Item_Count(iObj)>iField) Begin
11864>>>>>        Get value of iObj iField to sHelp
11865>>>>>        if sHelp eq '0' move '' to shelp
11868>>>>>     end
11868>>>>>>
11868>>>>>     function_return shelp
11869>>>>>  End_Function // StatusHelp_Value
11870>>>>>
11870>>>>>  //************************************************************************//
11870>>>>>  // Get File_Field_status_Help                                             //
11870>>>>>  // Get status-line help for the passed file and field. This is called     //
11870>>>>>  // by DEOs (or any other object) that needs help for a particular file    //
11870>>>>>  // and field.                                                             //
11870>>>>>  //************************************************************************//
11870>>>>>
11870>>>>>  Function File_Field_Status_Help Integer iFile Integer iField returns string
11872>>>>>    integer iDSO
11872>>>>>    string sValue
11872>>>>>    Get Data_set iFile to iDSO
11873>>>>>    If iDSO ;      Get Status_Help of iDSO iField to sValue
11876>>>>>    Function_Return sValue
11877>>>>>  End_Function
11878>>>>>
11878>>>>>  //************************************************************************//
11878>>>>>  //                    Field Mask  Support                                 //
11878>>>>>  //************************************************************************//
11878>>>>>
11878>>>>>  //************************************************************************//
11878>>>>>  // Get/Set Field_Mask_Type                                                //
11878>>>>>  // Get     File_Field_Mask_Type                                           //
11878>>>>>  // Allows user to set a mask type. Legal value is any of the current mask //
11878>>>>>  // window types. 0 Means undefined.                                       //
11878>>>>>  //************************************************************************//
11878>>>>>
11878>>>>>  Procedure Set Field_Mask_Type Integer iField integer iType
11880>>>>>     Set Field_Mask_Type of (FieldMask_Array(Self)) iField to iType
11881>>>>>  End_procedure
11882>>>>>
11882>>>>>  Function Field_Mask_Type integer iField returns integer
11884>>>>>     Function_Return (Field_Mask_Type(FieldMask_Array(self),iField))
11885>>>>>  End_Function
11886>>>>>
11886>>>>>  Function File_Field_Mask_Type Integer iFile Integer iField returns integer
11888>>>>>    integer iDSO
11888>>>>>    Get Data_set iFile to iDSO
11889>>>>>    If iDSO ;      Function_Return (Field_Mask_Type(iDSO,iField))
11892>>>>>  End_Procedure
11893>>>>>
11893>>>>>  //************************************************************************//
11893>>>>>  // Get/Set Field_Mask_Value_State                                         //
11893>>>>>  // Get     File_Field_Mask_Value_state                                    //
11893>>>>>  // If TRUE the value returned by DEO will contain mask characters.        //
11893>>>>>  // Currently not supported.                                               //
11893>>>>>  //************************************************************************//
11893>>>>>
11893>>>>>  Procedure Set Field_Mask_Value_State Integer iField integer iState
11895>>>>>     Set Field_Mask_Value_State of (FieldMask_Array(Self)) iField to iState
11896>>>>>  End_procedure
11897>>>>>
11897>>>>>  Function Field_Mask_Value_State integer iField returns integer
11899>>>>>     Function_Return (Field_Mask_Value_State(FieldMask_Array(self),iField))
11900>>>>>  End_Function
11901>>>>>
11901>>>>>  Function File_Field_Mask_Value_State Integer iFile Integer iField returns integer
11903>>>>>    integer iDSO
11903>>>>>    Get Data_set iFile to iDSO
11904>>>>>    If iDSO ;      Function_Return (Field_Mask_Value_State(iDSO,iField))
11907>>>>>  End_Procedure
11908>>>>>
11908>>>>>  //************************************************************************//
11908>>>>>  // Get/Set Field_Mask                                                     //
11908>>>>>  // Get     File_Field_Mask                                                //
11908>>>>>  // Allows user to set a mask strinng. Legal value is any of the current   //
11908>>>>>  // masks. Note an empty string with a valid mask type implies that the    //
11908>>>>>  // system should figure it out by itself.                                 //
11908>>>>>  //************************************************************************//
11908>>>>>
11908>>>>>  Procedure Set Field_Mask Integer iField string sMask
11910>>>>>     Set Field_Mask of (FieldMask_Array(Self)) iField to sMask
11911>>>>>     If (Data_Set_User_Interface_Count(self)) ;          Send Field_Mask_Changed iField sMask
11914>>>>>  End_procedure
11915>>>>>
11915>>>>>  Function Field_Mask integer iField returns string
11917>>>>>     Function_Return (Field_Mask(FieldMask_Array(self),iField))
11918>>>>>  End_Function
11919>>>>>
11919>>>>>  Function File_Field_Mask Integer iFile Integer iField returns string
11921>>>>>    integer iDSO
11921>>>>>    string sValue
11921>>>>>    Get Data_set iFile to iDSO
11922>>>>>    If iDSO ;       Get Field_Mask of iDSO iField to sValue
11925>>>>>    Function_Return sValue
11926>>>>>  End_Function
11927>>>>>
11927>>>>>  //************************************************************************//
11927>>>>>  // Get/Set Field_Label_Short                                               //
11927>>>>>  // Get     File_Field_Label_Short                                          //
11927>>>>>  // Short for field. This is normally used by grid headers.                //
11927>>>>>  //************************************************************************//
11927>>>>>
11927>>>>>  Procedure Set Field_Label_Short Integer iField string sName
11929>>>>>     Set Field_Label_Short of (FieldMask_Array(Self)) iField to sName
11930>>>>>     If (Data_Set_User_Interface_Count(self)) ;          Send Field_Label_Changed iField 0 sName
11933>>>>>  End_procedure
11934>>>>>
11934>>>>>  Function Field_Label_Short integer iField returns string
11936>>>>>     Function_Return (Field_Label_Short(FieldMask_Array(self),iField))
11937>>>>>  End_Function
11938>>>>>
11938>>>>>  Function File_Field_Label_Short Integer iFile Integer iField returns string
11940>>>>>    integer iDSO
11940>>>>>    string sValue
11940>>>>>    Get Data_set iFile to iDSO
11941>>>>>    If iDSO ;       Get Field_Label_Short of iDSO iField to sValue
11944>>>>>    Function_Return sValue
11945>>>>>  End_Function
11946>>>>>
11946>>>>>  //************************************************************************//
11946>>>>>  // Get/Set Field_Label_Long                                                //
11946>>>>>  // Get     File_Field_Label_Long                                           //
11946>>>>>  // Full Name for field. This is normally used by form labels              //
11946>>>>>  //************************************************************************//
11946>>>>>
11946>>>>>  Procedure Set Field_Label_Long Integer iField string sName
11948>>>>>     Set Field_Label_Long of (FieldMask_Array(Self)) iField to sName
11949>>>>>     If (Data_Set_User_Interface_Count(self)) ;          Send Field_Label_Changed iField 1 sName
11952>>>>>  End_procedure
11953>>>>>
11953>>>>>  Function Field_Label_Long integer iField returns string
11955>>>>>     Function_Return (Field_Label_Long(FieldMask_Array(self),iField))
11956>>>>>  End_Function
11957>>>>>
11957>>>>>  Function File_Field_Label_Long Integer iFile Integer iField returns string
11959>>>>>    integer iDSO
11959>>>>>    string sValue
11959>>>>>    Get Data_set iFile to iDSO
11960>>>>>    If iDSO ;       Get Field_Label_Long of iDSO iField to sValue
11963>>>>>    Function_Return sValue
11964>>>>>  End_Function
11965>>>>>
11965>>>>>  //************************************************************************//
11965>>>>>  // Get Field_Label_Tag                                                     //
11965>>>>>  // This is not really a DD attribute (it is in the API) but it is         //
11965>>>>>  // appropriate to be accessed from the DD                                 //
11965>>>>>  //************************************************************************//
11965>>>>>
11965>>>>>  Function Field_Label_Tag integer iField returns string
11967>>>>>     String sName
11967>>>>>     Integer iFile
11967>>>>>     Get Main_File to iFile
11968>>>>>     If iFile ;        Get_Attribute DF_FIELD_NAME of iFile iField to sName
11973>>>>>     Function_Return sName
11974>>>>>  End_Function
11975>>>>>
11975>>>>>  function SmartCase string sName returns string
11977>>>>>    integer iPos iNewPos
11977>>>>>    string sRight
11977>>>>>    Move (Replaces("_",lowercase(sName)," ")) to sName
11978>>>>>    Trim (Replaces(".",sName," ")) to sName
11979>>>>>>
11979>>>>>    Move 1 to iPos
11980>>>>>    Repeat
11980>>>>>>
11980>>>>>        Move (mid(sName,255,iPos+1)) to sRight
11981>>>>>        Move (left(sName,iPos-1) + Uppercase(mid(sName,1,iPos)) + sRight) to sName
11982>>>>>        Pos " " in sRight to iNewPos
11984>>>>>>
11984>>>>>        If iNewPos eq 0 break
11987>>>>>        Add (iNewPos+1) to iPos
11988>>>>>    Loop
11989>>>>>>
11989>>>>>    Function_Return sName
11990>>>>>  end_function
11991>>>>>
11991>>>>>  Enumeration_List
11991>>>>>     Define DD_LABEL_SHORT
11991>>>>>     Define DD_LABEL_LONG
11991>>>>>     Define DD_LABEL_TAG
11991>>>>>  End_Enumeration_List
11991>>>>>
11991>>>>>  //************************************************************************//
11991>>>>>  // Get Field_Label                                                        //
11991>>>>>  // Get File_Field_Label                                                   //
11991>>>>>  // Handy function to get the label for a field. Three "types" are         //
11991>>>>>  // supported:                                                             //
11991>>>>>  // DD_LABEL_SHORT  use short, if none use long, if none use smart tag     //
11991>>>>>  // DD_LABEL_LONG   use long, if none use smart tag                        //
11991>>>>>  // DD_LABEL_TAG    use smart tag                                          //
11991>>>>>  // If you want an explicit field name use oneof the other messages.       //
11991>>>>>  //************************************************************************//
11991>>>>>
11991>>>>>  Function Field_Label Integer iField Integer iType returns string
11993>>>>>    Integer iServer
11993>>>>>    string sValue
11993>>>>>    If iType eq DD_LABEL_SHORT ;  // 0 = Short       Get Field_Label_Short iField to sValue
11996>>>>>    If (iType eq DD_LABEL_LONG OR (iType=DD_LABEL_SHORT and sValue='')) ;       Get Field_Label_Long iField to sValue
11999>>>>>    If (iType eq DD_LABEL_TAG OR sValue="") Begin
12001>>>>>       Get Field_Label_Tag iField to sValue
12002>>>>>       Get SmartCase sValue to sValue
12003>>>>>    End
12003>>>>>>
12003>>>>>    Function_Return sValue
12004>>>>>  End_Function // Field_Label
12005>>>>>
12005>>>>>  Function File_Field_Label Integer iFile Integer iField Integer iType returns string
12007>>>>>    integer iDSO
12007>>>>>    string sValue
12007>>>>>    Get Data_set iFile to iDSO
12008>>>>>    If iDSO ;       Get Field_Label of iDSO iField iType to sValue
12011>>>>>    Function_Return sValue
12012>>>>>  End_Function // File_Field_Label
12013>>>>>
12013>>>>>
12013>>>>>  //************************************************************************//
12013>>>>>  // Get/Set Field_Class_Name                                               //
12013>>>>>  // Normally this will not be used by a running program. However, it       //
12013>>>>>  // could be possible to create classes dynamically at runtime, in which   //
12013>>>>>  // case these messages could be useful. No File_Field is provided. If the //
12013>>>>>  // person knows enough to create dynamic classes they can find the DD.    //
12013>>>>>  //************************************************************************//
12013>>>>>
12013>>>>>  Procedure Set Field_Class_Name Integer iField string sName
12015>>>>>     Set Field_Class_Name of (FieldMask_Array(Self)) iField to sName
12016>>>>>  End_procedure
12017>>>>>
12017>>>>>  Function Field_Class_Name integer iField returns string
12019>>>>>     Function_Return (Field_Class_Name(FieldMask_Array(self),iField))
12020>>>>>  End_Function
12021>>>>>
12021>>>>>  //************************************************************************//
12021>>>>>  //                    Field and General Data-Set Error Support            //
12021>>>>>  //************************************************************************//
12021>>>>>
12021>>>>>  //************************************************************************//
12021>>>>>  // Set Field_Error                                                        //
12021>>>>>  // This procedure should be used to set a specific error number and       //
12021>>>>>  // message for a particular field. This can be used with the Field_error  //
12021>>>>>  // message to generate this error during a validation.                    //
12021>>>>>  //************************************************************************//
12021>>>>>
12021>>>>>  Procedure Set Field_Error Integer iField Integer iErr String sMsg
12023>>>>>    Set Field_Error of (Field_Attributes(self)) iField to iErr sMsg
12024>>>>>  End_Procedure
12025>>>>>
12025>>>>>  //************************************************************************//
12025>>>>>  // Get Field_error_Number                                                 //
12025>>>>>  // Get Field_error_Message                                                //
12025>>>>>  // Used to retreive the error number and message for a particular field   //
12025>>>>>  //************************************************************************//
12025>>>>>
12025>>>>>  Function Field_Error_Number Integer iField Returns Integer
12027>>>>>      Function_Return (Field_Error_Number(Field_Attributes(self),iField))
12028>>>>>  End_Function
12029>>>>>
12029>>>>>  Function Field_Error_Message Integer iField Returns String
12031>>>>>      Function_Return (Field_Error_Message(Field_Attributes(self),iField))
12032>>>>>  End_Function
12033>>>>>
12033>>>>>  //************************************************************************//
12033>>>>>  // Procedure Field_Error                                                  //
12033>>>>>  // This procedure is used to declare an error on a standard field         //
12033>>>>>  // validation violation like Range or Check.                              //
12033>>>>>  // Can pass 1 to 4 params:                                                //
12033>>>>>  // iField -                  Standard usage. Generates field as defined   //
12033>>>>>  //                           for this field. If field=-1, General error   //
12033>>>>>  // iField SDefault           If no field error mess (or field=-1) use     //
12033>>>>>  //                           the default message                          //
12033>>>>>  // iField sDefault sParam1 {sParam2} Replace occurances of @PARAM1 and    //
12033>>>>>  //                           @PARAM2 in text with these values            //
12033>>>>>  //************************************************************************//
12033>>>>>
12033>>>>>  Procedure Field_Error Integer iField String sDefault ;                        String sParam1 String sParam2
12035>>>>>     Integer iErr
12035>>>>>     String  sMess
12035>>>>>     If iField ge 0 Begin
12037>>>>>        Get Field_Error_Number  iField to iErr
12038>>>>>        Get Field_Error_Message iField to sMess
12039>>>>>     End
12039>>>>>>
12039>>>>>     If (sMess="" And Num_Arguments>1) ;        Move sDefault to sMess
12042>>>>>     If Num_Arguments eq 4 ;        Send Data_Set_Error iField iErr sMess sParam1 sParam2
12045>>>>>     else If Num_Arguments eq 3 ;        Send Data_Set_Error iField iErr sMess sParam1
12049>>>>>     Else ;        Send Data_Set_Error iField iErr sMess
12051>>>>>  End_procedure
12052>>>>>
12052>>>>>
12052>>>>>  //************************************************************************//
12052>>>>>  // Procedure Data_Set_Error                                               //
12052>>>>>  // This procedure is used to declare a data-set error. Pass error number  //
12052>>>>>  // and optional error message text.                                       //
12052>>>>>  // If iErr is 0, use the default error number.                            //
12052>>>>>  // sParam1 and sParam2 are optional. If passed they are used as text      //
12052>>>>>  // replacements for @PARAM1 and @PARAM2.                                  //
12052>>>>>  // We pass iField (even though we don't use it) so that augmentations     //
12052>>>>>  // could support error logging down to a field level. If a non-field error//
12052>>>>>  // is required the developer should pass negative values (e.g., -1)       //
12052>>>>>  // This will redirect errors locally if not already redirected            //
12052>>>>>  //                                                                        //
12052>>>>>  // Altered to additionally support %1 %2 replacements as well as          //
12052>>>>>  // replacements for @PARAM1 and @PARAM2. (vdf8.2)                         //
12052>>>>>  //************************************************************************//
12052>>>>>
12052>>>>>
12052>>>>>  Procedure Data_set_error Integer iField Integer iErr String sMess ;                           String sParam1 String sParam2
12054>>>>>    integer iOldField
12054>>>>>    Get Current_validate_field to iOldField
12055>>>>>    If iField ne 0 Set Current_Validate_field to iField
12058>>>>>
12058>>>>>    If iErr eq 0 ; // if no error is passes, used a default error       Move DD_DEFAULT_ERROR_NUMBER to iErr
12061>>>>>
12061>>>>>    If sMess GT "" Begin
12063>>>>>
12063>>>>>       // Support message replacements.. Up to two values
12063>>>>>       // altered to support @Param1/2 and %1 %2 messages
12063>>>>>       If (Num_Arguments>3) begin
12065>>>>>          Move (Replaces("@PARAM1", sMess, sParam1)) to sMess
12066>>>>>          If (Num_Arguments>4) begin
12068>>>>>              Move (Replaces("@PARAM2", sMess, sParam2)) to sMess
12069>>>>>              Move (SFormat(sMess,sParam1,sParam2)) to sMess
12070>>>>>          end
12070>>>>>>
12070>>>>>          else begin
12071>>>>>              Move (SFormat(sMess,sParam1)) to sMess
12072>>>>>          end
12072>>>>>>
12072>>>>>       end
12072>>>>>>
12072>>>>>       Move self to ghoErrorSource
12073>>>>>       Error iErr sMess
12074>>>>>>
12074>>>>>       Move 0 to ghoErrorSource
12075>>>>>    End
12075>>>>>>
12075>>>>>    Else ;      Send Operation_Not_Allowed iErr
12077>>>>>    Set Current_validate_field to iOldField
12078>>>>>    Move True to Err // make sure Err is still set
12079>>>>>  End_Procedure
12080>>>>>
12080>>>>>  //************************************************************************//
12080>>>>>  // Procedure Operation_not_allowed                                        //
12080>>>>>  // Augment to support Error_Report_Mode. Allows errors without error mess //
12080>>>>>  // This will redirect errors locally if not already redirected            //
12080>>>>>  //************************************************************************//
12080>>>>>
12080>>>>>  Procedure Operation_Not_Allowed integer iErr
12082>>>>>       integer bOK
12082>>>>>       Move self to ghoErrorSource
12083>>>>>       Forward Send Operation_Not_Allowed iErr
12085>>>>>       Move 0 to ghoErrorSource
12086>>>>>  End_Procedure
12087>>>>>
12087>>>>>// ----------Start of Experimental code not yet ready for 8.3 ----------
12087>>>>>//  //Doc/ Visibility=Private
12087>>>>>//  Procedure Data_set_error Integer iField Integer iErr String sMess ;
12087>>>>>//                           String sParam1 String sParam2
12087>>>>>//
12087>>>>>//    If iErr eq 0 ; // if no error is passes, used a default error
12087>>>>>//       Move DD_DEFAULT_ERROR_NUMBER to iErr
12087>>>>>//
12087>>>>>//    If sMess GT "" Begin
12087>>>>>//
12087>>>>>//       // Support message replacements.. Up to two values
12087>>>>>//       // altered to support @Param1/2 and %1 %2 messages
12087>>>>>//       If (Num_Arguments>3) begin
12087>>>>>//          Move (Replaces("@PARAM1", sMess, sParam1)) to sMess
12087>>>>>//          If (Num_Arguments>4) begin
12087>>>>>//              Move (Replaces("@PARAM2", sMess, sParam2)) to sMess
12087>>>>>//              Move (SFormat(sMess,sParam1,sParam2)) to sMess
12087>>>>>//          end
12087>>>>>//          else begin
12087>>>>>//              Move (SFormat(sMess,sParam1)) to sMess
12087>>>>>//          end
12087>>>>>//       end
12087>>>>>//    End
12087>>>>>//    Send DDError iErr sMess iField
12087>>>>>//  End_Procedure
12087>>>>>//
12087>>>>>//  //Doc/ Visibility=Public
12087>>>>>// Procedure DDError integer iError string sError integer iErrorField
12087>>>>>//    integer iOldField iField
12087>>>>>//    Get Current_validate_field to iOldField
12087>>>>>//    If (Num_Arguments<3) Move 0 to iField
12087>>>>>//    else                 Move iErrorField to iField
12087>>>>>//    If (iField<>0) Set Current_Validate_field to iErrorField
12087>>>>>//    Move self to ghoErrorSource
12087>>>>>//    Send OnDDError iError sError iField
12087>>>>>//    Move 0 to ghoErrorSource
12087>>>>>//    Set Current_validate_field to iOldField
12087>>>>>//  End_Procedure
12087>>>>>//
12087>>>>>//  //Doc/ MethodType=Event Visibility=Public
12087>>>>>//  Procedure OnDDError integer iError String sError integer iField
12087>>>>>////       showln "OnDDError: " (object_label(self)) ' error=' iError ' field=' iField ' Message='  sError
12087>>>>>//       Error iError sError
12087>>>>>//  End_Procedure
12087>>>>>//
12087>>>>>//  //************************************************************************//
12087>>>>>//  // Procedure Operation_not_allowed                                        //
12087>>>>>//  // Augment to support Error_Report_Mode. Allows errors without error mess //
12087>>>>>//  // This will redirect errors locally if not already redirected            //
12087>>>>>//  //************************************************************************//
12087>>>>>//
12087>>>>>//  //Doc/ Visibility=Public Obsolete=True
12087>>>>>//  Procedure Operation_Not_Allowed integer iErr
12087>>>>>//      Send DDError iErr ""
12087>>>>>//  End_Procedure
12087>>>>>// ----------End of Experimental code not yet ready for 8.3 ----------
12087>>>>>
12087>>>>>  //************************************************************************//
12087>>>>>  // Procedure Error_report                                                 //
12087>>>>>  // Local error handler. When errors are redirected to the DD this proce-  //
12087>>>>>  // dure handles the errors. If error_report_mode is NO-report it sets     //
12087>>>>>  // the err indicator and returns. Else it redirects the error to the      //
12087>>>>>  // main error handler first moving its ID to ghoErrorSource. This way the //
12087>>>>>  // handler knows who sent this message and will get additional error info //
12087>>>>>  // by calling Get Extended_error_message                                  //
12087>>>>>  //************************************************************************//
12087>>>>>
12087>>>>>  Procedure Error_Report integer iError integer iLine string ErrMsg
12089>>>>>    integer hoErrId
12089>>>>>    integer bRedirect
12089>>>>>    If (Error_Processing_State(self)) ;  // this prevents recursion        Procedure_Return
12092>>>>>    Set Error_Processing_State to True
12093>>>>>
12093>>>>>    // if no report mode, just set the err indicator to true.
12093>>>>>    If (Error_Report_Mode(self)=DD_ERROR_NO_REPORT) ;        Indicate Err True
12096>>>>>    else begin
12097>>>>>        get Old_error_object_id to hoErrId  // the original error handler
12098>>>>>        If hoErrId Begin
12100>>>>>            Move (ghoErrorSource=0) to bRedirect
12101>>>>>            if bRedirect move self to ghoErrorSource // error handler can use this
12104>>>>>            move hoErrID to Error_object_id
12105>>>>>            Send Error_Report to hoErrId iError iLine ErrMsg
12106>>>>>            Move self to Error_object_id
12107>>>>>            if bRedirect move 0 to ghoErrorSource
12110>>>>>        end
12110>>>>>>
12110>>>>>        else send error_report of desktop iError iLine ErrMsg
12112>>>>>        //else forward send error_report iError iLine ErrMsg
12112>>>>>    end
12112>>>>>>
12112>>>>>    Set Error_Processing_State to False
12113>>>>>  End_Procedure
12114>>>>>
12114>>>>>  //************************************************************************//
12114>>>>>  // Function Extended_error_message                                        //
12114>>>>>  // This is called (by the system error handler) to get additional informa-//
12114>>>>>  // tion about the error. Returns a multi line string with each line       //
12114>>>>>  // separated by a "\n". Return the file number, name, and if possible     //
12114>>>>>  // the field number and name.                                             //
12114>>>>>  //************************************************************************//
12114>>>>>
12114>>>>>  Function Extended_Error_Message returns string
12116>>>>>    string sExtMess
12116>>>>>    string sFile
12116>>>>>    integer iFile iField
12116>>>>>    Get main_file to iFile
12117>>>>>    Get Current_Validate_Field to iField
12118>>>>>    Get_Attribute DF_FILE_LOGICAL_NAME of iFile to sFile
12121>>>>>    Move (DD_FILE_TEXT* string(iFile) * "-" * sFile) to sExtMess
12122>>>>>    If iField GT 0;       Append sExtMess "\n" ;            (DD_FIELD_TEXT* string(iField) * "-" * Field_Label(self,iField,DD_LABEL_LONG))
12126>>>>>    Set Current_Validate_Field to 0
12127>>>>>    function_return sExtMess
12128>>>>>  End_Function
12129>>>>>
12129>>>>>  Function Extended_Error_File Returns Integer
12131>>>>>    Function_Return (Main_File(self))
12132>>>>>  End_Function
12133>>>>>
12133>>>>>  Function Extended_Error_Field Returns Integer
12135>>>>>    Function_Return (Current_Validate_Field(self))
12136>>>>>  End_Function
12137>>>>>
12137>>>>>
12137>>>>>  //************************************************************************//
12137>>>>>  // The following messages are used to control smart file mode exception   //
12137>>>>>  // handling. The message "Send Add_system_File file# Fg" allows you to    //
12137>>>>>  // add system files (or any other files not known to the dso structure)   //
12137>>>>>  // within define_fields. This allows you to not have to augment the msg   //
12137>>>>>  // reset_filemodes_for_lock. The only truly public messages here are      //
12137>>>>>  // Add_system_file and Remove_system_File (which s/b rarely used).        //
12137>>>>>  //************************************************************************//
12137>>>>>
12137>>>>>  //************************************************************************//
12137>>>>>  // Procedure Add_System_File                                              //
12137>>>>>  // Adds a system file for smart_file_mode handling. A second optional     //
12137>>>>>  // parameter may be passed to determine of the sys file should only be    //
12137>>>>>  // locked during a new save (and not during a delete or a save of an      //
12137>>>>>  // existing record). It is expected that this will be the only public     //
12137>>>>>  // message used to control smart filemode. All of the remaining sys file  //
12137>>>>>  // messages are considered advanced.                                      //
12137>>>>>  //************************************************************************//
12137>>>>>
12137>>>>>  Procedure Add_System_File integer iFile integer iLock_Mode
12139>>>>>    integer iobj iCnt iMode
12139>>>>>    If Num_arguments eq 1 Move DD_Lock_on_All to iMode
12142>>>>>    Else                  Move iLock_Mode     to iMode
12144>>>>>    Move (system_file_obj(self)) to iObj
12145>>>>>    Get Item_Count  of iObj to iCnt
12146>>>>>    Set Array_Value of iObj iCnt to iFile
12147>>>>>    Increment iCnt
12148>>>>>    Set Array_Value of iObj iCnt to iMode
12149>>>>>  End_procedure
12150>>>>>
12150>>>>>  //************************************************************************//
12150>>>>>  // Function System_File_Count                                             //
12150>>>>>  // Return number of system files                                          //
12150>>>>>  //************************************************************************//
12150>>>>>
12150>>>>>  Function System_File_Count returns integer
12152>>>>>    Function_Return (Item_Count(System_File_Obj(self))/2)
12153>>>>>  End_Function // System_File_Count
12154>>>>>
12154>>>>>  //************************************************************************//
12154>>>>>  // Function System_File_Number                                            //
12154>>>>>  // Returns system file number for passed item.                            //
12154>>>>>  //************************************************************************//
12154>>>>>
12154>>>>>  Function System_File_Number Integer iItem returns Integer
12156>>>>>    Function_Return (Integer_Value(System_File_Obj(self),iItem*2))
12157>>>>>  End_Function
12158>>>>>
12158>>>>>  //************************************************************************//
12158>>>>>  // Function System_File_Lock_Mode                                         //
12158>>>>>  // Returns system flag to determine if file is only used during a new     //
12158>>>>>  // save (and not during an exiting save or a delete).                     //
12158>>>>>  //************************************************************************//
12158>>>>>
12158>>>>>  Function System_File_Lock_Mode integer iItem returns integer
12160>>>>>    Function_Return (Integer_Value(System_File_Obj(self),iItem*2+1))
12161>>>>>  End_Function
12162>>>>>
12162>>>>>  //************************************************************************//
12162>>>>>  // Procedure Remove_System_File                                           //
12162>>>>>  // Removes a system_file for smart_file_Mode handling. This remvoes the   //
12162>>>>>  // first occurance of the file (S/b the only occurance). We assume that   //
12162>>>>>  // this will be rarely used.                                              //
12162>>>>>  //************************************************************************//
12162>>>>>
12162>>>>>  Procedure Remove_System_File integer iFile
12164>>>>>    integer iobj iCnt iItmCnt
12164>>>>>    Get System_file_Count to iItmCnt
12165>>>>>    Decrement iItmCnt
12166>>>>>    For iCnt from 0 to iItmCnt
12172>>>>>>
12172>>>>>        If (System_File_Number(self,iCnt)=iFile) Begin
12174>>>>>           Move (system_file_obj(self)) to iObj
12175>>>>>           Move (iCnt*2) to iCnt
12176>>>>>           Send Delete_Item to iObj iCnt
12177>>>>>           Send Delete_Item to iObj iCnt
12178>>>>>           Procedure_Return
12179>>>>>        End
12179>>>>>>
12179>>>>>    Loop
12180>>>>>>
12180>>>>>  End_Procedure
12181>>>>>  
12181>>>>>  // These set messages, add_client_file, add_server_file and add_system_file 
12181>>>>>  // were added to more easily support visual DD class modeling. They do the
12181>>>>>  // same thing the Send counterpart messages do
12181>>>>>
12181>>>>>  Procedure Set Add_Client_File Integer iFile
12183>>>>>      Send Add_Client_File iFile
12184>>>>>  End_Procedure
12185>>>>>  
12185>>>>>  Procedure Set Add_Server_File Integer iFile
12187>>>>>      Send Add_Server_File iFile
12188>>>>>  End_Procedure
12189>>>>>
12189>>>>>  Procedure Set Add_System_File Integer iFile Integer iLock_Mode
12191>>>>>      // allow no arguments because the old message allowed this
12191>>>>>      If (Num_arguments=1) Begin
12193>>>>>          Send Add_System_File iFile
12194>>>>>      End
12194>>>>>>
12194>>>>>      Else Begin
12195>>>>>          Send Add_System_File iFile iLock_Mode
12196>>>>>      End
12196>>>>>>
12196>>>>>  End_Procedure
12197>>>>>  
12197>>>>>  // The Set Field_Auto_Increment method replaces the need to use the Define_Auto_Incrmement
12197>>>>>  // command. This models more easily and it supports multiple auto-increment fields
12197>>>>>  Procedure Set Field_Auto_Increment Integer iField Integer iSysFile Integer iSysField
12199>>>>>      Integer[] AutoIncFields
12200>>>>>      tDDFileField[] SysFileFields
12200>>>>>      tDDFileField[] SysFileFields
12201>>>>>      Integer iIndex
12201>>>>>
12201>>>>>      If (iField=0 or (iSysFile<>0 and iSysField=0)) Begin
12203>>>>>          Error DFERR_PROGRAM "Auto-increment source or destination field is 0"
12204>>>>>>
12204>>>>>          Procedure_Return
12205>>>>>      End
12205>>>>>>
12205>>>>>      // setting the sysfile to 0 is valid. It can be used to clear an existing sysfile       
12205>>>>>      If (iSysFile=0) Begin
12207>>>>>          Move 0 to iSysField
12208>>>>>      End
12208>>>>>>
12208>>>>>      Get pAutoIncrementFields to AutoIncFields
12209>>>>>      Get pAutoIncrementSysFileFields to SysFileFields
12210>>>>>      // the destination field array is a list of fields that have auto-incr info. There
12210>>>>>      // can only be zero or one entry per field arranged in no defined order.
12210>>>>>      // see if field is already defined. If not add this to the end.
12210>>>>>      Move (SearchArray(iField,AutoIncFields)) to iIndex
12211>>>>>      If (iIndex=-1) Begin
12213>>>>>          Move (SizeOfArray(SysFileFields)) to iIndex
12214>>>>>      End
12214>>>>>>
12214>>>>>      Move iField    to AutoIncFields[iIndex]      
12215>>>>>      Move iSysFile  to SysFileFields[iIndex].iFile
12216>>>>>      Move iSysField to SysFileFields[iIndex].iField
12217>>>>>      Set pAutoIncrementFields to AutoIncFields
12218>>>>>      Set pAutoIncrementSysFileFields to SysFileFields
12219>>>>>  End_Procedure
12220>>>>>  
12220>>>>>  // Get auto-increment system file/field value for a field. There really should be no
12220>>>>>  // reason to ever need this. Field is returned byref
12220>>>>>  Function Field_Auto_Increment Integer iField Integer ByRef iSysField Returns Integer 
12222>>>>>      Integer iSysFile
12222>>>>>      Integer[] AutoIncFields
12223>>>>>      tDDFileField[] SysFileFields
12223>>>>>      tDDFileField[] SysFileFields
12224>>>>>      Integer iIndex
12224>>>>>
12224>>>>>      Get pAutoIncrementFields to AutoIncFields
12225>>>>>      Move (SearchArray(iField,AutoIncFields)) to iIndex
12226>>>>>      If (iIndex>-1) Begin
12228>>>>>          Get pAutoIncrementSysFileFields to SysFileFields
12229>>>>>          Move SysFileFields[iIndex].iFile to iSysFile
12230>>>>>          Move SysFileFields[iIndex].iField to iSysField
12231>>>>>      End
12231>>>>>>
12231>>>>>      Else Begin
12232>>>>>          Move 0 to iSysFile
12233>>>>>          Move 0 to iSysField
12234>>>>>      End
12234>>>>>>
12234>>>>>      Function_Return iSysFile
12235>>>>>  End_Procedure
12236>>>>>  
12236>>>>>   
12236>>>>>
12236>>>>>  //************************************************************************//
12236>>>>>  // Procedure Reset_FileModes_for_Lock                                     //
12236>>>>>  // Augmented to set any system files defined via the Add_System_file      //
12236>>>>>  // message. This allows us to hide this procedure for the vast majority   //
12236>>>>>  // of cases.                                                              //
12236>>>>>  //************************************************************************//
12236>>>>>
12236>>>>>    Procedure Reset_Filemodes_For_Lock
12238>>>>>        Boolean bNewRec
12238>>>>>        Integer  iItmCnt iCnt iMode iFile
12238>>>>>        Integer iMain iMaster iOpts
12238>>>>>        Handle hoDD
12238>>>>>        
12238>>>>>        Forward Send Reset_Filemodes_for_lock
12240>>>>>        
12240>>>>>        Get System_File_Count to iItmCnt
12241>>>>>        If iItmCnt Begin
12243>>>>>            Move (not(HasRecord(Self))) to bNewRec
12244>>>>>            Decrement iItmCnt
12245>>>>>            For iCnt from 0 to iItmCnt
12251>>>>>>
12251>>>>>                Get System_File_Number         iCnt to iFile
12252>>>>>                Get System_File_Lock_Mode iCnt to iMode
12253>>>>>                If ( (iMode=DD_Lock_on_All) or ;                (Operation_Mode=MODE_DELETING and (iMode iand DD_Lock_on_Delete) ) or ;                (Operation_Mode=MODE_SAVING and ( (iMode iand DD_Lock_on_Save) or ;                ( (iMode iand DD_Lock_on_New_Save) and bNewRec) ) ) ) Begin
12255>>>>>                    Set_Attribute DF_FILE_MODE of iFile to DF_FILEMODE_DEFAULT
12258>>>>>                End
12258>>>>>>
12258>>>>>            Loop
12259>>>>>>
12259>>>>>        End
12259>>>>>>
12259>>>>>        
12259>>>>>        // augment to support DD magnaged alias tables.
12259>>>>>        // If an alias, set the alias to the proper alias no locks only if 
12259>>>>>        // the master file is actually part of this DDO structure. This allows you
12259>>>>>        // to use alias files without the master being present (or even open). This will work without needing
12259>>>>>        // to set the Master|Alias DF_FILE_ALIAS attributes. If the file is master and part of the DDO structure
12259>>>>>        // it will already have its No_locks attribute cleared. If not part of the DD, its not needed.
12259>>>>>        // 
12259>>>>>        Get MasterForAlias to iMaster
12260>>>>>        If iMaster Begin
12262>>>>>            Get Main_File to iMain
12263>>>>>            Get Data_Set iMaster to hoDD // is the master in the DD structure
12264>>>>>            If hoDD Begin
12266>>>>>                Get_Attribute DF_FILE_MODE of iMain to iOpts            
12269>>>>>                Set_Attribute DF_FILE_MODE of iMain to (iOpts ior DF_FILEMODE_NO_LOCKS)           
12272>>>>>                // note this will be reset to what it was when the transaction ends
12272>>>>>            End
12272>>>>>>
12272>>>>>        End
12272>>>>>>
12272>>>>>    
12272>>>>>    End_Procedure
12273>>>>>
12273>>>>>  //************************************************************************//
12273>>>>>  // Procedure AutoIncrement                                                //
12273>>>>>  // Augmented to handle auto-increment fields if defined. The value from   //
12273>>>>>  // the auto-incre sys file is incremented, saved and moved to the new     //
12273>>>>>  // record. As of 17.0 this is no longer in Creating, which is called after//
12273>>>>>  // AutoIncrement.                                                         //
12273>>>>>  //************************************************************************//
12273>>>>>
12273>>>>>  Procedure AutoIncrement
12275>>>>>    Integer iSrcFile iSrcField i iAutoFields
12275>>>>>    integer iDestFile iDestField
12275>>>>>    Number nNum
12275>>>>>    Integer[] AutoIncFields
12276>>>>>    tDDFileField[] AutoIncSysFileFields
12276>>>>>    tDDFileField[] AutoIncSysFileFields
12277>>>>>    Handle hoOwner
12277>>>>>    
12277>>>>>    Forward Send AutoIncrement
12279>>>>>
12279>>>>>    // this supports the older Define_Auto_Increment logic. Only one is supported
12279>>>>>    // this is exists for backwards compatibility
12279>>>>>    Get Auto_Increment_Source_File to iSrcFile
12280>>>>>    If iSrcFile Begin // do we have auto increment?
12282>>>>>       Get Auto_Increment_Source_Field  to iSrcField
12283>>>>>       Get Auto_Increment_Dest_Field    to iDestField
12284>>>>>       If (iSrcField AND iDestField) Begin  // just in case of error
12286>>>>>          Get Main_file to iDestFile
12287>>>>>          Get_Field_Value iSrcFile iSrcField to nNum
12290>>>>>          Move (nNum+1) to nNum
12291>>>>>          Set_Field_Value iSrcFile  iSrcField  to nNum
12294>>>>>          Set_Field_Value iDestFile iDestField to nNum
12297>>>>>          // if the file's DD is a parent file in the structure, this will get saved as part of normal operations
12297>>>>>          // if the DD is not a parent file, it is a sysfile and we must save it
12297>>>>>          Get Which_Data_Set iSrcFile to hoOwner
12298>>>>>          If not hoOwner Begin
12300>>>>>              SaveRecord iSrcFile
12301>>>>>          End
12301>>>>>>
12301>>>>>       End
12301>>>>>>
12301>>>>>    End
12301>>>>>>
12301>>>>>    // this supports the newer set syntax which support multiple fields. It is expected that you will
12301>>>>>    // use one syntax of the other, not both. If you use the old syntax, you cannot use the new one
12301>>>>>    Else Begin
12302>>>>>        Get pAutoIncrementFields to AutoIncFields
12303>>>>>        Move (SizeOfArray(AutoIncFields)) to iAutoFields
12304>>>>>        If (iAutoFields>0) Begin
12306>>>>>            Get pAutoIncrementSysFileFields to AutoIncSysFileFields
12307>>>>>            Get Main_file to iDestFile
12308>>>>>            For i from 0 to (iAutoFields-1)
12314>>>>>>
12314>>>>>               // it is legal to set the sysfile to 0, this means it has been cleared and is not used 
12314>>>>>               If (AutoIncSysFileFields[i].iFile>0) Begin
12316>>>>>                   // we assume both the fields are valid and that they've already been tested when added
12316>>>>>                   Get_Field_Value AutoIncSysFileFields[i].iFile AutoIncSysFileFields[i].iField to nNum
12319>>>>>                   Move (nNum+1) to nNum
12320>>>>>                   Set_Field_Value AutoIncSysFileFields[i].iFile AutoIncSysFileFields[i].iField to nNum
12323>>>>>                   Set_Field_Value iDestFile AutoIncFields[i] to nNum
12326>>>>>                   // if the file's DD is a parent file in the structure, this will get saved as part of normal operations
12326>>>>>                   // if the DD is not a parent file, it is a sysfile and we must save it
12326>>>>>                   Get Which_Data_Set AutoIncSysFileFields[i].iFile to hoOwner
12327>>>>>                   If not hoOwner Begin
12329>>>>>                       SaveRecord AutoIncSysFileFields[i].iFile
12330>>>>>                   End
12330>>>>>>
12330>>>>>               End
12330>>>>>>
12330>>>>>            Loop
12331>>>>>>
12331>>>>>        End
12331>>>>>>
12331>>>>>    End
12331>>>>>>
12331>>>>>
12331>>>>>  End_Procedure
12332>>>>>
12332>>>>> //************************************************************************//
12332>>>>>  // Procedure Save_main_File                                               //
12332>>>>>  // Augmented to fix a bug in the data-set C code. When a record is saved  //
12332>>>>>  // as part of a delete operation OnNewCurrentRecord is not called. It     //
12332>>>>>  // should be. We will do this in flex code for now.                       //
12332>>>>>  //************************************************************************//
12332>>>>>  Procedure Save_Main_File
12334>>>>>    RowID riRec
12334>>>>>    Integer iRec iMain
12334>>>>>    Boolean bRecnumTable bChanged
12334>>>>>
12334>>>>>    Get Main_File to iMain
12335>>>>>    Get_Attribute DF_FILE_CHANGED of iMain to bChanged
12338>>>>>    If bChanged Begin
12340>>>>>        Send OnSaveRecord // OnSaveRecord sent if there is something to save
12341>>>>>    End
12341>>>>>>
12341>>>>>
12341>>>>>    Forward Send Save_Main_File
12343>>>>>
12343>>>>>    If Operation_Mode eq MODE_DELETING Begin  // during a delete the crnt
12345>>>>>       Get CurrentRowId to riRec             // rec of parents do not change
12346>>>>>       Send OnNewCurrentRecord riRec riRec  // so old and new are the same.
12347>>>>>       // for backwards compatibility reasons, we also send new_current_record if appropriate
12347>>>>>       Get_Attribute DF_FILE_RECNUM_TABLE of iMain to bRecnumTable
12350>>>>>       If (bRecnumTable) Begin
12352>>>>>           Get_Field_Value iMain 0 to iRec
12355>>>>>           Send New_Current_Record iRec iRec
12356>>>>>       End
12356>>>>>>
12356>>>>>    End
12356>>>>>>
12356>>>>>  End_Procedure // Save_main_File
12357>>>>>
12357>>>>>
12357>>>>>  //************************************************************************//
12357>>>>>  // Procedure Clear_main_File                                               //
12357>>>>>  // Augmented to not clear if a system-file. The auto-latching of views    //
12357>>>>>  // may cause a sys file DD to get cleared. This corrects this. This really//
12357>>>>>  // belongs in Data_set (C) but we will not risk this for now.             //
12357>>>>>  //************************************************************************//
12357>>>>>
12357>>>>>  Procedure Clear_Main_File
12359>>>>>      Integer iFile iIsSys
12359>>>>>      Get Main_File to iFile
12360>>>>>      If iFile Begin
12362>>>>>         Get_Attribute DF_FILE_IS_SYSTEM_FILE of iFile to iIsSys
12365>>>>>         If iIsSys Procedure_Return
12368>>>>>      End
12368>>>>>>
12368>>>>>      Forward Send Clear_main_file
12370>>>>>  End_Procedure // Clear_main_file
12371>>>>>
12371>>>>>  //************************************************************************//
12371>>>>>  // Procedure Find Mode Index                                              //
12371>>>>>  // Executes a request_find on the mainfile. This is easier that having to //
12371>>>>>  // pass file number all the time. Useful for batch operations.            //
12371>>>>>  // If Index is 0, use find_by_recnum (it handles a recnum of 0 better)    //
12371>>>>>  //************************************************************************//
12371>>>>>
12371>>>>>  Procedure Find integer iMode integer iIndex
12373>>>>>     integer iFile
12373>>>>>     Integer iRec
12373>>>>>     get Main_file to iFile
12374>>>>>     if (iIndex<>0 OR iMode<>EQ) ;        Send request_find iMode iFile iIndex
12377>>>>>     else begin
12378>>>>>        // this would never happen with row ID
12378>>>>>        Get_Field_Value iFile 0 to iRec // get recnum value
12381>>>>>        Send find_by_recnum iFile iRec
12382>>>>>     end
12382>>>>>>
12382>>>>>  End_procedure
12383>>>>>
12383>>>>>  //************************************************************************//
12383>>>>>  // Procedure Request_Clear                                                //
12383>>>>>  // Procedure Request_Clear_All                                            //
12383>>>>>  // So many people make the mistake of using requeset_clear and request_   //
12383>>>>>  // clear_all that will support these are alteratives to clear and         //
12383>>>>>  // clear_all. The preferred messages remain Clear and Clear_all.          //
12383>>>>>  // This would not work if you nested DEOs within DSOs (no-one does).      //
12383>>>>>  //************************************************************************//
12383>>>>>
12383>>>>>  Procedure Request_Clear
12385>>>>>    Send Clear
12386>>>>>  End_Procedure
12387>>>>>
12387>>>>>  Procedure Request_Clear_All
12389>>>>>    Send Clear_All
12390>>>>>  End_Procedure
12391>>>>>
12391>>>>>  // *****************************************************//
12391>>>>>  // we want changed_state to always go through the
12391>>>>>  // Record_buffer object. From there it is sent to
12391>>>>>  // here. So if state or RB does not match we must
12391>>>>>  // send to the RB object...it will delegate to here
12391>>>>>  // *****************************************************//
12391>>>>>
12391>>>>>  Procedure set Changed_State Integer bState
12393>>>>>      integer hRB
12393>>>>>      Move (record_buffer(self)) to hRB
12394>>>>>      if (hRB AND changed_state(hRB)<>bState) ;          set changed_state of hRB to bState
12397>>>>>      else ;          forward set changed_state to bState
12400>>>>>  End_Procedure
12401>>>>>
12401>>>>>    // **********************************************//
12401>>>>>    // this lets us use the new attach logic
12401>>>>>    // **********************************************//
12401>>>>>
12401>>>>>    Procedure Attach_Main_File
12403>>>>>        If (pbDDAttach(self)) Send DDAttach  // new improved attach logic
12406>>>>>        Else Forward Send Attach_Main_File   // old attach command.
12409>>>>>    End_procedure
12410>>>>>
12410>>>>>    // This is a smarter attach than the normal attach command. It only attaches data from a parent
12410>>>>>    // if 1) the DDO parent is connected to the structure and 2) if there is a record to attach. It will
12410>>>>>    // not attach empty records into a child. This should make the finding (and saving) more sensible when
12410>>>>>    // partial DD structures are used. For example, often a report does not all of the parent DDOs - however if
12410>>>>>    // they are not provided, finding can get messed up because blank data is being moved into the child before a
12410>>>>>    // find. This has been a problem since 3.0. This should just make it go away.
12410>>>>>    // as of 17.0, we get the related field info through the local DSO if needed
12410>>>>>
12410>>>>>    Procedure DDAttach
12412>>>>>        Integer iNumFields iFile iField iRelFile iRelField iType
12412>>>>>        Integer iServerCount iServer bOk bChanged iStat
12412>>>>>        Number nValue
12412>>>>>        String sValue
12412>>>>>        Date   dValue
12412>>>>>        DateTime dtValue
12412>>>>>        Boolean bUseDDRelates
12412>>>>>        Handle hoRelDD
12412>>>>>    
12412>>>>>        Get data_set_server_count to iServerCount
12413>>>>>        // short cut...no servers, no attach
12413>>>>>        If (iServerCount=0) Procedure_Return
12416>>>>>    
12416>>>>>        Get Main_File to iFile
12417>>>>>        Get pbUseDDRelates to bUseDDRelates
12418>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of iFile to iNumFields
12421>>>>>        For iField from 1 to iNumFields
12427>>>>>>
12427>>>>>            
12427>>>>>            If bUseDDRelates Begin
12429>>>>>                Get Field_Related_file iField to iRelFile
12430>>>>>            End
12430>>>>>>
12430>>>>>            Else Begin
12431>>>>>                Get_Attribute DF_FIELD_RELATED_FILE of iFile iField to iRelFile
12434>>>>>            End
12434>>>>>>
12434>>>>>            
12434>>>>>            If (iRelFile>0) Begin
12436>>>>>                // only attach if parent server exists
12436>>>>>                Move 0 to iServer
12437>>>>>                Repeat
12437>>>>>>
12437>>>>>                    Get Data_Set_Server iServer to hoRelDD
12438>>>>>                    Move (Main_file(hoRelDD)=iRelFile) to bOk
12439>>>>>                    Increment iServer
12440>>>>>                Until (bOk or iServer=iServerCount)
12442>>>>>                // before we attach check if Find mode and relfile is new and unchanged..if so skip.
12442>>>>>                // If operation_mode is 0, this is probably a Find (item_find sends attach_main_file for some reason).
12442>>>>>                If (bOK and (Operation_mode=MODE_FINDING or OPERATION_MODE=0)) Begin
12444>>>>>                    // we can test the file status to see if we have a record or not. If we have a record, we attach
12444>>>>>                    Get_Attribute DF_FILE_STATUS  of iRelFile to iStat
12447>>>>>                    If (iStat=DF_FILE_INACTIVE) Begin
12449>>>>>                        // if no record, we need to look for changes. We can't just look at the file's changed state because the DD
12449>>>>>                        // may have set defaults, which have been moved to the buffer. We should be able to check the DD's changed state
12449>>>>>                        // because this is not set with default values. When doing a find entry_update this should be ok. If this were
12449>>>>>                        // a save, this would cause problems (but this is not a save). Prior to 17.0 this was not an issue with windows
12449>>>>>                        // applications because find entry_updates were done at the DEO level (unlike web applications). 
12449>>>>>                        Get Changed_State of hoRelDD to bChanged
12450>>>>>                        Move bChanged to bOk
12451>>>>>                        
12451>>>>>                        // special Triumph workaround for Item_Find with blank inner segment. They were counting on the item_find attach_main_file
12451>>>>>                        // which would slip through the "no-attach on find when parent is empty optimization". This was needed to force a string segment
12451>>>>>                        // that was "" to get filled with spaces from the parent field. The child field was set to "" because of a constrained_clear
12451>>>>>                        // in Item_find. This workaround is as narrow as possible. If an item_find attach_main_file (operation_mode=0) and this is
12451>>>>>                        // an empty parent (bOk was just set to False), and the field is DF_Ascii and the child value is empty (no trailing spaces)
12451>>>>>                        // then force an attach. Since the parent should be "", we can just Set_Field_value to "", which fills the field buffer.
12451>>>>>                        // There is no real logic as to why this is being done other than to make it work like it used to with the least
12451>>>>>                        // amount of side-effects.
12451>>>>>                        If (not(bOk) and OPERATION_MODE=0) Begin
12453>>>>>                            Get_Attribute DF_FIELD_TYPE of iFile iField to iType
12456>>>>>                            If (iType=DF_ASCII) Begin
12458>>>>>                                Get_Field_Value iFile iField to sValue
12461>>>>>                                // if no spaces, this probably was cleared via constrained_clear in Item_Find. We should update
12461>>>>>                                If (Ascii(Left(sValue,1))=0) Begin 
12463>>>>>                                    Set_Field_Value iFile iField to ""
12466>>>>>                                End
12466>>>>>>
12466>>>>>                            End
12466>>>>>>
12466>>>>>                        End
12466>>>>>>
12466>>>>>                        
12466>>>>>                    End
12466>>>>>>
12466>>>>>//                    Get_Attribute DF_FILE_STATUS  of iRelFile to iStat
12466>>>>>//                    Get_Attribute DF_FILE_CHANGED of iRelFile to bChanged
12466>>>>>//                    Move (iStat<>DF_FILE_INACTIVE or bChanged) to bOk
12466>>>>>                End
12466>>>>>>
12466>>>>>                If bOk Begin
12468>>>>>                    
12468>>>>>                    If bUseDDRelates Begin
12470>>>>>                        Get Field_related_Field iField to iRelField
12471>>>>>                    End
12471>>>>>>
12471>>>>>                    Else Begin
12472>>>>>                        Get_Attribute DF_FIELD_RELATED_FIELD of iFile iField to iRelField
12475>>>>>                    End
12475>>>>>>
12475>>>>>                    
12475>>>>>                    Get_Attribute DF_FIELD_TYPE of iFile iField to iType
12478>>>>>                    Case Begin
12478>>>>>                        Case (iType=DF_BCD)
12480>>>>>                            Get_Field_Value iRelFile iRelField to nValue
12483>>>>>                            Set_Field_Value iFile iField to nValue
12486>>>>>                            Case Break
12487>>>>>                        Case (iType=DF_DATE)
12490>>>>>                            Get_Field_Value iRelFile iRelField to dValue
12493>>>>>                            Set_Field_Value iFile iField to dValue
12496>>>>>                            Case Break
12497>>>>>                        Case (iType=DF_DATETIME)
12500>>>>>                            Get_Field_Value iRelFile iRelField to dtValue
12503>>>>>                            Set_Field_Value iFile iField to dtValue
12506>>>>>                            Case Break
12507>>>>>                        Case Else
12507>>>>>                            Get_Field_Value iRelFile iRelField to sValue
12510>>>>>                            Set_Field_Value iFile iField to sValue
12513>>>>>                    Case End
12513>>>>>                End
12513>>>>>>
12513>>>>>            End
12513>>>>>>
12513>>>>>        Loop
12514>>>>>>
12514>>>>>    End_Procedure
12515>>>>>
12515>>>>>
12515>>>>>
12515>>>>>    //************************************************************************//
12515>>>>>    // Procedure Field_Mask_Changed                                           //
12515>>>>>    // Notify all DEOs that a mask has changed.                               //
12515>>>>>    //        this message is sent by set Field_Mask                          //
12515>>>>>    //************************************************************************//
12515>>>>>
12515>>>>>    Procedure Field_Mask_Changed Integer iField string sMask
12517>>>>>        Integer i iDEOs iDEO
12517>>>>>        Integer iMain_File
12517>>>>>        Get Main_File to iMain_File
12518>>>>>        Get Data_Set_User_Interface_Count to iDEOs
12519>>>>>        Decrement iDEOs
12520>>>>>        For i from 0 to iDEOs
12526>>>>>>
12526>>>>>            Get Data_Set_User_Interface i to iDEO
12527>>>>>            If (Extended_DEO_State(iDEO)) ;                Send File_Field_Mask_Changed to iDEO ;                    iMain_File iField sMask
12530>>>>>        Loop
12531>>>>>>
12531>>>>>    End_Procedure
12532>>>>>
12532>>>>>    //************************************************************************//
12532>>>>>    // Procedure Field_Label_Changed                                          //
12532>>>>>    // Notify all DEOs that a label has changed.                              //
12532>>>>>    //   This message is sent by Set Field_Label_long & Field_Label_Short     //
12532>>>>>    //************************************************************************//
12532>>>>>
12532>>>>>    Procedure Field_label_Changed Integer iField boolean bLong string sLabel
12534>>>>>        Integer i iDEOs iDEO
12534>>>>>        Integer iMain_File
12534>>>>>        Get Main_File to iMain_File
12535>>>>>        Get Data_Set_User_Interface_Count to iDEOs
12536>>>>>        Decrement iDEOs
12537>>>>>        For i from 0 to iDEOs
12543>>>>>>
12543>>>>>            Get Data_Set_User_Interface i to iDEO
12544>>>>>            If (Extended_DEO_State(iDEO)) ;                Send File_Field_Label_Changed to iDEO ;                    iMain_File iField bLong sLabel
12547>>>>>        Loop
12548>>>>>>
12548>>>>>    End_Procedure
12549>>>>>
12549>>>>>    //************************************************************************//
12549>>>>>    // Procedure Field_Options_Changed                                        //
12549>>>>>    // Notify all DEOs that a field option has changed.                       //
12549>>>>>    //   This message is sent by Set Field_Option                             //
12549>>>>>    //************************************************************************//
12549>>>>>
12549>>>>>    Procedure Field_Option_Changed Integer iField Integer iOptions Boolean bClear
12551>>>>>        Integer i iDEOs iDEO
12551>>>>>        Integer iMain_File
12551>>>>>        Get Main_File to iMain_File
12552>>>>>        Get Data_Set_User_Interface_Count to iDEOs
12553>>>>>        Decrement iDEOs
12554>>>>>        For i from 0 to iDEOs
12560>>>>>>
12560>>>>>            Get Data_Set_User_Interface i to iDEO
12561>>>>>            If (Extended_DEO_State(iDEO)) ;                Send File_Field_Option_Changed of iDEO ;                       iMain_File iField iOptions bClear
12564>>>>>        Loop
12565>>>>>>
12565>>>>>    End_Procedure
12566>>>>>
12566>>>>>
12566>>>>>    //************************************************************************//
12566>>>>>    // Procedure Set Field_option and File_Field_Option                       //
12566>>>>>    // Procedure Set Field_option_clear and File_Field_Option_Clear           //
12566>>>>>    // Procedure Set Field_option_toggle and File_Field_Option_toggle         //
12566>>>>>    //                                                                        //
12566>>>>>    //   Set, clear or toggle a field option                                  //
12566>>>>>    //   Multiple options can be passed as an expression                      //
12566>>>>>    //   (e.g. Set Field_option 2 (dd_Retain IOR dd_NoEnter).                 //
12566>>>>>    //   Unlike set Field_options this notifies DEOs of changes               //
12566>>>>>    //************************************************************************//
12566>>>>>
12566>>>>>    // supports setting and clearing. e.g.:
12566>>>>>    //    Set Field_Option Field Customer.Name DD_NoEnter to True
12566>>>>>    // This new syntax is now the recommended syntax but the older syntax without
12566>>>>>    // the last parameter is supported (where true is the default). The old syntax is
12566>>>>>    // only supported for compatibility. This means that Field_Option_Clear should 
12566>>>>>    // also be replaced with Field_Option
12566>>>>>    Procedure Set Field_Option Integer iField Integer iOption Boolean bSet
12568>>>>>        Boolean bSetTrue
12568>>>>>        Move (If(num_arguments>2, bSet, True)) to bSetTrue // support for old deprecated syntax
12569>>>>>        If bSetTrue Begin
12571>>>>>            Set Field_options iField to iOption
12572>>>>>        End
12572>>>>>>
12572>>>>>        Else Begin
12573>>>>>            Set Field_options iField to DD_CLEAR_FIELD_OPTIONS iOption
12574>>>>>        End
12574>>>>>>
12574>>>>>        If (Data_Set_User_Interface_Count(Self)) Begin
12576>>>>>            Send Field_Option_Changed iField iOption (not(bSetTrue))
12577>>>>>        End
12577>>>>>>
12577>>>>>    end_procedure
12578>>>>>
12578>>>>>    Procedure Set File_Field_Option Integer iFile Integer iField Integer iOption Boolean bSet
12580>>>>>        handle hoDD
12580>>>>>        Boolean bSetTrue
12580>>>>>        Move (If(num_arguments>3, bSet, True)) to bSetTrue // support for old deprecated syntax
12581>>>>>        Get Data_set iFile to hoDD
12582>>>>>        If hoDD Begin
12584>>>>>            Set Field_Option of hoDD iField iOption to bSetTrue
12585>>>>>        End
12585>>>>>>
12585>>>>>            
12585>>>>>    end_procedure
12586>>>>>
12586>>>>>    Procedure Set Field_Option_Clear Integer iField Integer iOptions
12588>>>>>        Set Field_Option iField iOptions to False
12589>>>>>        //Set Field_options iField to DD_CLEAR_FIELD_OPTIONS iOptions
12589>>>>>        //If (Data_Set_User_Interface_Count(self)) ;
12589>>>>>        //    Send Field_Option_Changed iField iOptions 1
12589>>>>>    end_procedure
12590>>>>>
12590>>>>>    Procedure Set File_Field_Option_Clear Integer iFile Integer iField Integer iOptions
12592>>>>>        Set File_Field_Option iFile iField iOptions to False
12593>>>>>        //handle hoDD
12593>>>>>        //Get Data_set iFile to hoDD
12593>>>>>        //If hoDD ;
12593>>>>>        //    Set Field_Option_Clear of hoDD iField to iOptions
12593>>>>>    end_procedure
12594>>>>>
12594>>>>>    Procedure Set Field_Option_Toggle integer iField Integer iOption
12596>>>>>        Integer iOldOption
12596>>>>>        Get Field_Options iField to iOldOption
12597>>>>>        // if old and new have overlapping bits, we assume clear
12597>>>>>        Set Field_Option iField iOption to ((iOldOption iand iOption)=0)
12598>>>>>        //If (iOldOption IAND iOption) ; // if the old and new have overlapping bits, we assume we will clear
12598>>>>>        //    Set Field_Option_Clear iField to iOption  // old and new are same, so we clear
12598>>>>>        //else ;
12598>>>>>        //    Set Field_Option iField to iOption        // old and new are not same, so we set
12598>>>>>    end_procedure
12599>>>>>
12599>>>>>    Procedure Set File_Field_Option_Toggle Integer iFile Integer iField Integer iOption
12601>>>>>        handle hoDD
12601>>>>>        Get Data_set iFile to hoDD
12602>>>>>        If hoDD ;            Set Field_Option_Toggle of hoDD iField to iOption
12605>>>>>    end_procedure
12606>>>>>
12606>>>>>    // Field_Index
12606>>>>>    // File_Field_Index
12606>>>>>    //
12606>>>>>    // This returns the main index for a field. This replaces the DSO message Field_Main_index which
12606>>>>>    // should no longer be used by DDOs. The old message has the problem that the DDO or DSO using
12606>>>>>    // this message may not be the owner of the field. So augmenting the owner DDO did not insure that
12606>>>>>    // all requests for this index would go through it. Now you can augment Field_Index and always
12606>>>>>    // be sure that any DDO requesting an index for a file (via file_field_index) will always go to
12606>>>>>    // the owner object.
12606>>>>>
12606>>>>>    function Field_Index integer iField returns integer
12608>>>>>        integer iFile iIndex iOrder
12608>>>>>        // ordering takes precendence
12608>>>>>        get ordering to iOrder
12609>>>>>        if (iOrder>=0);            move iOrder to iIndex  //ordering takes precedence over main index
12612>>>>>        Else Begin
12613>>>>>            Get Main_file to iFile
12614>>>>>            get_attribute DF_FIELD_INDEX of iFile iField to iIndex // main index field
12617>>>>>            if (iIndex=0 AND iField>0) ; // If field is not recnum and there is no index, the                move -1 to iIndex        // field has no main index
12620>>>>>        end
12620>>>>>>
12620>>>>>        function_return iIndex
12621>>>>>    end_function
12622>>>>>
12622>>>>>    // In all cases, this message should be sent instead of Field_Main_Index. If
12622>>>>>    // augmentation was used in Field_Main_Index, use Field_Index to insure the owner object
12622>>>>>    // is called.
12622>>>>>
12622>>>>>    function File_Field_Index integer iFile integer iField returns integer
12624>>>>>        integer iIndex
12624>>>>>        handle hoDD
12624>>>>>        Get Data_set iFile to hoDD
12625>>>>>        If (hoDD) ;            Get Field_Index of hoDD iField to iIndex
12628>>>>>        else ;            Move -1 to iIndex
12630>>>>>        function_return iIndex
12631>>>>>    End_Function
12632>>>>>    
12632>>>>>    // 12/1 change: Make sure all of the major DD operations update the DD with the value in
12632>>>>>    // the focus field. After the actual find, save, clar or delete, the DD buffer contains information that
12632>>>>>    // is not yet reflected in the DEOs (before refresh is called) we want to make sure that we
12632>>>>>    // don't try to get data from the DEO. Get Field_Current_Value now checks if operation_mode is
12632>>>>>    // non-zero. If it is, it always gets from the DD buffer.
12632>>>>>    
12632>>>>>    Procedure Clear
12634>>>>>         Boolean bOpOk
12634>>>>>         Move (OPERATION_MODE=MODE_WAITING or OPERATION_MODE=MODE_VALIDATING) to bOpOk
12635>>>>>         If (OPERATION_MODE=MODE_WAITING) Begin
12637>>>>>            Send Update_Focus_Field_For_Operation MODE_CLEARING
12638>>>>>         End
12638>>>>>>
12638>>>>>         If (bOpOk) Begin
12640>>>>>            Send OnPreFind DDFindClear
12641>>>>>         End
12641>>>>>>
12641>>>>>         Forward Send Clear
12643>>>>>         If (bOpOk) Begin
12645>>>>>            Send DefaultParentAutofinds
12646>>>>>            Send OnPostFind DDFindClear True
12647>>>>>         End
12647>>>>>>
12647>>>>>    End_Procedure
12648>>>>>    
12648>>>>>    Procedure Clear_All
12650>>>>>         Boolean bOpOk
12650>>>>>         Move (OPERATION_MODE=MODE_WAITING or OPERATION_MODE=MODE_VALIDATING) to bOpOk
12651>>>>>         If (OPERATION_MODE=MODE_WAITING) Begin
12653>>>>>            Send Update_Focus_Field_For_Operation MODE_CLEARINGALL
12654>>>>>         End
12654>>>>>>
12654>>>>>         Forward Send clear_all
12656>>>>>         If (bOpOk) Begin
12658>>>>>            Send DefaultParentAutofinds
12659>>>>>         End
12659>>>>>>
12659>>>>>     End_Procedure
12660>>>>>    
12660>>>>>    Procedure Request_Assign Integer iFile
12662>>>>>        Handle hoDD
12662>>>>>        Boolean bFound
12662>>>>>        Boolean bOpOk
12662>>>>>        Move (OPERATION_MODE=MODE_WAITING or OPERATION_MODE=MODE_VALIDATING) to bOpOk
12663>>>>>        If (OPERATION_MODE=MODE_WAITING) Begin
12665>>>>>            Send Update_Focus_Field_For_Operation MODE_FINDING
12666>>>>>        End
12666>>>>>>
12666>>>>>            
12666>>>>>        If (bOpOk) Begin
12668>>>>>            If (num_arguments=0 or iFile=0) Begin
12670>>>>>                Move Self to hoDD
12671>>>>>            End
12671>>>>>>
12671>>>>>            Else Begin
12672>>>>>                Get Data_Set iFile to hoDD
12673>>>>>            End
12673>>>>>>
12673>>>>>            If hoDD Begin
12675>>>>>                Send OnPreFind of hoDD DDFindRequestAssign
12676>>>>>            End
12676>>>>>>
12676>>>>>        End
12676>>>>>>
12676>>>>>        
12676>>>>>        If (num_arguments=0) Begin
12678>>>>>            Forward Send Request_Assign
12680>>>>>        End
12680>>>>>>
12680>>>>>        Else Begin
12681>>>>>            Forward Send Request_Assign iFile
12683>>>>>        End
12683>>>>>>
12683>>>>>        
12683>>>>>        If (bOpOk) Begin
12685>>>>>            If (hoDD) Begin
12687>>>>>                Move (Found) to bFound
12688>>>>>                Send OnPostFind of hoDD DDFindRequestAssign bFound 
12689>>>>>                Move bFound to Found
12690>>>>>            End
12690>>>>>>
12690>>>>>        End
12690>>>>>>
12690>>>>>    End_Procedure
12691>>>>>    
12691>>>>>    
12691>>>>>    Procedure Find_By_Recnum Integer iFile Integer iRecord
12693>>>>>         Handle hoDD
12693>>>>>         Boolean bFound
12693>>>>>         Boolean bOpOk
12693>>>>>         Move (OPERATION_MODE=MODE_WAITING or OPERATION_MODE=MODE_VALIDATING) to bOpOk
12694>>>>>         Send Update_Focus_Field_For_Operation MODE_FINDING
12695>>>>>            
12695>>>>>        If (bOpOk) Begin
12697>>>>>            Get Data_Set iFile to hoDD
12698>>>>>            If hoDD Begin
12700>>>>>                Send OnPreFind of hoDD DDFindFindByRowRec
12701>>>>>            End
12701>>>>>>
12701>>>>>        End
12701>>>>>>
12701>>>>>            
12701>>>>>        Forward Send Find_By_Recnum iFile iRecord
12703>>>>>            
12703>>>>>        If (bOpOk) Begin
12705>>>>>            If (hoDD) Begin
12707>>>>>                Move (Found) to bFound
12708>>>>>                Send OnPostFind of hoDD DDFindFindByRowRec bFound 
12709>>>>>                Move bFound to Found
12710>>>>>            End
12710>>>>>>
12710>>>>>        End
12710>>>>>>
12710>>>>>    End_Procedure
12711>>>>>
12711>>>>>    Procedure FindByRowId Integer iFile RowID riRowId
12713>>>>>         Handle hoDD
12713>>>>>         Boolean bFound
12713>>>>>         Boolean bOpOk
12713>>>>>         Move (OPERATION_MODE=MODE_WAITING or OPERATION_MODE=MODE_VALIDATING) to bOpOk
12714>>>>>         Send Update_Focus_Field_For_Operation MODE_FINDING
12715>>>>>            
12715>>>>>        If (bOpOk) Begin
12717>>>>>            Get Data_Set iFile to hoDD
12718>>>>>            If hoDD Begin
12720>>>>>                Send OnPreFind of hoDD DDFindFindByRowRec
12721>>>>>            End
12721>>>>>>
12721>>>>>        End
12721>>>>>>
12721>>>>>            
12721>>>>>        Forward Send FindByRowId iFile riRowId
12723>>>>>            
12723>>>>>        If (bOpOk) Begin
12725>>>>>            If (hoDD) Begin
12727>>>>>                Move (Found) to bFound
12728>>>>>                Send OnPostFind of hoDD DDFindFindByRowRec bFound 
12729>>>>>                Move bFound to Found
12730>>>>>            End
12730>>>>>>
12730>>>>>        End
12730>>>>>>
12730>>>>>    End_Procedure
12731>>>>>    
12731>>>>>    Procedure Request_Find Integer eFindMode Integer iFile Integer iIndex
12733>>>>>         Handle hoDD
12733>>>>>         Boolean bFound
12733>>>>>         Boolean bOpOk
12733>>>>>         Move (OPERATION_MODE=MODE_WAITING or OPERATION_MODE=MODE_VALIDATING) to bOpOk
12734>>>>>         If (OPERATION_MODE=MODE_WAITING) Begin
12736>>>>>            Send Update_Focus_Field_For_Operation MODE_FINDING
12737>>>>>         End
12737>>>>>>
12737>>>>>            
12737>>>>>         If (bOpOk) Begin
12739>>>>>            Get Data_Set iFile to hoDD
12740>>>>>            If hoDD Begin
12742>>>>>                Send OnPreFind of hoDD DDFindRequestFind
12743>>>>>            End
12743>>>>>>
12743>>>>>         End
12743>>>>>>
12743>>>>>            
12743>>>>>         Forward Send Request_Find eFindMode iFile iIndex
12745>>>>>            
12745>>>>>         If (bOpOk) Begin
12747>>>>>            If (hoDD) Begin
12749>>>>>                Move (Found) to bFound
12750>>>>>                Send OnPostFind of hoDD DDFindRequestFind bFound 
12751>>>>>                Move bFound to Found
12752>>>>>            End
12752>>>>>>
12752>>>>>         End
12752>>>>>>
12752>>>>>    End_Procedure
12753>>>>>    
12753>>>>>    Procedure OnPreFind Integer eMessage
12755>>>>>    End_procedure
12756>>>>>    
12756>>>>>    Procedure OnPostFind Integer eMessage Boolean bFound
12758>>>>>    End_Procedure
12759>>>>>
12759>>>>>    
12759>>>>>    
12759>>>>>    Procedure Request_Superfind Integer eFindMode Integer iFile Integer iField
12761>>>>>         Boolean bInSuperFind
12761>>>>>         // we need to set pbInSuperFind so Entry_update in the DEOs will know that
12761>>>>>         // they should perform an entry_update. Superfind entry_updates have never gone through
12761>>>>>         // the DD's field buffer.
12761>>>>>         Get pbInSuperFind to bInSuperFind
12762>>>>>         Set pbInSuperFind to True
12763>>>>>         If (OPERATION_MODE=MODE_WAITING) Begin
12765>>>>>            Send Update_Focus_Field_For_Operation MODE_FINDING
12766>>>>>         End
12766>>>>>>
12766>>>>>         Forward Send Request_Superfind eFindMode iFile iField
12768>>>>>         Set pbInSuperFind to bInSuperFind
12769>>>>>    End_Procedure
12770>>>>>    
12770>>>>>    // Augmented to return true if a non-constrained parent DD has a change. This way
12770>>>>>    // Should_Save_row only filters changes in a consrained parent.
12770>>>>>
12770>>>>>    Function Should_Save_Row Returns Boolean
12772>>>>>        Boolean bShouldSaveRow bShouldSave bRelatesToConstraint
12772>>>>>        Integer iServers iServer iServerFile
12772>>>>>        Handle hoServerDD
12772>>>>>        Forward Get Should_Save_Row to bShouldSaveRow // will be true if this DD is changed or has a changed parent.
12774>>>>>        Get Should_Save to bShouldSave // will be true if there is a change anywhere up the entire save structure
12775>>>>>        If (not(bShouldSaveRow) and bShouldSave) Begin
12777>>>>>            // If here we have a changed in an server but not the this DD. We need a further refinement. If the server
12777>>>>>            // change is in a constrained server, we don't consider this a change because you can switch rows without losing
12777>>>>>            // data (with RT changes made for 17.0).
12777>>>>>            Get Data_Set_Server_Count to iServers
12778>>>>>            For iServer from 0 to (iServers-1)
12784>>>>>>
12784>>>>>                Get Data_Set_Server iServer to hoServerDD
12785>>>>>                Get Should_Save of hoServerDD to bShouldSave
12786>>>>>                If bShouldSave Begin
12788>>>>>                    Get Main_File of hoServerDD to iServerFile
12789>>>>>                    Get IsRelatesToConstrained iServerFile to bRelatesToConstraint
12790>>>>>                    If not bRelatesToConstraint Begin
12792>>>>>                        Function_Return True
12793>>>>>                    End
12793>>>>>>
12793>>>>>                End
12793>>>>>>
12793>>>>>            Loop
12794>>>>>>
12794>>>>>        End
12794>>>>>>
12794>>>>>        Function_Return bShouldSaveRow
12795>>>>>    End_Function
12796>>>>>
12796>>>>>    // returns true if any relates-to constraining server needs a save. Normally there will be
12796>>>>>    // one or zero related-to parents. If Should_Save_Row returns false it is possible that there
12796>>>>>    // is a change up the relates-to constrained branch. If so, this will return True. This can be
12796>>>>>    // used to better determine the changed status of your DDO sructure
12796>>>>>    Function ShouldSaveConstrainedToServer Returns Boolean
12798>>>>>        Boolean bShouldSave bRelatesToConstraint
12798>>>>>        Integer iServers iServer iServerFile
12798>>>>>        Handle hoServerDD
12798>>>>>        Get Data_Set_Server_Count to iServers
12799>>>>>        For iServer from 0 to (iServers-1)
12805>>>>>>
12805>>>>>            Get Data_Set_Server iServer to hoServerDD
12806>>>>>            Get Main_File of hoServerDD to iServerFile
12807>>>>>            Get IsRelatesToConstrained iServerFile to bRelatesToConstraint
12808>>>>>            If bRelatesToConstraint Begin
12810>>>>>                Get Should_Save of hoServerDD to bShouldSave
12811>>>>>                If bShouldSave Begin
12813>>>>>                    Function_Return True
12814>>>>>                End
12814>>>>>>
12814>>>>>            End
12814>>>>>>
12814>>>>>        Loop
12815>>>>>>
12815>>>>>        Function_Return False
12816>>>>>    End_Function
12817>>>>>    
12817>>>>>    Function FindServerInformationElement Integer iFile Returns Integer         
12819>>>>>        tDDServerInformation[] ServerInformation
12819>>>>>        tDDServerInformation[] ServerInformation
12820>>>>>        Integer iIndex
12820>>>>>        Get pServerInformation to ServerInformation
12821>>>>>        For iIndex from 0 to (SizeOfArray(ServerInformation)-1)
12827>>>>>>
12827>>>>>            If (iFile=ServerInformation[iIndex].iParent) Begin
12829>>>>>                Function_Return iIndex
12830>>>>>            End
12830>>>>>>
12830>>>>>        Loop
12831>>>>>>
12831>>>>>        Function_Return -1
12832>>>>>    End_Function
12833>>>>>    
12833>>>>>    Procedure AddServerData Integer iFile Integer eParam Boolean bValue
12835>>>>>        tDDServerInformation[] ServerInformation
12835>>>>>        tDDServerInformation[] ServerInformation
12836>>>>>        Integer iIndex
12836>>>>>        Get pServerInformation to ServerInformation
12837>>>>>        Get FindServerInformationElement iFile to iIndex
12838>>>>>        If (iIndex=-1) Begin
12840>>>>>            Move (SizeOfArray(ServerInformation)) to iIndex
12841>>>>>            Move iFile to ServerInformation[iIndex].iParent
12842>>>>>            Move False to ServerInformation[iIndex].bParentNoSwitchIfCommitted
12843>>>>>            Move False to ServerInformation[iIndex].bAllowNullParent
12844>>>>>        End
12844>>>>>>
12844>>>>>        If (eParam=0) Begin
12846>>>>>            Move bValue to ServerInformation[iIndex].bAllowNullParent
12847>>>>>        End
12847>>>>>>
12847>>>>>        Else Begin
12848>>>>>            Move bValue to ServerInformation[iIndex].bParentNoSwitchIfCommitted
12849>>>>>        End
12849>>>>>>
12849>>>>>        Set pServerInformation to ServerInformation
12850>>>>>    End_Procedure
12851>>>>>    
12851>>>>>    Function GetServerData Integer iFile Integer eParam Returns Boolean
12853>>>>>        Boolean bValue
12853>>>>>        tDDServerInformation[] ServerInformation
12853>>>>>        tDDServerInformation[] ServerInformation
12854>>>>>        Integer iIndex
12854>>>>>        Get pServerInformation to ServerInformation
12855>>>>>        Get FindServerInformationElement iFile to iIndex
12856>>>>>        If (iIndex<>-1) Begin
12858>>>>>            If (eParam=0) Begin
12860>>>>>                Move ServerInformation[iIndex].bAllowNullParent to bValue
12861>>>>>            End
12861>>>>>>
12861>>>>>            Else Begin
12862>>>>>                Move ServerInformation[iIndex].bParentNoSwitchIfCommitted to bValue
12863>>>>>            End
12863>>>>>>
12863>>>>>        End
12863>>>>>>
12863>>>>>        Function_Return bValue
12864>>>>>    End_Function
12865>>>>>    
12865>>>>>    
12865>>>>>    // Used to add a null parent to the list of parents that allow this
12865>>>>>    Procedure Set ParentNullAllowed Integer iParent Boolean bAllowed
12867>>>>>        Send AddServerData iParent 0 bAllowed    
12868>>>>>    End_Procedure
12869>>>>>    
12869>>>>>    // returns true if null parent allowed for this parent file
12869>>>>>    Function ParentNullAllowed Integer iParent Returns Boolean
12871>>>>>        Boolean bValue
12871>>>>>        Get GetServerData iParent 0 to bValue
12872>>>>>        Function_Return bValue
12873>>>>>    End_Function
12874>>>>>
12874>>>>>    // returns true if null parent allowed for this parent file. This is the function
12874>>>>>    // that can be used for augmentation. This is the methid that is called by the runtime
12874>>>>>    // to determine if a null parent is allowed
12874>>>>>    Function IsNullParentAllowed Integer iServer Returns Boolean
12876>>>>>        Boolean bAllowed
12876>>>>>        Get ParentNullAllowed iServer to bAllowed
12877>>>>>        Function_Return bAllowed
12878>>>>>    End_Function
12879>>>>>
12879>>>>>    Procedure Set ParentNoSwitchIfCommitted Integer iParent Boolean bAllowed
12881>>>>>        Send AddServerData iParent 1 bAllowed    
12882>>>>>    End_Procedure
12883>>>>>
12883>>>>>    Function ParentNoSwitchIfCommitted Integer iParent Returns Boolean
12885>>>>>        Boolean bValue
12885>>>>>        Get GetServerData iParent 1 to bValue
12886>>>>>        Function_Return bValue
12887>>>>>    End_Function
12888>>>>>
12888>>>>>    // return an array with the server path from this DD to passed top. The top will be
12888>>>>>    // in 0 and its child in 1, grand-child in 2, etc. If empty, no path was found. To start
12888>>>>>    // this process the byref hoDDs array MUST be empty
12888>>>>>    Procedure DDOServerPath Handle hoTop Handle[] ByRef hoDDs
12890>>>>>        Handle hoServer
12890>>>>>        Integer iServers iServer
12890>>>>>        If (hoTop=Self) Begin
12892>>>>>            Move Self to hoDDs[SizeOfArray(hoDDs)]
12893>>>>>            Procedure_Return
12894>>>>>        End
12894>>>>>>
12894>>>>>        Get Data_Set_Server_Count to iServers
12895>>>>>        For iServer from 0 to (iServers-1)
12901>>>>>>
12901>>>>>            Get Data_Set_Server iServer to hoServer
12902>>>>>            Send DDOServerPath of hoServer hoTop (&hoDDs)
12903>>>>>            If (SizeOfArray(hoDDs)) Begin
12905>>>>>                Move Self to hoDDs[SizeOfArray(hoDDs)]
12906>>>>>                Procedure_Return
12907>>>>>            End
12907>>>>>>
12907>>>>>        Loop
12908>>>>>>
12908>>>>>    End_Procedure
12909>>>>>    
12909>>>>>    // returns True if the value passed can be considered empty for this field.
12909>>>>>    Function IsEmptyField Integer iField String sValue Returns Boolean
12911>>>>>        Integer iFile iDataType iValidationType
12911>>>>>        Number nNum
12911>>>>>        Boolean bInvalid bChecked
12911>>>>>        Get Main_File to iFile
12912>>>>>        Get_Attribute DF_FIELD_TYPE of iFile iField to iDataType
12915>>>>>        Get IsDataInvalid iDataType sValue to bInvalid
12916>>>>>        If bInvalid Begin
12918>>>>>            Function_Return True
12919>>>>>        End
12919>>>>>>
12919>>>>>        
12919>>>>>        // DDs set checkbox fields to the False value as default. We must test its select_state
12919>>>>>        Get Field_Validation_Type of (Field_Attributes(Self)) iField to iValidationType
12920>>>>>        If (iValidationType=FA_VALIDATION_TYPE_CHECKBOX) Begin
12922>>>>>            Get Field_Select_State iField to bChecked
12923>>>>>            If not bChecked Begin
12925>>>>>                Function_Return True
12926>>>>>            End
12926>>>>>>
12926>>>>>        End
12926>>>>>>
12926>>>>>        
12926>>>>>        If ((iDataType=DF_BCD or iDataType=DF_DATE) and (Number(sValue)=0)) Begin
12928>>>>>             Move "" to sValue
12929>>>>>        End
12929>>>>>>
12929>>>>>        Else If (iDataType=DF_DATETIME and IsNullDateTime(cast(sValue,DateTime))) Begin
12932>>>>>             Move "" to sValue
12933>>>>>        End
12933>>>>>>
12933>>>>>        Function_Return (sValue="")
12934>>>>>    End_Function
12935>>>>>    
12935>>>>>
12935>>>>>    // is the record committed
12935>>>>>    Function IsCommitted Returns Boolean
12937>>>>>        Boolean bHasRecord
12937>>>>>        Get HasRecord to bHasRecord
12938>>>>>        Function_Return bHasRecord
12939>>>>>    End_Function
12940>>>>>    
12940>>>>>    // is the field committed. It assumes the record is already committed
12940>>>>>    Function IsFieldCommitted Integer iField Returns Boolean
12942>>>>>        Boolean bIsCommitted
12942>>>>>        Get Field_Option iField DD_COMMIT to bIsCommitted
12943>>>>>        Function_Return bIsCommitted
12944>>>>>    End_Function
12945>>>>>    
12945>>>>>    // is a parent change allowed for this parent server.
12945>>>>>    Function IsCommittedParentChangeAllowed Integer iServer Returns Boolean
12947>>>>>        Boolean bNoSwitch
12947>>>>>        Get ParentNoSwitchIfCommitted iServer to bNoSwitch
12948>>>>>        Function_Return (not(bNoSwitch))
12949>>>>>    End_Function
12950>>>>>    
12950>>>>>    // Are we allowed to find with this file when it is used as a parent?
12950>>>>>    // Check all child DDOs and see if any are committed and do not allow switching parents when committed.
12950>>>>>    //  The rules for each child are switching is ok If:
12950>>>>>    // 1. the child is not committed,
12950>>>>>    // 2. it has a relates-to constraint (Find will change child which is ok)
12950>>>>>    // 3. if IsCommittedParentChangeAllowed allowed.
12950>>>>>    //
12950>>>>>    Function AllowParentFind Returns Boolean
12952>>>>>        Integer iClients iClient iMain
12952>>>>>        Handle hoChild     
12952>>>>>        Boolean bIsCommitted   
12952>>>>>        Get Data_Set_Client_Count to iClients
12953>>>>>        For iClient from 0 to (iClients-1)
12959>>>>>>
12959>>>>>            Get Data_Set_Client iClient to hoChild
12960>>>>>            Get IsCommitted of hoChild to bIsCommitted
12961>>>>>            If bIsCommitted Begin
12963>>>>>                Get Main_File to iMain
12964>>>>>                Get IsRelatesToConstrained of hoChild iMain to bIsCommitted
12965>>>>>                If not bIsCommitted Begin
12967>>>>>                    Get IsCommittedParentChangeAllowed of hoChild iMain to bIsCommitted
12968>>>>>                    If (not(bIsCommitted)) Begin
12970>>>>>                       Function_Return False
12971>>>>>                    End
12971>>>>>>
12971>>>>>                End
12971>>>>>>
12971>>>>>            End
12971>>>>>>
12971>>>>>        End
12972>>>>>>
12972>>>>>        Function_Return True
12973>>>>>    End_Function
12974>>>>>    
12974>>>>>    // aumgented to do nothing if there is no index (instead of annoying error message) and
12974>>>>>    // to do nothing if a find is not allowed because it is a no switch parent of a committed child.
12974>>>>>    Procedure Item_Find Integer eFindMode ;            Integer iFile Integer iField ;            Integer bDoEntryUpdate Integer bShowFindErr Integer bDeferred
12976>>>>>    
12976>>>>>        Integer iIndex iMain
12976>>>>>        Handle  hoOwner
12976>>>>>        Boolean bOk
12976>>>>>        
12976>>>>>        Get File_Field_Index iFile iField to iIndex
12977>>>>>        If (iIndex=-1)  Begin
12979>>>>>            Procedure_Return
12980>>>>>        End
12980>>>>>>
12980>>>>>        Get Main_File to iMain
12981>>>>>        If (iMain<>iFile) Begin
12983>>>>>            Get Which_Data_Set iFile to hoOwner
12984>>>>>            If hoOwner Begin
12986>>>>>                Get AllowParentFind of hoOwner to bOk
12987>>>>>                If not bOk Begin
12989>>>>>                    Procedure_Return
12990>>>>>                End
12990>>>>>>
12990>>>>>            End
12990>>>>>>
12990>>>>>        End
12990>>>>>>
12990>>>>>        
12990>>>>>        If not bDeferred Begin
12992>>>>>            Send Refind_Records // make sure the buffers are correct before the find
12993>>>>>        End
12993>>>>>>
12993>>>>>        
12993>>>>>        Forward Send Item_Find eFindMode iFile iField bDoEntryUpdate bShowFindErr bDeferred
12995>>>>>    End_Procedure
12996>>>>>    
12996>>>>>    
12996>>>>>    
12996>>>>>    // Return the committed options for this field based on the committed status or this record,
12996>>>>>    // the committed status of the field and whether, if committed, it should be noput or noput+noenter
12996>>>>>    Function File_Field_Committed_Options Integer iFile Integer iField Returns Integer
12998>>>>>        Boolean bIsCommitted
12998>>>>>        Integer iNewOpts iIndex
12998>>>>>        Handle hoOwner
12998>>>>>        
12998>>>>>        Get Which_Data_Set iFile to hoOwner
12999>>>>>        If not hoOwner Function_Return 0
13002>>>>>        
13002>>>>>        Get File_Field_Index iFile iField to iIndex
13003>>>>>        Get IsCommitted of hoOwner iField to bIsCommitted
13004>>>>>        If bIsCommitted Begin
13006>>>>>            Get IsFieldCommitted of hoOwner iField to bIsCommitted
13007>>>>>            If bIsCommitted Begin
13009>>>>>                // if committed, it is noput and, if non-indexed, also noenter
13009>>>>>                Move (If(iIndex=-1,DD_DISPLAYONLY,DD_NOPUT)) to iNewOpts
13010>>>>>            End
13010>>>>>>
13010>>>>>        End
13010>>>>>>
13010>>>>>        // if a finding parent field, we want to know if you are allowed to switch parents as we will assume
13010>>>>>        // that this field is used for finding.        
13010>>>>>        If (hoOwner<>Self and iIndex>-1) Begin
13012>>>>>            Get AllowParentFind of hoOwner to bIsCommitted
13013>>>>>            If not bIsCommitted Begin
13015>>>>>               Move DD_DISPLAYONLY to iNewOpts
13016>>>>>            End
13016>>>>>>
13016>>>>>        End
13016>>>>>>
13016>>>>>    
13016>>>>>        Function_Return iNewOpts
13017>>>>>    End_Function
13018>>>>>    
13018>>>>>    // Returns the current field-field options based on regular options, foreign field status
13018>>>>>    // plus committed record status
13018>>>>>    Function File_Field_DynamicEntryOptions Integer iFile Integer iField Returns Integer
13020>>>>>        Integer iCOpts iFOpts
13020>>>>>        If (iFile=0) Begin
13022>>>>>            Function_Return 0
13023>>>>>        End
13023>>>>>>
13023>>>>>        Get File_Field_Options iFile iField to iFOpts            // regular options (handles regular and foreign)
13024>>>>>        Get File_Field_Committed_Options iFile iField to iCOpts  // possible NoPut, NoEnter additions
13025>>>>>        Function_Return (iFOpts ior iCOpts)
13026>>>>>    End_Function
13027>>>>>    
13027>>>>>    Function DDRememberedFieldIndex Integer iField Returns Integer
13029>>>>>        tDDRemembered[] DefaultValues
13029>>>>>        tDDRemembered[] DefaultValues
13030>>>>>        tDDRemembered SearchItem
13030>>>>>        tDDRemembered SearchItem
13030>>>>>        Integer iIndex
13030>>>>>        Get pDDDefaults to DefaultValues
13031>>>>>        Move iField to SearchItem.iField
13032>>>>>        Move (SearchArray(SearchItem,DefaultValues,Desktop,RefFunc(CompareDDDefault_Field))) to iIndex
13033>>>>>        Function_Return iIndex
13034>>>>>    End_Function
13035>>>>>    
13035>>>>>    // Interface used to set or clear a dynamic default (remembered) value for a DD field. If the
13035>>>>>    // value passed is empty ("" or as empty as defined by the data-type) it is cleared. If the value
13035>>>>>    // is DD_RememberLast, it will use the last value before a clear as the default, else it uses the
13035>>>>>    // passed value as the default
13035>>>>>    Procedure Set Field_RememberedValue Integer iField String sValue
13037>>>>>        tDDRemembered[] DefaultValues
13037>>>>>        tDDRemembered[] DefaultValues
13038>>>>>        Integer iIndex
13038>>>>>        Boolean bNull 
13038>>>>>        Get DDRememberedFieldIndex iField to iIndex
13039>>>>>        Get pDDDefaults to DefaultValues
13040>>>>>        If (sValue<>DD_RememberLast) Begin // if it is rememberlast, we know it is not null
13042>>>>>            Get IsEmptyField iField sValue to bNull
13043>>>>>        End
13043>>>>>>
13043>>>>>        If (not(bNull)) Begin
13045>>>>>            If (iIndex=-1) Begin
13047>>>>>                Move (SizeOfArray(DefaultValues)) to iIndex
13048>>>>>                Move iField to DefaultValues[iIndex].iField
13049>>>>>            End
13049>>>>>>
13049>>>>>            Move sValue to DefaultValues[iIndex].sDefault
13050>>>>>            Set pDDDefaults to DefaultValues
13051>>>>>        End
13051>>>>>>
13051>>>>>        Else If  (iIndex<>-1) Begin
13054>>>>>            Set pDDDefaults to (RemoveFromArray(DefaultValues,iIndex))
13055>>>>>        End
13055>>>>>>
13055>>>>>    End_Procedure
13056>>>>>    
13056>>>>>    // get the remembered value as per rules above
13056>>>>>    Function Field_RememberedValue Integer iField Returns String
13058>>>>>        tDDRemembered[] DefaultValues
13058>>>>>        tDDRemembered[] DefaultValues
13059>>>>>        Integer iIndex
13059>>>>>        Get DDRememberedFieldIndex iField to iIndex
13060>>>>>        If (iIndex<>-1) Begin
13062>>>>>            Get pDDDefaults to DefaultValues
13063>>>>>            Function_Return DefaultValues[iIndex].sDefault
13064>>>>>        End
13064>>>>>>
13064>>>>>        Function_Return ''
13065>>>>>    End_Function
13066>>>>>    
13066>>>>>    Procedure AssignDynamicDefaults
13068>>>>>        Integer iField iFields iFile
13068>>>>>        tDDRemembered[] DefaultValues
13068>>>>>        tDDRemembered[] DefaultValues
13069>>>>>        Boolean bMain
13069>>>>>        String sValue
13069>>>>>        
13069>>>>>        Get Main_File to iFile
13070>>>>>        Get pDDDefaults to DefaultValues
13071>>>>>        Move (SizeOfArray(DefaultValues)) to iFields
13072>>>>>        For iField from 0 to (iFields-1)
13078>>>>>>
13078>>>>>            If ( DefaultValues[iField].sDefault<>"") Begin
13080>>>>>               If (DefaultValues[iField].sDefault=DD_RememberLast) Begin
13082>>>>>                    Move DefaultValues[iField].sLastValue to sValue                 
13083>>>>>               End
13083>>>>>>
13083>>>>>               Else Begin
13084>>>>>                    Move DefaultValues[iField].sDefault to sValue                 
13085>>>>>               End
13085>>>>>>
13085>>>>>               Set Field_Changed_Value DefaultValues[iField].iField to sValue
13086>>>>>            End
13086>>>>>>
13086>>>>>        Loop
13087>>>>>>
13087>>>>>    End_Procedure
13088>>>>>    
13088>>>>>    // Clears all remembered defaults for this DD.
13088>>>>>    Procedure ClearRememberedDefaults
13090>>>>>        tDDRemembered[] DefaultValues
13090>>>>>        tDDRemembered[] DefaultValues
13091>>>>>        Set pDDDefaults to DefaultValues
13092>>>>>    End_Procedure
13093>>>>>
13093>>>>>    Procedure PrivateClearAllRememberedDefaults
13095>>>>>        Integer iCount iMax
13095>>>>>        Handle hoDD
13095>>>>>        Boolean bVisisted
13095>>>>>        
13095>>>>>        Set Visited_State to True
13096>>>>>        
13096>>>>>        Get Data_Set_Server_Count to iMax
13097>>>>>        Decrement iMax
13098>>>>>        For iCount from 0 to iMax
13104>>>>>>
13104>>>>>            Get Data_Set_Server iCount to hoDD
13105>>>>>            Get Visited_State of hoDD to bVisisted
13106>>>>>            If not (bVisisted) Begin
13108>>>>>                Send PrivateClearAllRememberedDefaults of hoDD
13109>>>>>            End
13109>>>>>>
13109>>>>>        Loop
13110>>>>>>
13110>>>>>        
13110>>>>>        Send ClearRememberedDefaults
13111>>>>>        
13111>>>>>        Get Data_Set_Client_Count to iMax
13112>>>>>        Decrement iMax
13113>>>>>        For iCount from 0 to iMax
13119>>>>>>
13119>>>>>            Get Data_Set_Client iCount to hoDD
13120>>>>>            Get Visited_State of hoDD to bVisisted
13121>>>>>            If not (bVisisted) Begin
13123>>>>>                Send PrivateClearAllRememberedDefaults of hoDD
13124>>>>>        End
13124>>>>>>
13124>>>>>        Loop
13125>>>>>>
13125>>>>>    
13125>>>>>    End_Procedure 
13126>>>>>
13126>>>>>    // Clears all remembered defaults for all DDs in this structure.
13126>>>>>    Procedure ClearAllRememberedDefaults
13128>>>>>        Send Initialize_Visited True False // False=don't clear field marks
13129>>>>>        Send PrivateClearAllRememberedDefaults
13130>>>>>    End_Function
13131>>>>>    
13131>>>>>    // This is called after a clear or clear all is sent to this DD. It does autofinds as needed
13131>>>>>    // for any parent DDs. It does this if the parent is not a relates to contraining parent, if
13131>>>>>    // a field has an index, it has a changed value and it is autofind or autofind_ge.
13131>>>>>    Procedure DefaultParentAutofinds
13133>>>>>        Integer i iServers iField iFields iFile iIndex iOpts
13133>>>>>        Boolean bDoAutoFind bRelates bIsEmptyField
13133>>>>>        String sValue
13133>>>>>        Handle hoServer
13133>>>>>        Get Data_Set_Server_Count to iServers
13134>>>>>        For i from 0 to (iServers-1)
13140>>>>>>
13140>>>>>            Get Data_Set_Server i to hoServer
13141>>>>>            Get IsRelatesToConstrained hoServer to bRelates
13142>>>>>            // never autofind on a relates-to constraining parent
13142>>>>>            If not (bRelates) Begin
13144>>>>>
13144>>>>>                Get Field_Count of hoServer to iFields
13145>>>>>                Get Main_File of hoServer to iFile
13146>>>>>                Move False to bDoAutoFind
13147>>>>>                Move 1 to iField
13148>>>>>                While (not(bDoAutoFind) and (iField<=iFields))
13152>>>>>                    Get_Attribute DF_FIELD_INDEX of iFile iField to iIndex
13155>>>>>                    If (iIndex>0) Begin
13157>>>>>                        Get Field_Changed_State of hoServer iField to bDoAutoFind
13158>>>>>                        If bDoAutoFind Begin
13160>>>>>                            Get Field_Current_Value of hoServer iField to sValue
13161>>>>>                            Get IsEmptyField of hoServer iField sValue to bIsEmptyField
13162>>>>>                            Move (not(bIsEmptyField)) to bDoAutoFind
13163>>>>>                            If bDoAutoFind Begin
13165>>>>>                                Get File_Field_Options iFile iField to iOpts
13166>>>>>                                // if this is a retain or retainall we don't do this because we want
13166>>>>>                                // to maintain backwards compatibility
13166>>>>>                                Move ( (iOpts iand DD_AUTOFIND or iOpts iand DD_AUTOFIND_GE) and ;                                        not( iOpts iand DD_RETAIN or iOpts iand DD_RETAINALL) ) to bDoAutoFind
13167>>>>>                                If bDoAutoFind Begin
13169>>>>>                                    Send File_Field_Default_AutoFind iFile iField
13170>>>>>                                    Set Changed_State to False // clears parent changed state
13171>>>>>                                End
13171>>>>>>
13171>>>>>                            End
13171>>>>>>
13171>>>>>                        End
13171>>>>>>
13171>>>>>                    End
13171>>>>>>
13171>>>>>                    Increment iField
13172>>>>>                Loop
13173>>>>>>
13173>>>>>                
13173>>>>>                // Only check for grandparent autofinds if this parent did not do a an autofind
13173>>>>>                // Doing an autofind on an autofind parent's parent is just too confusing
13173>>>>>                If not bDoAutoFind Begin
13175>>>>>                    Send DefaultParentAutofinds of hoServer
13176>>>>>                End
13176>>>>>>
13176>>>>>            End
13176>>>>>>
13176>>>>>        Loop
13177>>>>>>
13177>>>>>    End_Procedure
13178>>>>>    
13178>>>>>    // Set this DD to be an alias, passing the file number of the alias
13178>>>>>    // This can only be called once per instance and the Main_File must already have been set
13178>>>>>    // most likely in a superclass.
13178>>>>>    // This sets Main_File to the alias, stores the original master file (accessed via MasterForAlias).
13178>>>>>    // It also clears all existing relatonships. Normally we expect the alias class to set
13178>>>>>    // sets pbUseDDRelates and pbNoCascadeDeleteStrict to true. We don't do that automatically so that
13178>>>>>    // the Studio's property panel will show the correct values. When an alias is defined using the
13178>>>>>    // studio it will set these two properties.
13178>>>>>    // This means you must set any required relationships yourself
13178>>>>>    Procedure Set Alias_File Integer iTable
13180>>>>>        Integer iMain iMaster iFieldsM iFieldsA
13180>>>>>        Get Main_File to iMain
13181>>>>>        Get MasterForAlias to iMaster
13182>>>>>        
13182>>>>>        If (iTable=0 and iMaster) Begin
13184>>>>>            Error DFERR_PROGRAM "Cannot unset alias table"
13185>>>>>>
13185>>>>>            Procedure_Return
13186>>>>>        End
13186>>>>>>
13186>>>>>        If (iTable=iMain) Begin
13188>>>>>            Error DFERR_PROGRAM "Cannot set alias table to self"
13189>>>>>>
13189>>>>>            Procedure_Return
13190>>>>>        End
13190>>>>>>
13190>>>>>        If (iMaster) Begin
13192>>>>>            Error DFERR_PROGRAM "Cannot redefine alias table"
13193>>>>>>
13193>>>>>            Procedure_Return
13194>>>>>        End
13194>>>>>>
13194>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of iMain to iFieldsM
13197>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of iTable to iFieldsA
13200>>>>>        If (iFieldsA<>iFieldsM) Begin
13202>>>>>            Error DFERR_PROGRAM "Alias and Master file are not based on the same table"
13203>>>>>>
13203>>>>>            Procedure_Return
13204>>>>>        End
13204>>>>>>
13204>>>>>
13204>>>>>        Set piMasterTable to iMain 
13205>>>>>        Set Main_File to iTable
13206>>>>>        Send DefineAsAlias
13207>>>>>    End_Procedure
13208>>>>>    
13208>>>>>    Procedure DefineAsAlias
13210>>>>>        Integer i iFile
13210>>>>>        
13210>>>>>        // We expect he developer to set these properties to True
13210>>>>>        //Set pbUseDDRelates to True
13210>>>>>        //Set pbNoCascadeDeleteStrict to True
13210>>>>>        
13210>>>>>        Send ClearDDRelates
13211>>>>>        Get Client_File_Count to i
13212>>>>>        While i
13216>>>>>            Decrement i
13217>>>>>            Get Client_File i to iFile
13218>>>>>            Send Remove_Client_File iFile
13219>>>>>        Loop
13220>>>>>>
13220>>>>>        Get Server_File_Count to i
13221>>>>>        While i
13225>>>>>            Decrement i
13226>>>>>            Get Server_File i to iFile
13227>>>>>            Send Remove_Server_File iFile
13228>>>>>        Loop
13229>>>>>>
13229>>>>>    End_Procedure
13230>>>>>
13230>>>>>    Function MasterForAlias Returns Integer
13232>>>>>        Integer iMaster
13232>>>>>        Get piMasterTable to iMaster
13233>>>>>        Function_Return iMaster
13234>>>>>    End_Function
13235>>>>>    
13235>>>>>    Function IsAlias Returns Boolean
13237>>>>>        Integer iMaster
13237>>>>>        Get piMasterTable to iMaster
13238>>>>>        Function_Return (iMaster<>0)
13239>>>>>    End_Function
13240>>>>>    
13240>>>>>    
13240>>>>>//    Procedure ClearMasterRelationships 
13240>>>>>//        Integer iCount iFields iMain
13240>>>>>//        tRelationship[] MasterRelationships
13240>>>>>//        tRelationship Relationship
13240>>>>>//        Get Main_File to iMain
13240>>>>>//        Get Field_Count to iFields
13240>>>>>//        For i from 0 to iFields
13240>>>>>//            Get_Attribute DF_FIELD_RELATED_FILE of iMain i to Relationship.iParentFile
13240>>>>>//            If iRelFile Begin
13240>>>>>//                Get_Attribute DF_FIELD_RELATED_FIELD of iMaster i to Relationship.iParentField
13240>>>>>//                Move i to MasterRelationships[iCount].iChildField
13240>>>>>//                Set_Attribute DF_FIELD_RELATED_FILE of iMaster i to 0
13240>>>>>//                Set_Attribute DF_FIELD_RELATED_FIELD of iMaster i to 0
13240>>>>>//                Increment iCount
13240>>>>>//            End
13240>>>>>//        Loop
13240>>>>>//        Set pMasterRelatonships to MasterRelationships
13240>>>>>//    End_Procedure
13240>>>>>//    
13240>>>>>//    Procedure DefineAliasRelationship Integer iMasterParent Integer iAliasParent
13240>>>>>//        Integer i iRels iMain
13240>>>>>//        tRelationship[] MasterRelationships
13240>>>>>//        Get pMasterRelatonships to MasterRelationships
13240>>>>>//        Get Main_File to iMain
13240>>>>>//        Move (SizeOfArray(MasterRelationships)) to iRels
13240>>>>>//        For i from 0 to (iRels-1)
13240>>>>>//            If (MasterRelationships[i].iParentFile=iMasterParent) Begin
13240>>>>>//                Set_Attribute DF_FIELD_RELATED_FILE  of iMain i to iAliasParent
13240>>>>>//                Set_Attribute DF_FIELD_RELATED_FIELD of iMain i to MasterRelationships[i].iParentField
13240>>>>>//            End
13240>>>>>//        Loop
13240>>>>>//    End_Procedure
13240>>>>>//
13240>>>>>////    Procedure RestoreMasterRelationship Integer iMasterParent
13240>>>>>////        Integer i iRels iMain
13240>>>>>////        tRelationship[] MasterRelationships
13240>>>>>////        Get pMasterRelatonships to MasterRelationships
13240>>>>>////        Get Main_File to iMain
13240>>>>>////        Move (SizeOfArray(MasterRelationships)) to iRels
13240>>>>>////        For i from 0 to (iRels-1)
13240>>>>>////            Set_Attribute DF_FIELD_RELATED_FILE  of iMain i to MasterRelationships[i].iParentFile
13240>>>>>////            Set_Attribute DF_FIELD_RELATED_FIELD of iMain i to MasterRelationships[i].iParentField
13240>>>>>////        Loop
13240>>>>>////    End_Procedure
13240>>>>>
13240>>>>>    Procedure OnSaveRecord
13242>>>>>    End_Procedure
13243>>>>>    
13243>>>>>  // this tells the DD that this field's Field_Changed_State is being applied to a noput field
13243>>>>>  // and should not be used in a save. It is the responsibility of the DEO to send this or SetFileFieldNoPutOverride
13243>>>>>  Procedure SetNoPutOverride Integer iField
13245>>>>>      Send SetNoPutOverride of Record_Buffer iField  
13246>>>>>  End_Procedure
13247>>>>>
13247>>>>>  Procedure SetFileFieldNoPutOverride Integer iFile Integer iField
13249>>>>>      Handle hoDD
13249>>>>>      Get Data_Set iFile to hoDD
13250>>>>>      If hoDD Begin
13252>>>>>          Send SetNoPutOverride of hoDD iField  
13253>>>>>      End
13253>>>>>>
13253>>>>>  End_Procedure
13254>>>>>  
13254>>>>>    
13254>>>>>End_Class
13255>>>>>
13255>>>>>//************************************************************************//
13255>>>>>// This message will be send as a notification message from an            //
13255>>>>>// Extended_Data_Set whenever a fieldvalue has been changed.              //
13255>>>>>// It has been defined FOR cUIObject or Desktop  here so that attached    //
13255>>>>>// DEO which do not know anything about Extended_Data_Sets don't get      //
13255>>>>>// frustrated.                                                            //
13255>>>>>// All focusable objects and DEOs must understand this. This should be    //
13255>>>>>// changed at some point in the future.                                   //
13255>>>>>//************************************************************************//
13255>>>>>
13255>>>>>Function Extended_DEO_State for cUIObject Returns Integer
13257>>>>>End_function
13258>>>>>
13258>>>>>
13258>>>>>// this command is now obsolete. use Set Field_auto_increment
13258>>>
13258>>>Class cIterator is a cObject
13259>>>    Procedure construct_object 
13261>>>        Forward Send construct_object 
13263>>>    End_Procedure
13264>>>
13264>>>    Procedure InitialiseObject 
13266>>>    End_Procedure
13267>>>
13267>>>    Function NextItem Returns Boolean
13269>>>    End_Function 
13270>>>    
13270>>>    Function FirstItem Returns Boolean
13272>>>    End_Function 
13273>>>    
13273>>>    Function ItemValue Returns Variant
13275>>>    End_Function
13276>>>
13276>>>    Procedure Destroy_Object
13278>>>        Forward Send Destroy_Object 
13280>>>    End_Procedure
13281>>>End_Class
13282>>>
13282>>>Function CreateObject for cObject Integer hClass Variant v1 Variant v2 Variant v3 Variant v4 Returns Integer 
13284>>>    Integer hObj 
13284>>>    Integer iArgs 
13284>>>    Move Num_Arguments to iArgs 
13285>>>    
13285>>>    Move (Create(Self,hClass)) to hObj 
13286>>>
13286>>>    If (iArgs = 1) Send InitialiseObject to (hObj) 
13289>>>    If (iArgs = 2) Send InitialiseObject to (hObj) v1 
13292>>>    If (iArgs = 3) Send InitialiseObject to (hObj) v1 v2 
13295>>>    If (iArgs = 4) Send InitialiseObject to (hObj) v1 v2 v3 
13298>>>    If (iArgs = 5) Send InitialiseObject to (hObj) v1 v2 v3 v4 
13301>>>    
13301>>>    Function_Return hObj 
13302>>>End_Function
13303>>>
13303>>>
13303>>>
13303>>>
13303>>>Enum_List
13303>>>    Define rtAsRecnum
13303>>>    Define rtAsRowID
13303>>>End_Enum_List
13303>>>
13303>>>Class cDataDictionaryIterator is a cObject
13304>>>    Procedure construct_object 
13306>>>        Forward Send construct_object 
13308>>>        Property Integer phDD 
13309>>>        Property Integer piIndex
13310>>>    End_Procedure
13311>>>    
13311>>>    Procedure InitialiseObject Integer hDD Integer iIndex 
13313>>>        Set phDD to hDD 
13314>>>        Set piIndex to iIndex 
13315>>>    End_Procedure
13316>>>
13316>>>    Function NextItem Returns Boolean
13318>>>        Send Request_Find to (phDD(Self)) GT (Main_File(phDD(Self))) (piIndex(Self))
13319>>>        Function_Return (Found)
13320>>>    End_Function 
13321>>>    
13321>>>    Function FirstItem Returns Boolean
13323>>>        Send Request_Clear to (phDD(Self)) 
13324>>>        Send Request_Find to (phDD(Self)) GT (Main_File(phDD(Self))) (piIndex(Self))
13325>>>        Function_Return (Found)
13326>>>    End_Function 
13327>>>    
13327>>>    Function ItemValue Returns Variant
13329>>>        Function_Return (CurrentRowId(phDD(Self)))
13330>>>    End_Function
13331>>>
13331>>>End_Class
13332>>>
13332>>>Class cDataDictionaryRecnumIterator is a cDataDictionaryIterator
13333>>>    Function ItemValue Returns Variant
13335>>>        Function_Return (Current_Record(phDD(Self)))
13336>>>    End_Function
13337>>>End_Class
13338>>>
13338>>>
13338>>>Class cStringCharIterator is a cIterator
13339>>>    Procedure construct_object 
13341>>>        Forward Send Construct_Object
13343>>>        Property Char[] psOutput
13344>>>        Property Integer piPos
13345>>>    End_Procedure
13346>>>
13346>>>    Procedure InitialiseObject String sInp 
13348>>>        Char[] myCharArray
13349>>>        Address pStr
13349>>>        Integer iMax
13349>>>        
13349>>>        Move (Length(sInp)) to iMax
13350>>>        Move (ResizeArray(myCharArray,iMax+1)) to myCharArray
13351>>>        Move (AddressOf(myCharArray)) to pStr
13352>>>        Move sInp to pStr
13353>>>        Set psOutput to myCharArray
13354>>>    End_Procedure
13355>>>
13355>>>    Function NextItem Returns Boolean
13357>>>        Integer iLength 
13357>>>        Integer iPos 
13357>>>        
13357>>>        Get piPos to iPos 
13358>>>        Move (SizeOfArray(psOutput(Self))) to iLength 
13359>>>        
13359>>>        If (iPos>=(iLength-1)) Begin 
13361>>>            Function_Return (False) 
13362>>>        End
13362>>>>
13362>>>        Else Begin
13363>>>            Set piPos to (iPos+1) 
13364>>>            Function_Return (True) 
13365>>>        End 
13365>>>>
13365>>>    End_Function 
13366>>>    
13366>>>    Function FirstItem Returns Boolean
13368>>>        Set piPos to 1 
13369>>>        Function_Return ((SizeOfArray(psOutput(Self)))<>0)
13370>>>    End_Function 
13371>>>    
13371>>>    Function ItemValue Returns String 
13373>>>        Char[] sTmp 
13374>>>        Get psOutput to sTmp 
13375>>>        Function_Return (Character(sTmp[(piPos(Self))-1]))
13376>>>    End_Function
13377>>>End_Class
13378>>>
13378>>>Class cTextFileIterator is a cIterator
13379>>>    Procedure construct_object 
13381>>>        Forward Send construct_object 
13383>>>        Property Integer piChannel
13384>>>        Property String psName 
13385>>>        Property Boolean pisOpened 
13386>>>        Property Boolean pisFinished
13387>>>        Property String psCurrentLine 
13388>>>    End_Procedure
13389>>>
13389>>>    Procedure InitialiseObject String sName 
13391>>>        Integer iChannel 
13391>>>        Move (Seq_New_Channel()) to iChannel 
13392>>>        Set piChannel to iChannel 
13393>>>        Set psName to sName 
13394>>>        Set pisOpened to False 
13395>>>    End_Procedure
13396>>>
13396>>>    Function NextItem Returns Boolean
13398>>>        String sTmp 
13398>>>        If (pisFinished(Self)) Function_Return (False) 
13401>>>
13401>>>        Readln sTmp 
13402>>>        If (SeqEof) Set pisFinished to (True) 
13405>>>        Set psCurrentLine to sTmp 
13406>>>
13406>>>        Function_Return ( (not(pisFinished(Self))) or (sTmp<>"") )
13407>>>    End_Function 
13408>>>
13408>>>    Function FirstItem Returns Boolean
13410>>>        Boolean isOK 
13410>>>        If (pisOpened(Self)) Close_Output channel (piChannel(Self))
13414>>>        File_Exist (psName(Self)) isOK 
13415>>>        If (not(isOK)) Function_Return (False) 
13418>>>        
13418>>>        Set pisFinished to False 
13419>>>        Direct_Input channel (piChannel(Self)) (psName(Self)) 
13421>>>        Function_Return (NextItem(Self))
13422>>>    End_Function 
13423>>>    
13423>>>    Function ItemValue Returns Variant
13425>>>        Function_Return (psCurrentLine(Self)) 
13426>>>    End_Function
13427>>>    
13427>>>    Procedure Destroy_Object
13429>>>        Integer iChannel 
13429>>>        
13429>>>        Get piChannel to iChannel 
13430>>>        Send Seq_Release_Channel iChannel 
13431>>>        
13431>>>        Forward Send Destroy_Object 
13433>>>    End_Procedure
13434>>>End_Class
13435>>>
13435>>>Class cArrayIterator is a cObject
13436>>>    Procedure construct_object 
13438>>>        Forward Send construct_object 
13440>>>        Property Variant[] paList
13441>>>        Property Variant paReturn 
13442>>>        Property Integer piItem 
13443>>>    End_Procedure
13444>>>
13444>>>    Procedure InitialiseObject Variant[] aList 
13446>>>        Set paList to aList 
13447>>>    End_Procedure
13448>>>
13448>>>    Function NextItem Returns Boolean
13450>>>        Integer iItem 
13450>>>        Variant[] aList
13451>>>
13451>>>        Get paList to aList 
13452>>>        Get piItem to iItem 
13453>>>        
13453>>>        If (iItem >= (SizeOfArray(aList))) Function_Return False 
13456>>>        
13456>>>        Set paReturn to aList[iItem]
13457>>>        Set piItem to (iItem+1) 
13458>>>        
13458>>>        Function_Return True 
13459>>>    End_Function 
13460>>>    
13460>>>    Function FirstItem Returns Boolean
13462>>>        Variant[] aList
13463>>>        Get paList to aList 
13464>>>        Set piItem to 1 
13465>>>        
13465>>>        If ((SizeOfArray(aList)) = 0) Function_Return (False) 
13468>>>        
13468>>>        Set paReturn to aList[0]
13469>>>        Function_Return True 
13470>>>    End_Function 
13471>>>    
13471>>>    Function ItemValue Returns Variant
13473>>>        Function_Return (paReturn(Self))
13474>>>    End_Function
13475>>>
13475>>>    Procedure Destroy_Object
13477>>>        Forward Send Destroy_Object 
13479>>>    End_Procedure
13480>>>End_Class
13481>>>
13481>>>Class cQueuedDataDictionaryIterator is a cIterator
13482>>>    Procedure construct_object 
13484>>>        Forward Send construct_object 
13486>>>        Property Integer phDD 
13487>>>        Property Integer piIndex 
13488>>>        Property RowID[] paRows
13489>>>        Property RowID priReturn 
13490>>>        Property Integer piItem 
13491>>>    End_Procedure
13492>>>    
13492>>>    Procedure InitialiseObject Integer hDD Integer iIndex 
13494>>>        RowID[] aRows
13495>>>        RowID riRow
13495>>>        Integer iPos 
13495>>>        
13495>>>        Set phDD to hDD 
13496>>>        Set piIndex to iIndex
13497>>>        
13497>>>        Move 0 to iPos 
13498>>>        Send Request_Clear to (phDD(Self)) 
13499>>>        Send Request_Find to (phDD(Self)) GT (Main_File(phDD(Self))) (piIndex(Self))
13500>>>        While (Found)
13504>>>            Move (CurrentRowId(phDD(Self))) to riRow 
13505>>>            Move (&riRow) to aRows[iPos]
13506>>>            
13506>>>            Move (iPos+1) to iPos 
13507>>>            Send Request_Find to (phDD(Self)) GT (Main_File(phDD(Self))) (piIndex(Self))
13508>>>        Loop
13509>>>>
13509>>>        
13509>>>        Set paRows to aRows 
13510>>>    End_Procedure
13511>>>    
13511>>>    Function NextItem Returns Boolean
13513>>>        Integer iItem 
13513>>>        RowID[] aRows
13514>>>
13514>>>        Get paRows to aRows 
13515>>>        Get piItem to iItem 
13516>>>        
13516>>>        If (iItem >= (SizeOfArray(aRows))) Function_Return False 
13519>>>        
13519>>>        Set priReturn to aRows[iItem]
13520>>>        Set piItem to (iItem+1) 
13521>>>        
13521>>>        Function_Return True 
13522>>>    End_Function 
13523>>>    
13523>>>    Function FirstItem Returns Boolean
13525>>>        RowID[] aRows
13526>>>        Get paRows to aRows 
13527>>>        Set piItem to 1 
13528>>>        
13528>>>        If ((SizeOfArray(aRows)) = 0) Function_Return (False) 
13531>>>        
13531>>>        Set priReturn to aRows[0]
13532>>>        Function_Return True 
13533>>>    End_Function 
13534>>>
13534>>>    Function ItemValue Returns RowID
13536>>>        RowID riRow 
13536>>>        
13536>>>        Move (priReturn(Self)) to riRow 
13537>>>        Send FindByRowId to (phDD(Self)) (Main_File(phDD(Self))) riRow 
13538>>>        
13538>>>        Function_Return riRow 
13539>>>    End_Function
13540>>>    
13540>>>End_Class
13541>>>
13541>>>Class cDataFileIterator is a cIterator
13542>>>    Procedure construct_object 
13544>>>        Forward Send construct_object 
13546>>>        Property Integer phFileNumber
13547>>>        Property Integer piIndex
13548>>>    End_Procedure
13549>>>    
13549>>>    Procedure InitialiseObject Integer hFile Integer iIndex 
13551>>>        Set phFileNumber to hFile 
13552>>>        Set piIndex to iIndex 
13553>>>    End_Procedure
13554>>>
13554>>>    Function NextItem Returns Boolean
13556>>>        Constrained_Find gt (phFileNumber(Self)) by (piIndex(Self))
13560>>>        Function_Return (Found)
13561>>>    End_Function 
13562>>>    
13562>>>    Function FirstItem Returns Boolean
13564>>>        Constrained_Clear GE (phFileNumber(Self)) by (piIndex(Self))
13567>>>        Constrained_Find First (phFileNumber(Self)) by (piIndex(Self))
13572>>>        Function_Return (Found)
13573>>>    End_Function 
13574>>>    
13574>>>    Function ItemValue Returns Variant
13576>>>        Function_Return (GetRowId( (phFileNumber(Self)) ))
13577>>>    End_Function
13578>>>End_Class
13579>Use cTestDataDictionary.dd
Including file: cTestDataDictionary.dd    (C:\data\VDF\ForEach\DDSrc\cTestDataDictionary.dd)
13579>>>Use Datadict.pkg
13579>>>
13579>>>Open Test
Including file: Test.fd    (C:\data\VDF\ForEach\DDSrc\Test.fd)
13581>>>
13581>>>Class cTestDataDictionary is a DataDictionary
13582>>>    
13582>>>    Procedure Construct_Object
13584>>>        Forward Send Construct_Object
13586>>>        Set Main_File to Test.File_Number
13587>>>
13587>>>        Set Foreign_Field_Option DD_KEYFIELD DD_NOPUT to True
13588>>>        Set Foreign_Field_Option DD_KEYFIELD DD_FINDREQ to True
13589>>>        Set Foreign_Field_Option DD_INDEXFIELD DD_NOPUT to True
13590>>>        Set Foreign_Field_Option DD_DEFAULT DD_DISPLAYONLY to True
13591>>>
13591>>>    End_Procedure
13592>>>
13592>>>End_Class
13593>
13593>Object oTest is a cObject
13595>    Object oTest_DD is a cTestDataDictionary
13597>    End_Object 
13598>    
13598>    Procedure Demonstrate_freach
13601>        String sPos 
13601>        Integer iRecnum 
13601>        RowID riRow
13601>        Variant[] aList 
13602>        
13602>        Showln "For each character in a string"
13604>        Showln "==========================================="
13606>        for_each StringChar sPos in "This is a string" 
13610>            Showln "we'll be constraining here"
13612>        And_Do
13613>           Show sPos "-"
13615>        end_for_each 
13629>
13629>        Showln ""
13631>        Showln ""
13633>        
13633>        Showln "Data Dictionary - index.2"
13635>        Showln "==========================================="
13637>        for_each DataDictionary riRow in (oTest_DD(Self)) Index.2  DO
13641>            Showln (SerializeRowID(riRow)) ":" Test.Description
13645>        end_for_each 
13656>        Showln ""
13658>        
13658>        Showln "For data files = index.2"
13660>        for_each DataFile riRow in test.file_number Index.2  DO
13664>            Showln (SerializeRowID(riRow)) ":" Test.Description
13668>        end_for_each 
13679>        Showln ""
13681>        
13681>        Showln "For data files = index.2 - constrained > S"
13683>        for_each DataFile riRow in test.file_number Index.2  
13687>            showln "first we constrain"
13689>            Constrain Test.Description gt "S"
13691>        AND_DO
13692>            Showln (SerializeRowID(riRow)) ":" Test.Description
13696>        end_for_each 
13710>        Showln ""
13712>        
13712>        Showln "Queued Data Dictionary - index.2"
13714>        Showln "Doesn't matter if we lose our place with clear or saves"
13716>        Showln "==========================================="
13718>        for_each QueuedDataDictionary riRow in (oTest_DD(Self)) Index.2  DO
13722>            Showln (SerializeRowID(riRow)) ":" Test.Description
13726>            Send Request_Clear to oTest_DD
13727>            Clear Test
13728>        end_for_each 
13739>        Showln ""
13741>        
13741>        String sFile 
13741>        Move ((psDataPath(phoWorkspace(oApplication))) + "\test.txt") to sFile 
13742>        Showln "Text file"
13744>        Showln "==========================================="
13746>        for_each TextFile sPos in sFile  "test.txt"  DO
13750>           Showln sPos 
13752>        end_for_each 
13763>        Showln ""
13765>        
13765>        Showln "Array - we populate an array, then use for_each"
13767>        Showln "==========================================="
13769>        Move "hello" to aList[0]
13770>        Move "world" to aList[1]
13771>        for_each array sPos in aList  DO
13775>           Showln sPos 
13777>        end_for_each 
13788>    End_Procedure
13789>    Send Demonstrate_freach
13790>End_Object
13791>
13791>Object oPanel is a BasicPanel
13793>    Set Size to 100 100 
13794>    Set Label to "Demonstarting the iterator"
13795>End_Object
13796>Start_UI oPanel 
13798>
Summary
Memory Available: 2147483647
Total Warnings : 0
Total Errors   : 0
Total Symbols  : 11757
Total Resources: 0
Total Commands : 13797
Total Windows  : 1
Total Pages    : 1
Static Data    : 102917
Message area   : 76209
Total Blocks   : 6233
